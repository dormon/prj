#pragma once

#include<geCore/Command.h>
#include<geGL/Export.h>
#include<GL/glew.h>
#include<geGL/AllAttribs.h>

namespace ge{
  namespace gl{
    template<
      typename TEXTURE_TYPE = GLuint        ,
      typename PNAME_TYPE   = GLenum        ,
      typename PARAM_TYPE   = const GLfloat*>
    class TextureParameterfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "param"  )return(void*)&this->param  ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        PNAME_TYPE   pname  ;
        PARAM_TYPE   param  ;
        TextureParameterfv(
            TEXTURE_TYPE const&texture,
            PNAME_TYPE   const&pname  ,
            PARAM_TYPE   const&param  ){
          this->texture = texture;
          this->pname   = pname  ;
          this->param   = param  ;
        }
        virtual~TextureParameterfv(){}
        virtual void operator()(){
          glTextureParameterfv(
            ge::core::convertTo<GLuint        >(this->texture),
            ge::core::convertTo<GLenum        >(this->pname  ),
            ge::core::convertTo<const GLfloat*>(this->param  )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLuint,
      typename Y_TYPE     = GLuint,
      typename Z_TYPE     = GLuint>
    class VertexAttribI3ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        VertexAttribI3ui(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
        }
        virtual~VertexAttribI3ui(){}
        virtual void operator()(){
          glVertexAttribI3ui(
            ge::core::convertTo<GLuint>(this->index),
            ge::core::convertTo<GLuint>(this->x    ),
            ge::core::convertTo<GLuint>(this->y    ),
            ge::core::convertTo<GLuint>(this->z    )
          );
        }
    };

    template<
      typename VAOBJ_TYPE  = GLuint,
      typename BUFFER_TYPE = GLuint>
    class VertexArrayElementBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj" )return(void*)&this->vaobj ;
          if(name == "buffer")return(void*)&this->buffer;
          return NULL;
        }
      public:
        VAOBJ_TYPE  vaobj ;
        BUFFER_TYPE buffer;
        VertexArrayElementBuffer(
            VAOBJ_TYPE  const&vaobj ,
            BUFFER_TYPE const&buffer){
          this->vaobj  = vaobj ;
          this->buffer = buffer;
        }
        virtual~VertexArrayElementBuffer(){}
        virtual void operator()(){
          glVertexArrayElementBuffer(
            ge::core::convertTo<GLuint>(this->vaobj ),
            ge::core::convertTo<GLuint>(this->buffer)
          );
        }
    };

    template<
      typename FACE_TYPE = GLenum,
      typename MASK_TYPE = GLuint>
    class StencilMaskSeparate:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "face")return(void*)&this->face;
          if(name == "mask")return(void*)&this->mask;
          return NULL;
        }
      public:
        FACE_TYPE face;
        MASK_TYPE mask;
        StencilMaskSeparate(
            FACE_TYPE const&face,
            MASK_TYPE const&mask){
          this->face = face;
          this->mask = mask;
        }
        virtual~StencilMaskSeparate(){}
        virtual void operator()(){
          glStencilMaskSeparate(
            ge::core::convertTo<GLenum>(this->face),
            ge::core::convertTo<GLuint>(this->mask)
          );
        }
    };

    template<
      typename TEXTURE_TYPE              = GLuint   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename DEPTH_TYPE                = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    class TextureStorage3DMultisample:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture"             )return(void*)&this->texture             ;
          if(name == "samples"             )return(void*)&this->samples             ;
          if(name == "internalformat"      )return(void*)&this->internalformat      ;
          if(name == "width"               )return(void*)&this->width               ;
          if(name == "height"              )return(void*)&this->height              ;
          if(name == "depth"               )return(void*)&this->depth               ;
          if(name == "fixedsamplelocations")return(void*)&this->fixedsamplelocations;
          return NULL;
        }
      public:
        TEXTURE_TYPE              texture             ;
        SAMPLES_TYPE              samples             ;
        INTERNALFORMAT_TYPE       internalformat      ;
        WIDTH_TYPE                width               ;
        HEIGHT_TYPE               height              ;
        DEPTH_TYPE                depth               ;
        FIXEDSAMPLELOCATIONS_TYPE fixedsamplelocations;
        TextureStorage3DMultisample(
            TEXTURE_TYPE              const&texture             ,
            SAMPLES_TYPE              const&samples             ,
            INTERNALFORMAT_TYPE       const&internalformat      ,
            WIDTH_TYPE                const&width               ,
            HEIGHT_TYPE               const&height              ,
            DEPTH_TYPE                const&depth               ,
            FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
          this->texture              = texture             ;
          this->samples              = samples             ;
          this->internalformat       = internalformat      ;
          this->width                = width               ;
          this->height               = height              ;
          this->depth                = depth               ;
          this->fixedsamplelocations = fixedsamplelocations;
        }
        virtual~TextureStorage3DMultisample(){}
        virtual void operator()(){
          glTextureStorage3DMultisample(
            ge::core::convertTo<GLuint   >(this->texture             ),
            ge::core::convertTo<GLsizei  >(this->samples             ),
            ge::core::convertTo<GLenum   >(this->internalformat      ),
            ge::core::convertTo<GLsizei  >(this->width               ),
            ge::core::convertTo<GLsizei  >(this->height              ),
            ge::core::convertTo<GLsizei  >(this->depth               ),
            ge::core::convertTo<GLboolean>(this->fixedsamplelocations)
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVEL_TYPE          = GLint  ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename X_TYPE              = GLint  ,
      typename Y_TYPE              = GLint  ,
      typename WIDTH_TYPE          = GLsizei,
      typename BORDER_TYPE         = GLint  >
    class CopyTexImage1D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "level"         )return(void*)&this->level         ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "x"             )return(void*)&this->x             ;
          if(name == "y"             )return(void*)&this->y             ;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "border"        )return(void*)&this->border        ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        LEVEL_TYPE          level         ;
        INTERNALFORMAT_TYPE internalformat;
        X_TYPE              x             ;
        Y_TYPE              y             ;
        WIDTH_TYPE          width         ;
        BORDER_TYPE         border        ;
        CopyTexImage1D(
            TARGET_TYPE         const&target        ,
            LEVEL_TYPE          const&level         ,
            INTERNALFORMAT_TYPE const&internalformat,
            X_TYPE              const&x             ,
            Y_TYPE              const&y             ,
            WIDTH_TYPE          const&width         ,
            BORDER_TYPE         const&border        ){
          this->target         = target        ;
          this->level          = level         ;
          this->internalformat = internalformat;
          this->x              = x             ;
          this->y              = y             ;
          this->width          = width         ;
          this->border         = border        ;
        }
        virtual~CopyTexImage1D(){}
        virtual void operator()(){
          glCopyTexImage1D(
            ge::core::convertTo<GLenum >(this->target        ),
            ge::core::convertTo<GLint  >(this->level         ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLint  >(this->x             ),
            ge::core::convertTo<GLint  >(this->y             ),
            ge::core::convertTo<GLsizei>(this->width         ),
            ge::core::convertTo<GLint  >(this->border        )
          );
        }
    };

    template<
      typename VALUE_TYPE = GLfloat>
    class MinSampleShading:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "value")return(void*)&this->value;
          return NULL;
        }
      public:
        VALUE_TYPE value;
        MinSampleShading(
            VALUE_TYPE const&value){
          this->value = value;
        }
        virtual~MinSampleShading(){}
        virtual void operator()(){
          glMinSampleShading(
            ge::core::convertTo<GLfloat>(this->value)
          );
        }
    };

    template<
      typename TARGET_TYPE             = GLenum,
      typename ATTACHMENT_TYPE         = GLenum,
      typename RENDERBUFFERTARGET_TYPE = GLenum,
      typename RENDERBUFFER_TYPE       = GLuint>
    class FramebufferRenderbuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"            )return(void*)&this->target            ;
          if(name == "attachment"        )return(void*)&this->attachment        ;
          if(name == "renderbuffertarget")return(void*)&this->renderbuffertarget;
          if(name == "renderbuffer"      )return(void*)&this->renderbuffer      ;
          return NULL;
        }
      public:
        TARGET_TYPE             target            ;
        ATTACHMENT_TYPE         attachment        ;
        RENDERBUFFERTARGET_TYPE renderbuffertarget;
        RENDERBUFFER_TYPE       renderbuffer      ;
        FramebufferRenderbuffer(
            TARGET_TYPE             const&target            ,
            ATTACHMENT_TYPE         const&attachment        ,
            RENDERBUFFERTARGET_TYPE const&renderbuffertarget,
            RENDERBUFFER_TYPE       const&renderbuffer      ){
          this->target             = target            ;
          this->attachment         = attachment        ;
          this->renderbuffertarget = renderbuffertarget;
          this->renderbuffer       = renderbuffer      ;
        }
        virtual~FramebufferRenderbuffer(){}
        virtual void operator()(){
          glFramebufferRenderbuffer(
            ge::core::convertTo<GLenum>(this->target            ),
            ge::core::convertTo<GLenum>(this->attachment        ),
            ge::core::convertTo<GLenum>(this->renderbuffertarget),
            ge::core::convertTo<GLuint>(this->renderbuffer      )
          );
        }
    };

    template<
      typename SHADERTYPE_TYPE = GLenum       ,
      typename COUNT_TYPE      = GLsizei      ,
      typename INDICES_TYPE    = const GLuint*>
    class UniformSubroutinesuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "shadertype")return(void*)&this->shadertype;
          if(name == "count"     )return(void*)&this->count     ;
          if(name == "indices"   )return(void*)&this->indices   ;
          return NULL;
        }
      public:
        SHADERTYPE_TYPE shadertype;
        COUNT_TYPE      count     ;
        INDICES_TYPE    indices   ;
        UniformSubroutinesuiv(
            SHADERTYPE_TYPE const&shadertype,
            COUNT_TYPE      const&count     ,
            INDICES_TYPE    const&indices   ){
          this->shadertype = shadertype;
          this->count      = count     ;
          this->indices    = indices   ;
        }
        virtual~UniformSubroutinesuiv(){}
        virtual void operator()(){
          glUniformSubroutinesuiv(
            ge::core::convertTo<GLenum       >(this->shadertype),
            ge::core::convertTo<GLsizei      >(this->count     ),
            ge::core::convertTo<const GLuint*>(this->indices   )
          );
        }
    };

    template<
      typename TARGET_TYPE    = GLenum     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename YOFFSET_TYPE   = GLint      ,
      typename ZOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename HEIGHT_TYPE    = GLsizei    ,
      typename DEPTH_TYPE     = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    class CompressedTexSubImage3D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"   )return(void*)&this->target   ;
          if(name == "level"    )return(void*)&this->level    ;
          if(name == "xoffset"  )return(void*)&this->xoffset  ;
          if(name == "yoffset"  )return(void*)&this->yoffset  ;
          if(name == "zoffset"  )return(void*)&this->zoffset  ;
          if(name == "width"    )return(void*)&this->width    ;
          if(name == "height"   )return(void*)&this->height   ;
          if(name == "depth"    )return(void*)&this->depth    ;
          if(name == "format"   )return(void*)&this->format   ;
          if(name == "imageSize")return(void*)&this->imageSize;
          if(name == "data"     )return(void*)&this->data     ;
          return NULL;
        }
      public:
        TARGET_TYPE    target   ;
        LEVEL_TYPE     level    ;
        XOFFSET_TYPE   xoffset  ;
        YOFFSET_TYPE   yoffset  ;
        ZOFFSET_TYPE   zoffset  ;
        WIDTH_TYPE     width    ;
        HEIGHT_TYPE    height   ;
        DEPTH_TYPE     depth    ;
        FORMAT_TYPE    format   ;
        IMAGESIZE_TYPE imageSize;
        DATA_TYPE      data     ;
        CompressedTexSubImage3D(
            TARGET_TYPE    const&target   ,
            LEVEL_TYPE     const&level    ,
            XOFFSET_TYPE   const&xoffset  ,
            YOFFSET_TYPE   const&yoffset  ,
            ZOFFSET_TYPE   const&zoffset  ,
            WIDTH_TYPE     const&width    ,
            HEIGHT_TYPE    const&height   ,
            DEPTH_TYPE     const&depth    ,
            FORMAT_TYPE    const&format   ,
            IMAGESIZE_TYPE const&imageSize,
            DATA_TYPE      const&data     ){
          this->target    = target   ;
          this->level     = level    ;
          this->xoffset   = xoffset  ;
          this->yoffset   = yoffset  ;
          this->zoffset   = zoffset  ;
          this->width     = width    ;
          this->height    = height   ;
          this->depth     = depth    ;
          this->format    = format   ;
          this->imageSize = imageSize;
          this->data      = data     ;
        }
        virtual~CompressedTexSubImage3D(){}
        virtual void operator()(){
          glCompressedTexSubImage3D(
            ge::core::convertTo<GLenum     >(this->target   ),
            ge::core::convertTo<GLint      >(this->level    ),
            ge::core::convertTo<GLint      >(this->xoffset  ),
            ge::core::convertTo<GLint      >(this->yoffset  ),
            ge::core::convertTo<GLint      >(this->zoffset  ),
            ge::core::convertTo<GLsizei    >(this->width    ),
            ge::core::convertTo<GLsizei    >(this->height   ),
            ge::core::convertTo<GLsizei    >(this->depth    ),
            ge::core::convertTo<GLenum     >(this->format   ),
            ge::core::convertTo<GLsizei    >(this->imageSize),
            ge::core::convertTo<const void*>(this->data     )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum   ,
      typename INDEX_TYPE  = GLuint   ,
      typename DATA_TYPE   = GLdouble*>
    class GetDoublei_v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          if(name == "data"  )return(void*)&this->data  ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        DATA_TYPE   data  ;
        GetDoublei_v(
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ,
            DATA_TYPE   const&data  ){
          this->target = target;
          this->index  = index ;
          this->data   = data  ;
        }
        virtual~GetDoublei_v(){}
        virtual void operator()(){
          glGetDoublei_v(
            ge::core::convertTo<GLenum   >(this->target),
            ge::core::convertTo<GLuint   >(this->index ),
            ge::core::convertTo<GLdouble*>(this->data  )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    class VertexAttrib1sv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib1sv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib1sv(){}
        virtual void operator()(){
          glVertexAttrib1sv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLshort*>(this->v    )
          );
        }
    };

    template<
      typename VAOBJ_TYPE   = GLuint         ,
      typename FIRST_TYPE   = GLuint         ,
      typename COUNT_TYPE   = GLsizei        ,
      typename BUFFERS_TYPE = const GLuint*  ,
      typename OFFSETS_TYPE = const GLintptr*,
      typename STRIDES_TYPE = const GLsizei* >
    class VertexArrayVertexBuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj"  )return(void*)&this->vaobj  ;
          if(name == "first"  )return(void*)&this->first  ;
          if(name == "count"  )return(void*)&this->count  ;
          if(name == "buffers")return(void*)&this->buffers;
          if(name == "offsets")return(void*)&this->offsets;
          if(name == "strides")return(void*)&this->strides;
          return NULL;
        }
      public:
        VAOBJ_TYPE   vaobj  ;
        FIRST_TYPE   first  ;
        COUNT_TYPE   count  ;
        BUFFERS_TYPE buffers;
        OFFSETS_TYPE offsets;
        STRIDES_TYPE strides;
        VertexArrayVertexBuffers(
            VAOBJ_TYPE   const&vaobj  ,
            FIRST_TYPE   const&first  ,
            COUNT_TYPE   const&count  ,
            BUFFERS_TYPE const&buffers,
            OFFSETS_TYPE const&offsets,
            STRIDES_TYPE const&strides){
          this->vaobj   = vaobj  ;
          this->first   = first  ;
          this->count   = count  ;
          this->buffers = buffers;
          this->offsets = offsets;
          this->strides = strides;
        }
        virtual~VertexArrayVertexBuffers(){}
        virtual void operator()(){
          glVertexArrayVertexBuffers(
            ge::core::convertTo<GLuint         >(this->vaobj  ),
            ge::core::convertTo<GLuint         >(this->first  ),
            ge::core::convertTo<GLsizei        >(this->count  ),
            ge::core::convertTo<const GLuint*  >(this->buffers),
            ge::core::convertTo<const GLintptr*>(this->offsets),
            ge::core::convertTo<const GLsizei* >(this->strides)
          );
        }
    };

    template<
      typename UNIT_TYPE    = GLuint,
      typename SAMPLER_TYPE = GLuint>
    class BindSampler:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "unit"   )return(void*)&this->unit   ;
          if(name == "sampler")return(void*)&this->sampler;
          return NULL;
        }
      public:
        UNIT_TYPE    unit   ;
        SAMPLER_TYPE sampler;
        BindSampler(
            UNIT_TYPE    const&unit   ,
            SAMPLER_TYPE const&sampler){
          this->unit    = unit   ;
          this->sampler = sampler;
        }
        virtual~BindSampler(){}
        virtual void operator()(){
          glBindSampler(
            ge::core::convertTo<GLuint>(this->unit   ),
            ge::core::convertTo<GLuint>(this->sampler)
          );
        }
    };

    template<
      typename WIDTH_TYPE = GLfloat>
    class LineWidth:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "width")return(void*)&this->width;
          return NULL;
        }
      public:
        WIDTH_TYPE width;
        LineWidth(
            WIDTH_TYPE const&width){
          this->width = width;
        }
        virtual~LineWidth(){}
        virtual void operator()(){
          glLineWidth(
            ge::core::convertTo<GLfloat>(this->width)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint,
      typename DATA_TYPE   = GLint*>
    class GetIntegeri_v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          if(name == "data"  )return(void*)&this->data  ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        DATA_TYPE   data  ;
        GetIntegeri_v(
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ,
            DATA_TYPE   const&data  ){
          this->target = target;
          this->index  = index ;
          this->data   = data  ;
        }
        virtual~GetIntegeri_v(){}
        virtual void operator()(){
          glGetIntegeri_v(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLuint>(this->index ),
            ge::core::convertTo<GLint*>(this->data  )
          );
        }
    };

    template<
      typename SHADER_TYPE = GLuint>
    class CompileShader:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "shader")return(void*)&this->shader;
          return NULL;
        }
      public:
        SHADER_TYPE shader;
        CompileShader(
            SHADER_TYPE const&shader){
          this->shader = shader;
        }
        virtual~CompileShader(){}
        virtual void operator()(){
          glCompileShader(
            ge::core::convertTo<GLuint>(this->shader)
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint  ,
      typename INDEX_TYPE   = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename SIZE_TYPE    = GLsizei*,
      typename TYPE_TYPE    = GLenum* ,
      typename NAME_TYPE    = GLchar* >
    class GetTransformFeedbackVarying:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          if(name == "index"  )return(void*)&this->index  ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "length" )return(void*)&this->length ;
          if(name == "size"   )return(void*)&this->size   ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "name"   )return(void*)&this->name   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        INDEX_TYPE   index  ;
        BUFSIZE_TYPE bufSize;
        LENGTH_TYPE  length ;
        SIZE_TYPE    size   ;
        TYPE_TYPE    type   ;
        NAME_TYPE    name   ;
        GetTransformFeedbackVarying(
            PROGRAM_TYPE const&program,
            INDEX_TYPE   const&index  ,
            BUFSIZE_TYPE const&bufSize,
            LENGTH_TYPE  const&length ,
            SIZE_TYPE    const&size   ,
            TYPE_TYPE    const&type   ,
            NAME_TYPE    const&name   ){
          this->program = program;
          this->index   = index  ;
          this->bufSize = bufSize;
          this->length  = length ;
          this->size    = size   ;
          this->type    = type   ;
          this->name    = name   ;
        }
        virtual~GetTransformFeedbackVarying(){}
        virtual void operator()(){
          glGetTransformFeedbackVarying(
            ge::core::convertTo<GLuint  >(this->program),
            ge::core::convertTo<GLuint  >(this->index  ),
            ge::core::convertTo<GLsizei >(this->bufSize),
            ge::core::convertTo<GLsizei*>(this->length ),
            ge::core::convertTo<GLsizei*>(this->size   ),
            ge::core::convertTo<GLenum* >(this->type   ),
            ge::core::convertTo<GLchar* >(this->name   )
          );
        }
    };

    template<
      typename TEXTURE_TYPE   = GLuint     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename YOFFSET_TYPE   = GLint      ,
      typename ZOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename HEIGHT_TYPE    = GLsizei    ,
      typename DEPTH_TYPE     = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    class CompressedTextureSubImage3D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture"  )return(void*)&this->texture  ;
          if(name == "level"    )return(void*)&this->level    ;
          if(name == "xoffset"  )return(void*)&this->xoffset  ;
          if(name == "yoffset"  )return(void*)&this->yoffset  ;
          if(name == "zoffset"  )return(void*)&this->zoffset  ;
          if(name == "width"    )return(void*)&this->width    ;
          if(name == "height"   )return(void*)&this->height   ;
          if(name == "depth"    )return(void*)&this->depth    ;
          if(name == "format"   )return(void*)&this->format   ;
          if(name == "imageSize")return(void*)&this->imageSize;
          if(name == "data"     )return(void*)&this->data     ;
          return NULL;
        }
      public:
        TEXTURE_TYPE   texture  ;
        LEVEL_TYPE     level    ;
        XOFFSET_TYPE   xoffset  ;
        YOFFSET_TYPE   yoffset  ;
        ZOFFSET_TYPE   zoffset  ;
        WIDTH_TYPE     width    ;
        HEIGHT_TYPE    height   ;
        DEPTH_TYPE     depth    ;
        FORMAT_TYPE    format   ;
        IMAGESIZE_TYPE imageSize;
        DATA_TYPE      data     ;
        CompressedTextureSubImage3D(
            TEXTURE_TYPE   const&texture  ,
            LEVEL_TYPE     const&level    ,
            XOFFSET_TYPE   const&xoffset  ,
            YOFFSET_TYPE   const&yoffset  ,
            ZOFFSET_TYPE   const&zoffset  ,
            WIDTH_TYPE     const&width    ,
            HEIGHT_TYPE    const&height   ,
            DEPTH_TYPE     const&depth    ,
            FORMAT_TYPE    const&format   ,
            IMAGESIZE_TYPE const&imageSize,
            DATA_TYPE      const&data     ){
          this->texture   = texture  ;
          this->level     = level    ;
          this->xoffset   = xoffset  ;
          this->yoffset   = yoffset  ;
          this->zoffset   = zoffset  ;
          this->width     = width    ;
          this->height    = height   ;
          this->depth     = depth    ;
          this->format    = format   ;
          this->imageSize = imageSize;
          this->data      = data     ;
        }
        virtual~CompressedTextureSubImage3D(){}
        virtual void operator()(){
          glCompressedTextureSubImage3D(
            ge::core::convertTo<GLuint     >(this->texture  ),
            ge::core::convertTo<GLint      >(this->level    ),
            ge::core::convertTo<GLint      >(this->xoffset  ),
            ge::core::convertTo<GLint      >(this->yoffset  ),
            ge::core::convertTo<GLint      >(this->zoffset  ),
            ge::core::convertTo<GLsizei    >(this->width    ),
            ge::core::convertTo<GLsizei    >(this->height   ),
            ge::core::convertTo<GLsizei    >(this->depth    ),
            ge::core::convertTo<GLenum     >(this->format   ),
            ge::core::convertTo<GLsizei    >(this->imageSize),
            ge::core::convertTo<const void*>(this->data     )
          );
        }
    };

    template<
      typename XFB_TYPE    = GLuint    ,
      typename INDEX_TYPE  = GLuint    ,
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr>
    class TransformFeedbackBufferRange:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "xfb"   )return(void*)&this->xfb   ;
          if(name == "index" )return(void*)&this->index ;
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "offset")return(void*)&this->offset;
          if(name == "size"  )return(void*)&this->size  ;
          return NULL;
        }
      public:
        XFB_TYPE    xfb   ;
        INDEX_TYPE  index ;
        BUFFER_TYPE buffer;
        OFFSET_TYPE offset;
        SIZE_TYPE   size  ;
        TransformFeedbackBufferRange(
            XFB_TYPE    const&xfb   ,
            INDEX_TYPE  const&index ,
            BUFFER_TYPE const&buffer,
            OFFSET_TYPE const&offset,
            SIZE_TYPE   const&size  ){
          this->xfb    = xfb   ;
          this->index  = index ;
          this->buffer = buffer;
          this->offset = offset;
          this->size   = size  ;
        }
        virtual~TransformFeedbackBufferRange(){}
        virtual void operator()(){
          glTransformFeedbackBufferRange(
            ge::core::convertTo<GLuint    >(this->xfb   ),
            ge::core::convertTo<GLuint    >(this->index ),
            ge::core::convertTo<GLuint    >(this->buffer),
            ge::core::convertTo<GLintptr  >(this->offset),
            ge::core::convertTo<GLsizeiptr>(this->size  )
          );
        }
    };

    template<
      typename N_TYPE = GLfloat,
      typename F_TYPE = GLfloat>
    class DepthRangef:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n")return(void*)&this->n;
          if(name == "f")return(void*)&this->f;
          return NULL;
        }
      public:
        N_TYPE n;
        F_TYPE f;
        DepthRangef(
            N_TYPE const&n,
            F_TYPE const&f){
          this->n = n;
          this->f = f;
        }
        virtual~DepthRangef(){}
        virtual void operator()(){
          glDepthRangef(
            ge::core::convertTo<GLfloat>(this->n),
            ge::core::convertTo<GLfloat>(this->f)
          );
        }
    };

    template<
      typename INDEX_TYPE   = GLuint     ,
      typename SIZE_TYPE    = GLint      ,
      typename TYPE_TYPE    = GLenum     ,
      typename STRIDE_TYPE  = GLsizei    ,
      typename POINTER_TYPE = const void*>
    class VertexAttribIPointer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"  )return(void*)&this->index  ;
          if(name == "size"   )return(void*)&this->size   ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "stride" )return(void*)&this->stride ;
          if(name == "pointer")return(void*)&this->pointer;
          return NULL;
        }
      public:
        INDEX_TYPE   index  ;
        SIZE_TYPE    size   ;
        TYPE_TYPE    type   ;
        STRIDE_TYPE  stride ;
        POINTER_TYPE pointer;
        VertexAttribIPointer(
            INDEX_TYPE   const&index  ,
            SIZE_TYPE    const&size   ,
            TYPE_TYPE    const&type   ,
            STRIDE_TYPE  const&stride ,
            POINTER_TYPE const&pointer){
          this->index   = index  ;
          this->size    = size   ;
          this->type    = type   ;
          this->stride  = stride ;
          this->pointer = pointer;
        }
        virtual~VertexAttribIPointer(){}
        virtual void operator()(){
          glVertexAttribIPointer(
            ge::core::convertTo<GLuint     >(this->index  ),
            ge::core::convertTo<GLint      >(this->size   ),
            ge::core::convertTo<GLenum     >(this->type   ),
            ge::core::convertTo<GLsizei    >(this->stride ),
            ge::core::convertTo<const void*>(this->pointer)
          );
        }
    };

    template<
      typename BUFFER_TYPE = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetNamedBufferParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        BUFFER_TYPE buffer;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetNamedBufferParameteriv(
            BUFFER_TYPE const&buffer,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->buffer = buffer;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetNamedBufferParameteriv(){}
        virtual void operator()(){
          glGetNamedBufferParameteriv(
            ge::core::convertTo<GLuint>(this->buffer),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    template<
      typename MODE_TYPE          = GLenum     ,
      typename COUNT_TYPE         = GLsizei    ,
      typename TYPE_TYPE          = GLenum     ,
      typename INDICES_TYPE       = const void*,
      typename INSTANCECOUNT_TYPE = GLsizei    ,
      typename BASEINSTANCE_TYPE  = GLuint     >
    class DrawElementsInstancedBaseInstance:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"         )return(void*)&this->mode         ;
          if(name == "count"        )return(void*)&this->count        ;
          if(name == "type"         )return(void*)&this->type         ;
          if(name == "indices"      )return(void*)&this->indices      ;
          if(name == "instancecount")return(void*)&this->instancecount;
          if(name == "baseinstance" )return(void*)&this->baseinstance ;
          return NULL;
        }
      public:
        MODE_TYPE          mode         ;
        COUNT_TYPE         count        ;
        TYPE_TYPE          type         ;
        INDICES_TYPE       indices      ;
        INSTANCECOUNT_TYPE instancecount;
        BASEINSTANCE_TYPE  baseinstance ;
        DrawElementsInstancedBaseInstance(
            MODE_TYPE          const&mode         ,
            COUNT_TYPE         const&count        ,
            TYPE_TYPE          const&type         ,
            INDICES_TYPE       const&indices      ,
            INSTANCECOUNT_TYPE const&instancecount,
            BASEINSTANCE_TYPE  const&baseinstance ){
          this->mode          = mode         ;
          this->count         = count        ;
          this->type          = type         ;
          this->indices       = indices      ;
          this->instancecount = instancecount;
          this->baseinstance  = baseinstance ;
        }
        virtual~DrawElementsInstancedBaseInstance(){}
        virtual void operator()(){
          glDrawElementsInstancedBaseInstance(
            ge::core::convertTo<GLenum     >(this->mode         ),
            ge::core::convertTo<GLsizei    >(this->count        ),
            ge::core::convertTo<GLenum     >(this->type         ),
            ge::core::convertTo<const void*>(this->indices      ),
            ge::core::convertTo<GLsizei    >(this->instancecount),
            ge::core::convertTo<GLuint     >(this->baseinstance )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint>
    class Enablei:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        Enablei(
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ){
          this->target = target;
          this->index  = index ;
        }
        virtual~Enablei(){}
        virtual void operator()(){
          glEnablei(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLuint>(this->index )
          );
        }
    };

    template<
      typename INDEX_TYPE      = GLuint   ,
      typename TYPE_TYPE       = GLenum   ,
      typename NORMALIZED_TYPE = GLboolean,
      typename VALUE_TYPE      = GLuint   >
    class VertexAttribP4ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"     )return(void*)&this->index     ;
          if(name == "type"      )return(void*)&this->type      ;
          if(name == "normalized")return(void*)&this->normalized;
          if(name == "value"     )return(void*)&this->value     ;
          return NULL;
        }
      public:
        INDEX_TYPE      index     ;
        TYPE_TYPE       type      ;
        NORMALIZED_TYPE normalized;
        VALUE_TYPE      value     ;
        VertexAttribP4ui(
            INDEX_TYPE      const&index     ,
            TYPE_TYPE       const&type      ,
            NORMALIZED_TYPE const&normalized,
            VALUE_TYPE      const&value     ){
          this->index      = index     ;
          this->type       = type      ;
          this->normalized = normalized;
          this->value      = value     ;
        }
        virtual~VertexAttribP4ui(){}
        virtual void operator()(){
          glVertexAttribP4ui(
            ge::core::convertTo<GLuint   >(this->index     ),
            ge::core::convertTo<GLenum   >(this->type      ),
            ge::core::convertTo<GLboolean>(this->normalized),
            ge::core::convertTo<GLuint   >(this->value     )
          );
        }
    };

    template<
      typename RET_TYPE  = GLuint,
      typename TYPE_TYPE = GLenum>
    class CreateShader:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret" )return(void*)&this->ret ;
          if(name == "type")return(void*)&this->type;
          return NULL;
        }
      public:
        RET_TYPE  ret ;
        TYPE_TYPE type;
        CreateShader(
            RET_TYPE  const&ret ,
            TYPE_TYPE const&type){
          this->ret  = ret ;
          this->type = type;
        }
        virtual~CreateShader(){}
        virtual void operator()(){
          ge::core::convertFrom<GLuint>(this->ret,glCreateShader(
              ge::core::convertTo<GLenum>(this->type))
          );
        }
    };

    template<
      typename RET_TYPE    = GLboolean,
      typename BUFFER_TYPE = GLuint   >
    class IsBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"   )return(void*)&this->ret   ;
          if(name == "buffer")return(void*)&this->buffer;
          return NULL;
        }
      public:
        RET_TYPE    ret   ;
        BUFFER_TYPE buffer;
        IsBuffer(
            RET_TYPE    const&ret   ,
            BUFFER_TYPE const&buffer){
          this->ret    = ret   ;
          this->buffer = buffer;
        }
        virtual~IsBuffer(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsBuffer(
              ge::core::convertTo<GLuint   >(this->buffer))
          );
        }
    };

    template<
      typename PNAME_TYPE = GLenum  ,
      typename INDEX_TYPE = GLuint  ,
      typename VAL_TYPE   = GLfloat*>
    class GetMultisamplefv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname")return(void*)&this->pname;
          if(name == "index")return(void*)&this->index;
          if(name == "val"  )return(void*)&this->val  ;
          return NULL;
        }
      public:
        PNAME_TYPE pname;
        INDEX_TYPE index;
        VAL_TYPE   val  ;
        GetMultisamplefv(
            PNAME_TYPE const&pname,
            INDEX_TYPE const&index,
            VAL_TYPE   const&val  ){
          this->pname = pname;
          this->index = index;
          this->val   = val  ;
        }
        virtual~GetMultisamplefv(){}
        virtual void operator()(){
          glGetMultisamplefv(
            ge::core::convertTo<GLenum  >(this->pname),
            ge::core::convertTo<GLuint  >(this->index),
            ge::core::convertTo<GLfloat*>(this->val  )
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class ProgramUniformMatrix2dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix2dv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix2dv(){}
        virtual void operator()(){
          glProgramUniformMatrix2dv(
            ge::core::convertTo<GLuint         >(this->program  ),
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename N_TYPE             = GLsizei,
      typename RENDERBUFFERS_TYPE = GLuint*>
    class GenRenderbuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"            )return(void*)&this->n            ;
          if(name == "renderbuffers")return(void*)&this->renderbuffers;
          return NULL;
        }
      public:
        N_TYPE             n            ;
        RENDERBUFFERS_TYPE renderbuffers;
        GenRenderbuffers(
            N_TYPE             const&n            ,
            RENDERBUFFERS_TYPE const&renderbuffers){
          this->n             = n            ;
          this->renderbuffers = renderbuffers;
        }
        virtual~GenRenderbuffers(){}
        virtual void operator()(){
          glGenRenderbuffers(
            ge::core::convertTo<GLsizei>(this->n            ),
            ge::core::convertTo<GLuint*>(this->renderbuffers)
          );
        }
    };

    template<
      typename TARGET_TYPE  = GLenum ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei>
    class CopyTexSubImage2D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target" )return(void*)&this->target ;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "yoffset")return(void*)&this->yoffset;
          if(name == "x"      )return(void*)&this->x      ;
          if(name == "y"      )return(void*)&this->y      ;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          return NULL;
        }
      public:
        TARGET_TYPE  target ;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        YOFFSET_TYPE yoffset;
        X_TYPE       x      ;
        Y_TYPE       y      ;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        CopyTexSubImage2D(
            TARGET_TYPE  const&target ,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            YOFFSET_TYPE const&yoffset,
            X_TYPE       const&x      ,
            Y_TYPE       const&y      ,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ){
          this->target  = target ;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->yoffset = yoffset;
          this->x       = x      ;
          this->y       = y      ;
          this->width   = width  ;
          this->height  = height ;
        }
        virtual~CopyTexSubImage2D(){}
        virtual void operator()(){
          glCopyTexSubImage2D(
            ge::core::convertTo<GLenum >(this->target ),
            ge::core::convertTo<GLint  >(this->level  ),
            ge::core::convertTo<GLint  >(this->xoffset),
            ge::core::convertTo<GLint  >(this->yoffset),
            ge::core::convertTo<GLint  >(this->x      ),
            ge::core::convertTo<GLint  >(this->y      ),
            ge::core::convertTo<GLsizei>(this->width  ),
            ge::core::convertTo<GLsizei>(this->height )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble>
    class VertexAttrib1d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        VertexAttrib1d(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ){
          this->index = index;
          this->x     = x    ;
        }
        virtual~VertexAttrib1d(){}
        virtual void operator()(){
          glVertexAttrib1d(
            ge::core::convertTo<GLuint  >(this->index),
            ge::core::convertTo<GLdouble>(this->x    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat>
    class VertexAttrib1f:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        VertexAttrib1f(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ){
          this->index = index;
          this->x     = x    ;
        }
        virtual~VertexAttrib1f(){}
        virtual void operator()(){
          glVertexAttrib1f(
            ge::core::convertTo<GLuint >(this->index),
            ge::core::convertTo<GLfloat>(this->x    )
          );
        }
    };

    template<
      typename SFACTORRGB_TYPE   = GLenum,
      typename DFACTORRGB_TYPE   = GLenum,
      typename SFACTORALPHA_TYPE = GLenum,
      typename DFACTORALPHA_TYPE = GLenum>
    class BlendFuncSeparate:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sfactorRGB"  )return(void*)&this->sfactorRGB  ;
          if(name == "dfactorRGB"  )return(void*)&this->dfactorRGB  ;
          if(name == "sfactorAlpha")return(void*)&this->sfactorAlpha;
          if(name == "dfactorAlpha")return(void*)&this->dfactorAlpha;
          return NULL;
        }
      public:
        SFACTORRGB_TYPE   sfactorRGB  ;
        DFACTORRGB_TYPE   dfactorRGB  ;
        SFACTORALPHA_TYPE sfactorAlpha;
        DFACTORALPHA_TYPE dfactorAlpha;
        BlendFuncSeparate(
            SFACTORRGB_TYPE   const&sfactorRGB  ,
            DFACTORRGB_TYPE   const&dfactorRGB  ,
            SFACTORALPHA_TYPE const&sfactorAlpha,
            DFACTORALPHA_TYPE const&dfactorAlpha){
          this->sfactorRGB   = sfactorRGB  ;
          this->dfactorRGB   = dfactorRGB  ;
          this->sfactorAlpha = sfactorAlpha;
          this->dfactorAlpha = dfactorAlpha;
        }
        virtual~BlendFuncSeparate(){}
        virtual void operator()(){
          glBlendFuncSeparate(
            ge::core::convertTo<GLenum>(this->sfactorRGB  ),
            ge::core::convertTo<GLenum>(this->dfactorRGB  ),
            ge::core::convertTo<GLenum>(this->sfactorAlpha),
            ge::core::convertTo<GLenum>(this->dfactorAlpha)
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class ProgramUniformMatrix4fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix4fv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix4fv(){}
        virtual void operator()(){
          glProgramUniformMatrix4fv(
            ge::core::convertTo<GLuint        >(this->program  ),
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE = GLuint       ,
      typename BUFFER_TYPE      = GLenum       ,
      typename DEPTH_TYPE       = const GLfloat,
      typename STENCIL_TYPE     = GLint        >
    class ClearNamedFramebufferfi:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "buffer"     )return(void*)&this->buffer     ;
          if(name == "depth"      )return(void*)&this->depth      ;
          if(name == "stencil"    )return(void*)&this->stencil    ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE framebuffer;
        BUFFER_TYPE      buffer     ;
        DEPTH_TYPE       depth      ;
        STENCIL_TYPE     stencil    ;
        ClearNamedFramebufferfi(
            FRAMEBUFFER_TYPE const&framebuffer,
            BUFFER_TYPE      const&buffer     ,
            DEPTH_TYPE       const&depth      ,
            STENCIL_TYPE     const&stencil    ){
          this->framebuffer = framebuffer;
          this->buffer      = buffer     ;
          this->depth       = depth      ;
          this->stencil     = stencil    ;
        }
        virtual~ClearNamedFramebufferfi(){}
        virtual void operator()(){
          glClearNamedFramebufferfi(
            ge::core::convertTo<GLuint       >(this->framebuffer),
            ge::core::convertTo<GLenum       >(this->buffer     ),
            ge::core::convertTo<const GLfloat>(this->depth      ),
            ge::core::convertTo<GLint        >(this->stencil    )
          );
        }
    };

    template<
      typename ID_TYPE     = GLuint  ,
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename OFFSET_TYPE = GLintptr>
    class GetQueryBufferObjectuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "id"    )return(void*)&this->id    ;
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "offset")return(void*)&this->offset;
          return NULL;
        }
      public:
        ID_TYPE     id    ;
        BUFFER_TYPE buffer;
        PNAME_TYPE  pname ;
        OFFSET_TYPE offset;
        GetQueryBufferObjectuiv(
            ID_TYPE     const&id    ,
            BUFFER_TYPE const&buffer,
            PNAME_TYPE  const&pname ,
            OFFSET_TYPE const&offset){
          this->id     = id    ;
          this->buffer = buffer;
          this->pname  = pname ;
          this->offset = offset;
        }
        virtual~GetQueryBufferObjectuiv(){}
        virtual void operator()(){
          glGetQueryBufferObjectuiv(
            ge::core::convertTo<GLuint  >(this->id    ),
            ge::core::convertTo<GLuint  >(this->buffer),
            ge::core::convertTo<GLenum  >(this->pname ),
            ge::core::convertTo<GLintptr>(this->offset)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLshort,
      typename Y_TYPE     = GLshort>
    class VertexAttrib2s:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        VertexAttrib2s(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
        }
        virtual~VertexAttrib2s(){}
        virtual void operator()(){
          glVertexAttrib2s(
            ge::core::convertTo<GLuint >(this->index),
            ge::core::convertTo<GLshort>(this->x    ),
            ge::core::convertTo<GLshort>(this->y    )
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE = GLuint        ,
      typename BUFFER_TYPE      = GLenum        ,
      typename DRAWBUFFER_TYPE  = GLint         ,
      typename VALUE_TYPE       = const GLfloat*>
    class ClearNamedFramebufferfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "buffer"     )return(void*)&this->buffer     ;
          if(name == "drawbuffer" )return(void*)&this->drawbuffer ;
          if(name == "value"      )return(void*)&this->value      ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE framebuffer;
        BUFFER_TYPE      buffer     ;
        DRAWBUFFER_TYPE  drawbuffer ;
        VALUE_TYPE       value      ;
        ClearNamedFramebufferfv(
            FRAMEBUFFER_TYPE const&framebuffer,
            BUFFER_TYPE      const&buffer     ,
            DRAWBUFFER_TYPE  const&drawbuffer ,
            VALUE_TYPE       const&value      ){
          this->framebuffer = framebuffer;
          this->buffer      = buffer     ;
          this->drawbuffer  = drawbuffer ;
          this->value       = value      ;
        }
        virtual~ClearNamedFramebufferfv(){}
        virtual void operator()(){
          glClearNamedFramebufferfv(
            ge::core::convertTo<GLuint        >(this->framebuffer),
            ge::core::convertTo<GLenum        >(this->buffer     ),
            ge::core::convertTo<GLint         >(this->drawbuffer ),
            ge::core::convertTo<const GLfloat*>(this->value      )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLshort>
    class VertexAttrib1s:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        VertexAttrib1s(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ){
          this->index = index;
          this->x     = x    ;
        }
        virtual~VertexAttrib1s(){}
        virtual void operator()(){
          glVertexAttrib1s(
            ge::core::convertTo<GLuint >(this->index),
            ge::core::convertTo<GLshort>(this->x    )
          );
        }
    };

    template<
      typename MASKNUMBER_TYPE = GLuint    ,
      typename MASK_TYPE       = GLbitfield>
    class SampleMaski:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "maskNumber")return(void*)&this->maskNumber;
          if(name == "mask"      )return(void*)&this->mask      ;
          return NULL;
        }
      public:
        MASKNUMBER_TYPE maskNumber;
        MASK_TYPE       mask      ;
        SampleMaski(
            MASKNUMBER_TYPE const&maskNumber,
            MASK_TYPE       const&mask      ){
          this->maskNumber = maskNumber;
          this->mask       = mask      ;
        }
        virtual~SampleMaski(){}
        virtual void operator()(){
          glSampleMaski(
            ge::core::convertTo<GLuint    >(this->maskNumber),
            ge::core::convertTo<GLbitfield>(this->mask      )
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class UniformMatrix3x2fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix3x2fv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix3x2fv(){}
        virtual void operator()(){
          glUniformMatrix3x2fv(
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename SOURCE_TYPE   = GLenum       ,
      typename TYPE_TYPE     = GLenum       ,
      typename SEVERITY_TYPE = GLenum       ,
      typename COUNT_TYPE    = GLsizei      ,
      typename IDS_TYPE      = const GLuint*,
      typename ENABLED_TYPE  = GLboolean    >
    class DebugMessageControl:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "source"  )return(void*)&this->source  ;
          if(name == "type"    )return(void*)&this->type    ;
          if(name == "severity")return(void*)&this->severity;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "ids"     )return(void*)&this->ids     ;
          if(name == "enabled" )return(void*)&this->enabled ;
          return NULL;
        }
      public:
        SOURCE_TYPE   source  ;
        TYPE_TYPE     type    ;
        SEVERITY_TYPE severity;
        COUNT_TYPE    count   ;
        IDS_TYPE      ids     ;
        ENABLED_TYPE  enabled ;
        DebugMessageControl(
            SOURCE_TYPE   const&source  ,
            TYPE_TYPE     const&type    ,
            SEVERITY_TYPE const&severity,
            COUNT_TYPE    const&count   ,
            IDS_TYPE      const&ids     ,
            ENABLED_TYPE  const&enabled ){
          this->source   = source  ;
          this->type     = type    ;
          this->severity = severity;
          this->count    = count   ;
          this->ids      = ids     ;
          this->enabled  = enabled ;
        }
        virtual~DebugMessageControl(){}
        virtual void operator()(){
          glDebugMessageControl(
            ge::core::convertTo<GLenum       >(this->source  ),
            ge::core::convertTo<GLenum       >(this->type    ),
            ge::core::convertTo<GLenum       >(this->severity),
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->ids     ),
            ge::core::convertTo<GLboolean    >(this->enabled )
          );
        }
    };

    template<
      typename SIZE_TYPE = GLfloat>
    class PointSize:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "size")return(void*)&this->size;
          return NULL;
        }
      public:
        SIZE_TYPE size;
        PointSize(
            SIZE_TYPE const&size){
          this->size = size;
        }
        virtual~PointSize(){}
        virtual void operator()(){
          glPointSize(
            ge::core::convertTo<GLfloat>(this->size)
          );
        }
    };

    template<
      typename UNIT_TYPE    = GLuint,
      typename TEXTURE_TYPE = GLuint>
    class BindTextureUnit:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "unit"   )return(void*)&this->unit   ;
          if(name == "texture")return(void*)&this->texture;
          return NULL;
        }
      public:
        UNIT_TYPE    unit   ;
        TEXTURE_TYPE texture;
        BindTextureUnit(
            UNIT_TYPE    const&unit   ,
            TEXTURE_TYPE const&texture){
          this->unit    = unit   ;
          this->texture = texture;
        }
        virtual~BindTextureUnit(){}
        virtual void operator()(){
          glBindTextureUnit(
            ge::core::convertTo<GLuint>(this->unit   ),
            ge::core::convertTo<GLuint>(this->texture)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    class VertexAttrib2dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib2dv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib2dv(){}
        virtual void operator()(){
          glVertexAttrib2dv(
            ge::core::convertTo<GLuint         >(this->index),
            ge::core::convertTo<const GLdouble*>(this->v    )
          );
        }
    };

    template<
      typename ID_TYPE     = GLuint  ,
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename OFFSET_TYPE = GLintptr>
    class GetQueryBufferObjectiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "id"    )return(void*)&this->id    ;
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "offset")return(void*)&this->offset;
          return NULL;
        }
      public:
        ID_TYPE     id    ;
        BUFFER_TYPE buffer;
        PNAME_TYPE  pname ;
        OFFSET_TYPE offset;
        GetQueryBufferObjectiv(
            ID_TYPE     const&id    ,
            BUFFER_TYPE const&buffer,
            PNAME_TYPE  const&pname ,
            OFFSET_TYPE const&offset){
          this->id     = id    ;
          this->buffer = buffer;
          this->pname  = pname ;
          this->offset = offset;
        }
        virtual~GetQueryBufferObjectiv(){}
        virtual void operator()(){
          glGetQueryBufferObjectiv(
            ge::core::convertTo<GLuint  >(this->id    ),
            ge::core::convertTo<GLuint  >(this->buffer),
            ge::core::convertTo<GLenum  >(this->pname ),
            ge::core::convertTo<GLintptr>(this->offset)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    class VertexAttrib4Nuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4Nuiv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4Nuiv(){}
        virtual void operator()(){
          glVertexAttrib4Nuiv(
            ge::core::convertTo<GLuint       >(this->index),
            ge::core::convertTo<const GLuint*>(this->v    )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    class TexStorage2D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "levels"        )return(void*)&this->levels        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        LEVELS_TYPE         levels        ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        TexStorage2D(
            TARGET_TYPE         const&target        ,
            LEVELS_TYPE         const&levels        ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ){
          this->target         = target        ;
          this->levels         = levels        ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->height         = height        ;
        }
        virtual~TexStorage2D(){}
        virtual void operator()(){
          glTexStorage2D(
            ge::core::convertTo<GLenum >(this->target        ),
            ge::core::convertTo<GLsizei>(this->levels        ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLsizei>(this->width         ),
            ge::core::convertTo<GLsizei>(this->height        )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    class RenderbufferStorage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        RenderbufferStorage(
            TARGET_TYPE         const&target        ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ){
          this->target         = target        ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->height         = height        ;
        }
        virtual~RenderbufferStorage(){}
        virtual void operator()(){
          glRenderbufferStorage(
            ge::core::convertTo<GLenum >(this->target        ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLsizei>(this->width         ),
            ge::core::convertTo<GLsizei>(this->height        )
          );
        }
    };

    template<
      typename SYNC_TYPE    = GLsync    ,
      typename FLAGS_TYPE   = GLbitfield,
      typename TIMEOUT_TYPE = GLuint64  >
    class WaitSync:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sync"   )return(void*)&this->sync   ;
          if(name == "flags"  )return(void*)&this->flags  ;
          if(name == "timeout")return(void*)&this->timeout;
          return NULL;
        }
      public:
        SYNC_TYPE    sync   ;
        FLAGS_TYPE   flags  ;
        TIMEOUT_TYPE timeout;
        WaitSync(
            SYNC_TYPE    const&sync   ,
            FLAGS_TYPE   const&flags  ,
            TIMEOUT_TYPE const&timeout){
          this->sync    = sync   ;
          this->flags   = flags  ;
          this->timeout = timeout;
        }
        virtual~WaitSync(){}
        virtual void operator()(){
          glWaitSync(
            ge::core::convertTo<GLsync    >(this->sync   ),
            ge::core::convertTo<GLbitfield>(this->flags  ),
            ge::core::convertTo<GLuint64  >(this->timeout)
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class UniformMatrix4x3fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix4x3fv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix4x3fv(){}
        virtual void operator()(){
          glUniformMatrix4x3fv(
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint,
      typename V0_TYPE       = GLint,
      typename V1_TYPE       = GLint,
      typename V2_TYPE       = GLint>
    class Uniform3i:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        Uniform3i(
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ){
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
        }
        virtual~Uniform3i(){}
        virtual void operator()(){
          glUniform3i(
            ge::core::convertTo<GLint>(this->location),
            ge::core::convertTo<GLint>(this->v0      ),
            ge::core::convertTo<GLint>(this->v1      ),
            ge::core::convertTo<GLint>(this->v2      )
          );
        }
    };

    template<
      typename IDENTIFIER_TYPE = GLenum  ,
      typename NAME_TYPE       = GLuint  ,
      typename BUFSIZE_TYPE    = GLsizei ,
      typename LENGTH_TYPE     = GLsizei*,
      typename LABEL_TYPE      = GLchar* >
    class GetObjectLabel:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "identifier")return(void*)&this->identifier;
          if(name == "name"      )return(void*)&this->name      ;
          if(name == "bufSize"   )return(void*)&this->bufSize   ;
          if(name == "length"    )return(void*)&this->length    ;
          if(name == "label"     )return(void*)&this->label     ;
          return NULL;
        }
      public:
        IDENTIFIER_TYPE identifier;
        NAME_TYPE       name      ;
        BUFSIZE_TYPE    bufSize   ;
        LENGTH_TYPE     length    ;
        LABEL_TYPE      label     ;
        GetObjectLabel(
            IDENTIFIER_TYPE const&identifier,
            NAME_TYPE       const&name      ,
            BUFSIZE_TYPE    const&bufSize   ,
            LENGTH_TYPE     const&length    ,
            LABEL_TYPE      const&label     ){
          this->identifier = identifier;
          this->name       = name      ;
          this->bufSize    = bufSize   ;
          this->length     = length    ;
          this->label      = label     ;
        }
        virtual~GetObjectLabel(){}
        virtual void operator()(){
          glGetObjectLabel(
            ge::core::convertTo<GLenum  >(this->identifier),
            ge::core::convertTo<GLuint  >(this->name      ),
            ge::core::convertTo<GLsizei >(this->bufSize   ),
            ge::core::convertTo<GLsizei*>(this->length    ),
            ge::core::convertTo<GLchar* >(this->label     )
          );
        }
    };

    template<
      typename COUNT_TYPE    = GLsizei      ,
      typename SAMPLERS_TYPE = const GLuint*>
    class DeleteSamplers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "samplers")return(void*)&this->samplers;
          return NULL;
        }
      public:
        COUNT_TYPE    count   ;
        SAMPLERS_TYPE samplers;
        DeleteSamplers(
            COUNT_TYPE    const&count   ,
            SAMPLERS_TYPE const&samplers){
          this->count    = count   ;
          this->samplers = samplers;
        }
        virtual~DeleteSamplers(){}
        virtual void operator()(){
          glDeleteSamplers(
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->samplers)
          );
        }
    };

    template<
      typename BUF_TYPE       = GLuint,
      typename MODERGB_TYPE   = GLenum,
      typename MODEALPHA_TYPE = GLenum>
    class BlendEquationSeparatei:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buf"      )return(void*)&this->buf      ;
          if(name == "modeRGB"  )return(void*)&this->modeRGB  ;
          if(name == "modeAlpha")return(void*)&this->modeAlpha;
          return NULL;
        }
      public:
        BUF_TYPE       buf      ;
        MODERGB_TYPE   modeRGB  ;
        MODEALPHA_TYPE modeAlpha;
        BlendEquationSeparatei(
            BUF_TYPE       const&buf      ,
            MODERGB_TYPE   const&modeRGB  ,
            MODEALPHA_TYPE const&modeAlpha){
          this->buf       = buf      ;
          this->modeRGB   = modeRGB  ;
          this->modeAlpha = modeAlpha;
        }
        virtual~BlendEquationSeparatei(){}
        virtual void operator()(){
          glBlendEquationSeparatei(
            ge::core::convertTo<GLuint>(this->buf      ),
            ge::core::convertTo<GLenum>(this->modeRGB  ),
            ge::core::convertTo<GLenum>(this->modeAlpha)
          );
        }
    };

    class TextureBarrier:
        public ge::core::Command{
      public:
        TextureBarrier(
            ){
        }
        virtual~TextureBarrier(){}
        virtual void operator()(){
          glTextureBarrier(

          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint   ,
      typename X_TYPE        = GLdouble,
      typename Y_TYPE        = GLdouble,
      typename Z_TYPE        = GLdouble>
    class Uniform3d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "x"       )return(void*)&this->x       ;
          if(name == "y"       )return(void*)&this->y       ;
          if(name == "z"       )return(void*)&this->z       ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        X_TYPE        x       ;
        Y_TYPE        y       ;
        Z_TYPE        z       ;
        Uniform3d(
            LOCATION_TYPE const&location,
            X_TYPE        const&x       ,
            Y_TYPE        const&y       ,
            Z_TYPE        const&z       ){
          this->location = location;
          this->x        = x       ;
          this->y        = y       ;
          this->z        = z       ;
        }
        virtual~Uniform3d(){}
        virtual void operator()(){
          glUniform3d(
            ge::core::convertTo<GLint   >(this->location),
            ge::core::convertTo<GLdouble>(this->x       ),
            ge::core::convertTo<GLdouble>(this->y       ),
            ge::core::convertTo<GLdouble>(this->z       )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat,
      typename V2_TYPE       = GLfloat>
    class Uniform3f:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        Uniform3f(
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ){
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
        }
        virtual~Uniform3f(){}
        virtual void operator()(){
          glUniform3f(
            ge::core::convertTo<GLint  >(this->location),
            ge::core::convertTo<GLfloat>(this->v0      ),
            ge::core::convertTo<GLfloat>(this->v1      ),
            ge::core::convertTo<GLfloat>(this->v2      )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLubyte*>
    class VertexAttrib4ubv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4ubv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4ubv(){}
        virtual void operator()(){
          glVertexAttrib4ubv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLubyte*>(this->v    )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetBufferParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetBufferParameteriv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetBufferParameteriv(){}
        virtual void operator()(){
          glGetBufferParameteriv(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint   ,
      typename R_TYPE     = GLboolean,
      typename G_TYPE     = GLboolean,
      typename B_TYPE     = GLboolean,
      typename A_TYPE     = GLboolean>
    class ColorMaski:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "r"    )return(void*)&this->r    ;
          if(name == "g"    )return(void*)&this->g    ;
          if(name == "b"    )return(void*)&this->b    ;
          if(name == "a"    )return(void*)&this->a    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        R_TYPE     r    ;
        G_TYPE     g    ;
        B_TYPE     b    ;
        A_TYPE     a    ;
        ColorMaski(
            INDEX_TYPE const&index,
            R_TYPE     const&r    ,
            G_TYPE     const&g    ,
            B_TYPE     const&b    ,
            A_TYPE     const&a    ){
          this->index = index;
          this->r     = r    ;
          this->g     = g    ;
          this->b     = b    ;
          this->a     = a    ;
        }
        virtual~ColorMaski(){}
        virtual void operator()(){
          glColorMaski(
            ge::core::convertTo<GLuint   >(this->index),
            ge::core::convertTo<GLboolean>(this->r    ),
            ge::core::convertTo<GLboolean>(this->g    ),
            ge::core::convertTo<GLboolean>(this->b    ),
            ge::core::convertTo<GLboolean>(this->a    )
          );
        }
    };

    template<
      typename BUFFER_TYPE     = GLenum ,
      typename DRAWBUFFER_TYPE = GLint  ,
      typename DEPTH_TYPE      = GLfloat,
      typename STENCIL_TYPE    = GLint  >
    class ClearBufferfi:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer"    )return(void*)&this->buffer    ;
          if(name == "drawbuffer")return(void*)&this->drawbuffer;
          if(name == "depth"     )return(void*)&this->depth     ;
          if(name == "stencil"   )return(void*)&this->stencil   ;
          return NULL;
        }
      public:
        BUFFER_TYPE     buffer    ;
        DRAWBUFFER_TYPE drawbuffer;
        DEPTH_TYPE      depth     ;
        STENCIL_TYPE    stencil   ;
        ClearBufferfi(
            BUFFER_TYPE     const&buffer    ,
            DRAWBUFFER_TYPE const&drawbuffer,
            DEPTH_TYPE      const&depth     ,
            STENCIL_TYPE    const&stencil   ){
          this->buffer     = buffer    ;
          this->drawbuffer = drawbuffer;
          this->depth      = depth     ;
          this->stencil    = stencil   ;
        }
        virtual~ClearBufferfi(){}
        virtual void operator()(){
          glClearBufferfi(
            ge::core::convertTo<GLenum >(this->buffer    ),
            ge::core::convertTo<GLint  >(this->drawbuffer),
            ge::core::convertTo<GLfloat>(this->depth     ),
            ge::core::convertTo<GLint  >(this->stencil   )
          );
        }
    };

    template<
      typename MODE_TYPE     = GLenum     ,
      typename INDIRECT_TYPE = const void*>
    class DrawArraysIndirect:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"    )return(void*)&this->mode    ;
          if(name == "indirect")return(void*)&this->indirect;
          return NULL;
        }
      public:
        MODE_TYPE     mode    ;
        INDIRECT_TYPE indirect;
        DrawArraysIndirect(
            MODE_TYPE     const&mode    ,
            INDIRECT_TYPE const&indirect){
          this->mode     = mode    ;
          this->indirect = indirect;
        }
        virtual~DrawArraysIndirect(){}
        virtual void operator()(){
          glDrawArraysIndirect(
            ge::core::convertTo<GLenum     >(this->mode    ),
            ge::core::convertTo<const void*>(this->indirect)
          );
        }
    };

    template<
      typename N_TYPE      = GLsizei,
      typename ARRAYS_TYPE = GLuint*>
    class GenVertexArrays:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"     )return(void*)&this->n     ;
          if(name == "arrays")return(void*)&this->arrays;
          return NULL;
        }
      public:
        N_TYPE      n     ;
        ARRAYS_TYPE arrays;
        GenVertexArrays(
            N_TYPE      const&n     ,
            ARRAYS_TYPE const&arrays){
          this->n      = n     ;
          this->arrays = arrays;
        }
        virtual~GenVertexArrays(){}
        virtual void operator()(){
          glGenVertexArrays(
            ge::core::convertTo<GLsizei>(this->n     ),
            ge::core::convertTo<GLuint*>(this->arrays)
          );
        }
    };

    template<
      typename VAOBJ_TYPE = GLuint,
      typename INDEX_TYPE = GLuint>
    class EnableVertexArrayAttrib:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj")return(void*)&this->vaobj;
          if(name == "index")return(void*)&this->index;
          return NULL;
        }
      public:
        VAOBJ_TYPE vaobj;
        INDEX_TYPE index;
        EnableVertexArrayAttrib(
            VAOBJ_TYPE const&vaobj,
            INDEX_TYPE const&index){
          this->vaobj = vaobj;
          this->index = index;
        }
        virtual~EnableVertexArrayAttrib(){}
        virtual void operator()(){
          glEnableVertexArrayAttrib(
            ge::core::convertTo<GLuint>(this->vaobj),
            ge::core::convertTo<GLuint>(this->index)
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class ProgramUniformMatrix3x2dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix3x2dv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix3x2dv(){}
        virtual void operator()(){
          glProgramUniformMatrix3x2dv(
            ge::core::convertTo<GLuint         >(this->program  ),
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename READBUFFER_TYPE  = GLuint    ,
      typename WRITEBUFFER_TYPE = GLuint    ,
      typename READOFFSET_TYPE  = GLintptr  ,
      typename WRITEOFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE        = GLsizeiptr>
    class CopyNamedBufferSubData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "readBuffer" )return(void*)&this->readBuffer ;
          if(name == "writeBuffer")return(void*)&this->writeBuffer;
          if(name == "readOffset" )return(void*)&this->readOffset ;
          if(name == "writeOffset")return(void*)&this->writeOffset;
          if(name == "size"       )return(void*)&this->size       ;
          return NULL;
        }
      public:
        READBUFFER_TYPE  readBuffer ;
        WRITEBUFFER_TYPE writeBuffer;
        READOFFSET_TYPE  readOffset ;
        WRITEOFFSET_TYPE writeOffset;
        SIZE_TYPE        size       ;
        CopyNamedBufferSubData(
            READBUFFER_TYPE  const&readBuffer ,
            WRITEBUFFER_TYPE const&writeBuffer,
            READOFFSET_TYPE  const&readOffset ,
            WRITEOFFSET_TYPE const&writeOffset,
            SIZE_TYPE        const&size       ){
          this->readBuffer  = readBuffer ;
          this->writeBuffer = writeBuffer;
          this->readOffset  = readOffset ;
          this->writeOffset = writeOffset;
          this->size        = size       ;
        }
        virtual~CopyNamedBufferSubData(){}
        virtual void operator()(){
          glCopyNamedBufferSubData(
            ge::core::convertTo<GLuint    >(this->readBuffer ),
            ge::core::convertTo<GLuint    >(this->writeBuffer),
            ge::core::convertTo<GLintptr  >(this->readOffset ),
            ge::core::convertTo<GLintptr  >(this->writeOffset),
            ge::core::convertTo<GLsizeiptr>(this->size       )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat,
      typename V2_TYPE       = GLfloat>
    class ProgramUniform3f:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        ProgramUniform3f(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
        }
        virtual~ProgramUniform3f(){}
        virtual void operator()(){
          glProgramUniform3f(
            ge::core::convertTo<GLuint >(this->program ),
            ge::core::convertTo<GLint  >(this->location),
            ge::core::convertTo<GLfloat>(this->v0      ),
            ge::core::convertTo<GLfloat>(this->v1      ),
            ge::core::convertTo<GLfloat>(this->v2      )
          );
        }
    };

    template<
      typename SAMPLER_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    class GetSamplerParameterIiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sampler")return(void*)&this->sampler;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        SAMPLER_TYPE sampler;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        GetSamplerParameterIiv(
            SAMPLER_TYPE const&sampler,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->sampler = sampler;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~GetSamplerParameterIiv(){}
        virtual void operator()(){
          glGetSamplerParameterIiv(
            ge::core::convertTo<GLuint>(this->sampler),
            ge::core::convertTo<GLenum>(this->pname  ),
            ge::core::convertTo<GLint*>(this->params )
          );
        }
    };

    template<
      typename RET_TYPE     = GLint        ,
      typename PROGRAM_TYPE = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    class GetFragDataIndex:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"    )return(void*)&this->ret    ;
          if(name == "program")return(void*)&this->program;
          if(name == "name"   )return(void*)&this->name   ;
          return NULL;
        }
      public:
        RET_TYPE     ret    ;
        PROGRAM_TYPE program;
        NAME_TYPE    name   ;
        GetFragDataIndex(
            RET_TYPE     const&ret    ,
            PROGRAM_TYPE const&program,
            NAME_TYPE    const&name   ){
          this->ret     = ret    ;
          this->program = program;
          this->name    = name   ;
        }
        virtual~GetFragDataIndex(){}
        virtual void operator()(){
          ge::core::convertFrom<GLint>(this->ret,glGetFragDataIndex(
              ge::core::convertTo<GLuint       >(this->program),
              ge::core::convertTo<const GLchar*>(this->name   ))
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei,
      typename DEPTH_TYPE          = GLsizei>
    class TexStorage3D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "levels"        )return(void*)&this->levels        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          if(name == "depth"         )return(void*)&this->depth         ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        LEVELS_TYPE         levels        ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        DEPTH_TYPE          depth         ;
        TexStorage3D(
            TARGET_TYPE         const&target        ,
            LEVELS_TYPE         const&levels        ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ,
            DEPTH_TYPE          const&depth         ){
          this->target         = target        ;
          this->levels         = levels        ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->height         = height        ;
          this->depth          = depth         ;
        }
        virtual~TexStorage3D(){}
        virtual void operator()(){
          glTexStorage3D(
            ge::core::convertTo<GLenum >(this->target        ),
            ge::core::convertTo<GLsizei>(this->levels        ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLsizei>(this->width         ),
            ge::core::convertTo<GLsizei>(this->height        ),
            ge::core::convertTo<GLsizei>(this->depth         )
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class UniformMatrix4x2fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix4x2fv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix4x2fv(){}
        virtual void operator()(){
          glUniformMatrix4x2fv(
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint      ,
      typename PNAME_TYPE   = GLenum      ,
      typename PARAM_TYPE   = const GLint*>
    class TextureParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "param"  )return(void*)&this->param  ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        PNAME_TYPE   pname  ;
        PARAM_TYPE   param  ;
        TextureParameteriv(
            TEXTURE_TYPE const&texture,
            PNAME_TYPE   const&pname  ,
            PARAM_TYPE   const&param  ){
          this->texture = texture;
          this->pname   = pname  ;
          this->param   = param  ;
        }
        virtual~TextureParameteriv(){}
        virtual void operator()(){
          glTextureParameteriv(
            ge::core::convertTo<GLuint      >(this->texture),
            ge::core::convertTo<GLenum      >(this->pname  ),
            ge::core::convertTo<const GLint*>(this->param  )
          );
        }
    };

    template<
      typename ID_TYPE     = GLuint  ,
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename OFFSET_TYPE = GLintptr>
    class GetQueryBufferObjecti64v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "id"    )return(void*)&this->id    ;
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "offset")return(void*)&this->offset;
          return NULL;
        }
      public:
        ID_TYPE     id    ;
        BUFFER_TYPE buffer;
        PNAME_TYPE  pname ;
        OFFSET_TYPE offset;
        GetQueryBufferObjecti64v(
            ID_TYPE     const&id    ,
            BUFFER_TYPE const&buffer,
            PNAME_TYPE  const&pname ,
            OFFSET_TYPE const&offset){
          this->id     = id    ;
          this->buffer = buffer;
          this->pname  = pname ;
          this->offset = offset;
        }
        virtual~GetQueryBufferObjecti64v(){}
        virtual void operator()(){
          glGetQueryBufferObjecti64v(
            ge::core::convertTo<GLuint  >(this->id    ),
            ge::core::convertTo<GLuint  >(this->buffer),
            ge::core::convertTo<GLenum  >(this->pname ),
            ge::core::convertTo<GLintptr>(this->offset)
          );
        }
    };

    template<
      typename INDEX_TYPE  = GLuint   ,
      typename PNAME_TYPE  = GLenum   ,
      typename PARAMS_TYPE = GLdouble*>
    class GetVertexAttribdv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index" )return(void*)&this->index ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        INDEX_TYPE  index ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetVertexAttribdv(
            INDEX_TYPE  const&index ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->index  = index ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetVertexAttribdv(){}
        virtual void operator()(){
          glGetVertexAttribdv(
            ge::core::convertTo<GLuint   >(this->index ),
            ge::core::convertTo<GLenum   >(this->pname ),
            ge::core::convertTo<GLdouble*>(this->params)
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class UniformMatrix3x4fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix3x4fv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix3x4fv(){}
        virtual void operator()(){
          glUniformMatrix3x4fv(
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class UniformMatrix3dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix3dv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix3dv(){}
        virtual void operator()(){
          glUniformMatrix3dv(
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class ProgramUniformMatrix3x4dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix3x4dv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix3x4dv(){}
        virtual void operator()(){
          glProgramUniformMatrix3x4dv(
            ge::core::convertTo<GLuint         >(this->program  ),
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename ATTACHMENT_TYPE  = GLenum,
      typename TEXTURE_TYPE     = GLuint,
      typename LEVEL_TYPE       = GLint >
    class NamedFramebufferTexture:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "attachment" )return(void*)&this->attachment ;
          if(name == "texture"    )return(void*)&this->texture    ;
          if(name == "level"      )return(void*)&this->level      ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE framebuffer;
        ATTACHMENT_TYPE  attachment ;
        TEXTURE_TYPE     texture    ;
        LEVEL_TYPE       level      ;
        NamedFramebufferTexture(
            FRAMEBUFFER_TYPE const&framebuffer,
            ATTACHMENT_TYPE  const&attachment ,
            TEXTURE_TYPE     const&texture    ,
            LEVEL_TYPE       const&level      ){
          this->framebuffer = framebuffer;
          this->attachment  = attachment ;
          this->texture     = texture    ;
          this->level       = level      ;
        }
        virtual~NamedFramebufferTexture(){}
        virtual void operator()(){
          glNamedFramebufferTexture(
            ge::core::convertTo<GLuint>(this->framebuffer),
            ge::core::convertTo<GLenum>(this->attachment ),
            ge::core::convertTo<GLuint>(this->texture    ),
            ge::core::convertTo<GLint >(this->level      )
          );
        }
    };

    template<
      typename TARGET_TYPE  = GLenum           ,
      typename FIRST_TYPE   = GLuint           ,
      typename COUNT_TYPE   = GLsizei          ,
      typename BUFFERS_TYPE = const GLuint*    ,
      typename OFFSETS_TYPE = const GLintptr*  ,
      typename SIZES_TYPE   = const GLsizeiptr*>
    class BindBuffersRange:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target" )return(void*)&this->target ;
          if(name == "first"  )return(void*)&this->first  ;
          if(name == "count"  )return(void*)&this->count  ;
          if(name == "buffers")return(void*)&this->buffers;
          if(name == "offsets")return(void*)&this->offsets;
          if(name == "sizes"  )return(void*)&this->sizes  ;
          return NULL;
        }
      public:
        TARGET_TYPE  target ;
        FIRST_TYPE   first  ;
        COUNT_TYPE   count  ;
        BUFFERS_TYPE buffers;
        OFFSETS_TYPE offsets;
        SIZES_TYPE   sizes  ;
        BindBuffersRange(
            TARGET_TYPE  const&target ,
            FIRST_TYPE   const&first  ,
            COUNT_TYPE   const&count  ,
            BUFFERS_TYPE const&buffers,
            OFFSETS_TYPE const&offsets,
            SIZES_TYPE   const&sizes  ){
          this->target  = target ;
          this->first   = first  ;
          this->count   = count  ;
          this->buffers = buffers;
          this->offsets = offsets;
          this->sizes   = sizes  ;
        }
        virtual~BindBuffersRange(){}
        virtual void operator()(){
          glBindBuffersRange(
            ge::core::convertTo<GLenum           >(this->target ),
            ge::core::convertTo<GLuint           >(this->first  ),
            ge::core::convertTo<GLsizei          >(this->count  ),
            ge::core::convertTo<const GLuint*    >(this->buffers),
            ge::core::convertTo<const GLintptr*  >(this->offsets),
            ge::core::convertTo<const GLsizeiptr*>(this->sizes  )
          );
        }
    };

    template<
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr>
    class InvalidateBufferSubData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "offset")return(void*)&this->offset;
          if(name == "length")return(void*)&this->length;
          return NULL;
        }
      public:
        BUFFER_TYPE buffer;
        OFFSET_TYPE offset;
        LENGTH_TYPE length;
        InvalidateBufferSubData(
            BUFFER_TYPE const&buffer,
            OFFSET_TYPE const&offset,
            LENGTH_TYPE const&length){
          this->buffer = buffer;
          this->offset = offset;
          this->length = length;
        }
        virtual~InvalidateBufferSubData(){}
        virtual void operator()(){
          glInvalidateBufferSubData(
            ge::core::convertTo<GLuint    >(this->buffer),
            ge::core::convertTo<GLintptr  >(this->offset),
            ge::core::convertTo<GLsizeiptr>(this->length)
          );
        }
    };

    class ResumeTransformFeedback:
        public ge::core::Command{
      public:
        ResumeTransformFeedback(
            ){
        }
        virtual~ResumeTransformFeedback(){}
        virtual void operator()(){
          glResumeTransformFeedback(

          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class ProgramUniformMatrix4x3fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix4x3fv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix4x3fv(){}
        virtual void operator()(){
          glProgramUniformMatrix4x3fv(
            ge::core::convertTo<GLuint        >(this->program  ),
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename FIRST_TYPE = GLuint        ,
      typename COUNT_TYPE = GLsizei       ,
      typename V_TYPE     = const GLfloat*>
    class ViewportArrayv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "first")return(void*)&this->first;
          if(name == "count")return(void*)&this->count;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        FIRST_TYPE first;
        COUNT_TYPE count;
        V_TYPE     v    ;
        ViewportArrayv(
            FIRST_TYPE const&first,
            COUNT_TYPE const&count,
            V_TYPE     const&v    ){
          this->first = first;
          this->count = count;
          this->v     = v    ;
        }
        virtual~ViewportArrayv(){}
        virtual void operator()(){
          glViewportArrayv(
            ge::core::convertTo<GLuint        >(this->first),
            ge::core::convertTo<GLsizei       >(this->count),
            ge::core::convertTo<const GLfloat*>(this->v    )
          );
        }
    };

    template<
      typename N_TYPE            = GLsizei      ,
      typename FRAMEBUFFERS_TYPE = const GLuint*>
    class DeleteFramebuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"           )return(void*)&this->n           ;
          if(name == "framebuffers")return(void*)&this->framebuffers;
          return NULL;
        }
      public:
        N_TYPE            n           ;
        FRAMEBUFFERS_TYPE framebuffers;
        DeleteFramebuffers(
            N_TYPE            const&n           ,
            FRAMEBUFFERS_TYPE const&framebuffers){
          this->n            = n           ;
          this->framebuffers = framebuffers;
        }
        virtual~DeleteFramebuffers(){}
        virtual void operator()(){
          glDeleteFramebuffers(
            ge::core::convertTo<GLsizei      >(this->n           ),
            ge::core::convertTo<const GLuint*>(this->framebuffers)
          );
        }
    };

    template<
      typename MODE_TYPE  = GLenum ,
      typename FIRST_TYPE = GLint  ,
      typename COUNT_TYPE = GLsizei>
    class DrawArrays:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode" )return(void*)&this->mode ;
          if(name == "first")return(void*)&this->first;
          if(name == "count")return(void*)&this->count;
          return NULL;
        }
      public:
        MODE_TYPE  mode ;
        FIRST_TYPE first;
        COUNT_TYPE count;
        DrawArrays(
            MODE_TYPE  const&mode ,
            FIRST_TYPE const&first,
            COUNT_TYPE const&count){
          this->mode  = mode ;
          this->first = first;
          this->count = count;
        }
        virtual~DrawArrays(){}
        virtual void operator()(){
          glDrawArrays(
            ge::core::convertTo<GLenum >(this->mode ),
            ge::core::convertTo<GLint  >(this->first),
            ge::core::convertTo<GLsizei>(this->count)
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint>
    class Uniform1ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        Uniform1ui(
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ){
          this->location = location;
          this->v0       = v0      ;
        }
        virtual~Uniform1ui(){}
        virtual void operator()(){
          glUniform1ui(
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLuint>(this->v0      )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    class VertexAttrib1dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib1dv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib1dv(){}
        virtual void operator()(){
          glVertexAttrib1dv(
            ge::core::convertTo<GLuint         >(this->index),
            ge::core::convertTo<const GLdouble*>(this->v    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLint ,
      typename Y_TYPE     = GLint >
    class VertexAttribI2i:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        VertexAttribI2i(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
        }
        virtual~VertexAttribI2i(){}
        virtual void operator()(){
          glVertexAttribI2i(
            ge::core::convertTo<GLuint>(this->index),
            ge::core::convertTo<GLint >(this->x    ),
            ge::core::convertTo<GLint >(this->y    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble,
      typename Z_TYPE     = GLdouble>
    class VertexAttrib3d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        VertexAttrib3d(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
        }
        virtual~VertexAttrib3d(){}
        virtual void operator()(){
          glVertexAttrib3d(
            ge::core::convertTo<GLuint  >(this->index),
            ge::core::convertTo<GLdouble>(this->x    ),
            ge::core::convertTo<GLdouble>(this->y    ),
            ge::core::convertTo<GLdouble>(this->z    )
          );
        }
    };

    template<
      typename MASK_TYPE = GLbitfield>
    class Clear:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mask")return(void*)&this->mask;
          return NULL;
        }
      public:
        MASK_TYPE mask;
        Clear(
            MASK_TYPE const&mask){
          this->mask = mask;
        }
        virtual~Clear(){}
        virtual void operator()(){
          glClear(
            ge::core::convertTo<GLbitfield>(this->mask)
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename VALUE_TYPE   = GLint >
    class ProgramParameteri:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "value"  )return(void*)&this->value  ;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        PNAME_TYPE   pname  ;
        VALUE_TYPE   value  ;
        ProgramParameteri(
            PROGRAM_TYPE const&program,
            PNAME_TYPE   const&pname  ,
            VALUE_TYPE   const&value  ){
          this->program = program;
          this->pname   = pname  ;
          this->value   = value  ;
        }
        virtual~ProgramParameteri(){}
        virtual void operator()(){
          glProgramParameteri(
            ge::core::convertTo<GLuint>(this->program),
            ge::core::convertTo<GLenum>(this->pname  ),
            ge::core::convertTo<GLint >(this->value  )
          );
        }
    };

    template<
      typename PROGRAM_TYPE      = GLuint  ,
      typename UNIFORMINDEX_TYPE = GLuint  ,
      typename BUFSIZE_TYPE      = GLsizei ,
      typename LENGTH_TYPE       = GLsizei*,
      typename UNIFORMNAME_TYPE  = GLchar* >
    class GetActiveUniformName:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"     )return(void*)&this->program     ;
          if(name == "uniformIndex")return(void*)&this->uniformIndex;
          if(name == "bufSize"     )return(void*)&this->bufSize     ;
          if(name == "length"      )return(void*)&this->length      ;
          if(name == "uniformName" )return(void*)&this->uniformName ;
          return NULL;
        }
      public:
        PROGRAM_TYPE      program     ;
        UNIFORMINDEX_TYPE uniformIndex;
        BUFSIZE_TYPE      bufSize     ;
        LENGTH_TYPE       length      ;
        UNIFORMNAME_TYPE  uniformName ;
        GetActiveUniformName(
            PROGRAM_TYPE      const&program     ,
            UNIFORMINDEX_TYPE const&uniformIndex,
            BUFSIZE_TYPE      const&bufSize     ,
            LENGTH_TYPE       const&length      ,
            UNIFORMNAME_TYPE  const&uniformName ){
          this->program      = program     ;
          this->uniformIndex = uniformIndex;
          this->bufSize      = bufSize     ;
          this->length       = length      ;
          this->uniformName  = uniformName ;
        }
        virtual~GetActiveUniformName(){}
        virtual void operator()(){
          glGetActiveUniformName(
            ge::core::convertTo<GLuint  >(this->program     ),
            ge::core::convertTo<GLuint  >(this->uniformIndex),
            ge::core::convertTo<GLsizei >(this->bufSize     ),
            ge::core::convertTo<GLsizei*>(this->length      ),
            ge::core::convertTo<GLchar* >(this->uniformName )
          );
        }
    };

    template<
      typename BARRIERS_TYPE = GLbitfield>
    class MemoryBarrier:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "barriers")return(void*)&this->barriers;
          return NULL;
        }
      public:
        BARRIERS_TYPE barriers;
        MemoryBarrier(
            BARRIERS_TYPE const&barriers){
          this->barriers = barriers;
        }
        virtual~MemoryBarrier(){}
        virtual void operator()(){
          glMemoryBarrier(
            ge::core::convertTo<GLbitfield>(this->barriers)
          );
        }
    };

    template<
      typename RET_TYPE = GLenum>
    class GetGraphicsResetStatus:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret")return(void*)&this->ret;
          return NULL;
        }
      public:
        RET_TYPE ret;
        GetGraphicsResetStatus(
            RET_TYPE const&ret){
          this->ret = ret;
        }
        virtual~GetGraphicsResetStatus(){}
        virtual void operator()(){
          ge::core::convertFrom<GLenum>(this->ret,glGetGraphicsResetStatus()
          );
        }
    };

    template<
      typename TARGET_TYPE  = GLenum,
      typename TEXTURE_TYPE = GLuint>
    class BindTexture:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target" )return(void*)&this->target ;
          if(name == "texture")return(void*)&this->texture;
          return NULL;
        }
      public:
        TARGET_TYPE  target ;
        TEXTURE_TYPE texture;
        BindTexture(
            TARGET_TYPE  const&target ,
            TEXTURE_TYPE const&texture){
          this->target  = target ;
          this->texture = texture;
        }
        virtual~BindTexture(){}
        virtual void operator()(){
          glBindTexture(
            ge::core::convertTo<GLenum>(this->target ),
            ge::core::convertTo<GLuint>(this->texture)
          );
        }
    };

    template<
      typename RET_TYPE = GLboolean,
      typename CAP_TYPE = GLenum   >
    class IsEnabled:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret")return(void*)&this->ret;
          if(name == "cap")return(void*)&this->cap;
          return NULL;
        }
      public:
        RET_TYPE ret;
        CAP_TYPE cap;
        IsEnabled(
            RET_TYPE const&ret,
            CAP_TYPE const&cap){
          this->ret = ret;
          this->cap = cap;
        }
        virtual~IsEnabled(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsEnabled(
              ge::core::convertTo<GLenum   >(this->cap))
          );
        }
    };

    template<
      typename INDEX_TYPE      = GLuint   ,
      typename TYPE_TYPE       = GLenum   ,
      typename NORMALIZED_TYPE = GLboolean,
      typename VALUE_TYPE      = GLuint   >
    class VertexAttribP2ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"     )return(void*)&this->index     ;
          if(name == "type"      )return(void*)&this->type      ;
          if(name == "normalized")return(void*)&this->normalized;
          if(name == "value"     )return(void*)&this->value     ;
          return NULL;
        }
      public:
        INDEX_TYPE      index     ;
        TYPE_TYPE       type      ;
        NORMALIZED_TYPE normalized;
        VALUE_TYPE      value     ;
        VertexAttribP2ui(
            INDEX_TYPE      const&index     ,
            TYPE_TYPE       const&type      ,
            NORMALIZED_TYPE const&normalized,
            VALUE_TYPE      const&value     ){
          this->index      = index     ;
          this->type       = type      ;
          this->normalized = normalized;
          this->value      = value     ;
        }
        virtual~VertexAttribP2ui(){}
        virtual void operator()(){
          glVertexAttribP2ui(
            ge::core::convertTo<GLuint   >(this->index     ),
            ge::core::convertTo<GLenum   >(this->type      ),
            ge::core::convertTo<GLboolean>(this->normalized),
            ge::core::convertTo<GLuint   >(this->value     )
          );
        }
    };

    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTARGET_TYPE  = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint >
    class FramebufferTexture2D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"    )return(void*)&this->target    ;
          if(name == "attachment")return(void*)&this->attachment;
          if(name == "textarget" )return(void*)&this->textarget ;
          if(name == "texture"   )return(void*)&this->texture   ;
          if(name == "level"     )return(void*)&this->level     ;
          return NULL;
        }
      public:
        TARGET_TYPE     target    ;
        ATTACHMENT_TYPE attachment;
        TEXTARGET_TYPE  textarget ;
        TEXTURE_TYPE    texture   ;
        LEVEL_TYPE      level     ;
        FramebufferTexture2D(
            TARGET_TYPE     const&target    ,
            ATTACHMENT_TYPE const&attachment,
            TEXTARGET_TYPE  const&textarget ,
            TEXTURE_TYPE    const&texture   ,
            LEVEL_TYPE      const&level     ){
          this->target     = target    ;
          this->attachment = attachment;
          this->textarget  = textarget ;
          this->texture    = texture   ;
          this->level      = level     ;
        }
        virtual~FramebufferTexture2D(){}
        virtual void operator()(){
          glFramebufferTexture2D(
            ge::core::convertTo<GLenum>(this->target    ),
            ge::core::convertTo<GLenum>(this->attachment),
            ge::core::convertTo<GLenum>(this->textarget ),
            ge::core::convertTo<GLuint>(this->texture   ),
            ge::core::convertTo<GLint >(this->level     )
          );
        }
    };

    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename PNAME_TYPE      = GLenum,
      typename PARAMS_TYPE     = GLint*>
    class GetFramebufferAttachmentParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"    )return(void*)&this->target    ;
          if(name == "attachment")return(void*)&this->attachment;
          if(name == "pname"     )return(void*)&this->pname     ;
          if(name == "params"    )return(void*)&this->params    ;
          return NULL;
        }
      public:
        TARGET_TYPE     target    ;
        ATTACHMENT_TYPE attachment;
        PNAME_TYPE      pname     ;
        PARAMS_TYPE     params    ;
        GetFramebufferAttachmentParameteriv(
            TARGET_TYPE     const&target    ,
            ATTACHMENT_TYPE const&attachment,
            PNAME_TYPE      const&pname     ,
            PARAMS_TYPE     const&params    ){
          this->target     = target    ;
          this->attachment = attachment;
          this->pname      = pname     ;
          this->params     = params    ;
        }
        virtual~GetFramebufferAttachmentParameteriv(){}
        virtual void operator()(){
          glGetFramebufferAttachmentParameteriv(
            ge::core::convertTo<GLenum>(this->target    ),
            ge::core::convertTo<GLenum>(this->attachment),
            ge::core::convertTo<GLenum>(this->pname     ),
            ge::core::convertTo<GLint*>(this->params    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLubyte,
      typename Y_TYPE     = GLubyte,
      typename Z_TYPE     = GLubyte,
      typename W_TYPE     = GLubyte>
    class VertexAttrib4Nub:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          if(name == "w"    )return(void*)&this->w    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        W_TYPE     w    ;
        VertexAttrib4Nub(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ,
            W_TYPE     const&w    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
          this->w     = w    ;
        }
        virtual~VertexAttrib4Nub(){}
        virtual void operator()(){
          glVertexAttrib4Nub(
            ge::core::convertTo<GLuint >(this->index),
            ge::core::convertTo<GLubyte>(this->x    ),
            ge::core::convertTo<GLubyte>(this->y    ),
            ge::core::convertTo<GLubyte>(this->z    ),
            ge::core::convertTo<GLubyte>(this->w    )
          );
        }
    };

    template<
      typename RET_TYPE    = void*     ,
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr,
      typename ACCESS_TYPE = GLbitfield>
    class MapNamedBufferRange:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"   )return(void*)&this->ret   ;
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "offset")return(void*)&this->offset;
          if(name == "length")return(void*)&this->length;
          if(name == "access")return(void*)&this->access;
          return NULL;
        }
      public:
        RET_TYPE    ret   ;
        BUFFER_TYPE buffer;
        OFFSET_TYPE offset;
        LENGTH_TYPE length;
        ACCESS_TYPE access;
        MapNamedBufferRange(
            RET_TYPE    const&ret   ,
            BUFFER_TYPE const&buffer,
            OFFSET_TYPE const&offset,
            LENGTH_TYPE const&length,
            ACCESS_TYPE const&access){
          this->ret    = ret   ;
          this->buffer = buffer;
          this->offset = offset;
          this->length = length;
          this->access = access;
        }
        virtual~MapNamedBufferRange(){}
        virtual void operator()(){
          ge::core::convertFrom<void*>(this->ret,glMapNamedBufferRange(
              ge::core::convertTo<GLuint    >(this->buffer),
              ge::core::convertTo<GLintptr  >(this->offset),
              ge::core::convertTo<GLsizeiptr>(this->length),
              ge::core::convertTo<GLbitfield>(this->access))
          );
        }
    };

    template<
      typename RET_TYPE     = GLint        ,
      typename PROGRAM_TYPE = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    class GetFragDataLocation:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"    )return(void*)&this->ret    ;
          if(name == "program")return(void*)&this->program;
          if(name == "name"   )return(void*)&this->name   ;
          return NULL;
        }
      public:
        RET_TYPE     ret    ;
        PROGRAM_TYPE program;
        NAME_TYPE    name   ;
        GetFragDataLocation(
            RET_TYPE     const&ret    ,
            PROGRAM_TYPE const&program,
            NAME_TYPE    const&name   ){
          this->ret     = ret    ;
          this->program = program;
          this->name    = name   ;
        }
        virtual~GetFragDataLocation(){}
        virtual void operator()(){
          ge::core::convertFrom<GLint>(this->ret,glGetFragDataLocation(
              ge::core::convertTo<GLuint       >(this->program),
              ge::core::convertTo<const GLchar*>(this->name   ))
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    class GetTextureParameterIiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        GetTextureParameterIiv(
            TEXTURE_TYPE const&texture,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->texture = texture;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~GetTextureParameterIiv(){}
        virtual void operator()(){
          glGetTextureParameterIiv(
            ge::core::convertTo<GLuint>(this->texture),
            ge::core::convertTo<GLenum>(this->pname  ),
            ge::core::convertTo<GLint*>(this->params )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLint      ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename PIXELS_TYPE         = const void*>
    class TexImage1D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "level"         )return(void*)&this->level         ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "border"        )return(void*)&this->border        ;
          if(name == "format"        )return(void*)&this->format        ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "pixels"        )return(void*)&this->pixels        ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        LEVEL_TYPE          level         ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        BORDER_TYPE         border        ;
        FORMAT_TYPE         format        ;
        TYPE_TYPE           type          ;
        PIXELS_TYPE         pixels        ;
        TexImage1D(
            TARGET_TYPE         const&target        ,
            LEVEL_TYPE          const&level         ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            BORDER_TYPE         const&border        ,
            FORMAT_TYPE         const&format        ,
            TYPE_TYPE           const&type          ,
            PIXELS_TYPE         const&pixels        ){
          this->target         = target        ;
          this->level          = level         ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->border         = border        ;
          this->format         = format        ;
          this->type           = type          ;
          this->pixels         = pixels        ;
        }
        virtual~TexImage1D(){}
        virtual void operator()(){
          glTexImage1D(
            ge::core::convertTo<GLenum     >(this->target        ),
            ge::core::convertTo<GLint      >(this->level         ),
            ge::core::convertTo<GLint      >(this->internalformat),
            ge::core::convertTo<GLsizei    >(this->width         ),
            ge::core::convertTo<GLint      >(this->border        ),
            ge::core::convertTo<GLenum     >(this->format        ),
            ge::core::convertTo<GLenum     >(this->type          ),
            ge::core::convertTo<const void*>(this->pixels        )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum      ,
      typename PNAME_TYPE  = GLenum      ,
      typename PARAMS_TYPE = const GLint*>
    class TexParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        TexParameteriv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~TexParameteriv(){}
        virtual void operator()(){
          glTexParameteriv(
            ge::core::convertTo<GLenum      >(this->target),
            ge::core::convertTo<GLenum      >(this->pname ),
            ge::core::convertTo<const GLint*>(this->params)
          );
        }
    };

    template<
      typename VAOBJ_TYPE          = GLuint,
      typename ATTRIBINDEX_TYPE    = GLuint,
      typename SIZE_TYPE           = GLint ,
      typename TYPE_TYPE           = GLenum,
      typename RELATIVEOFFSET_TYPE = GLuint>
    class VertexArrayAttribIFormat:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj"         )return(void*)&this->vaobj         ;
          if(name == "attribindex"   )return(void*)&this->attribindex   ;
          if(name == "size"          )return(void*)&this->size          ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "relativeoffset")return(void*)&this->relativeoffset;
          return NULL;
        }
      public:
        VAOBJ_TYPE          vaobj         ;
        ATTRIBINDEX_TYPE    attribindex   ;
        SIZE_TYPE           size          ;
        TYPE_TYPE           type          ;
        RELATIVEOFFSET_TYPE relativeoffset;
        VertexArrayAttribIFormat(
            VAOBJ_TYPE          const&vaobj         ,
            ATTRIBINDEX_TYPE    const&attribindex   ,
            SIZE_TYPE           const&size          ,
            TYPE_TYPE           const&type          ,
            RELATIVEOFFSET_TYPE const&relativeoffset){
          this->vaobj          = vaobj         ;
          this->attribindex    = attribindex   ;
          this->size           = size          ;
          this->type           = type          ;
          this->relativeoffset = relativeoffset;
        }
        virtual~VertexArrayAttribIFormat(){}
        virtual void operator()(){
          glVertexArrayAttribIFormat(
            ge::core::convertTo<GLuint>(this->vaobj         ),
            ge::core::convertTo<GLuint>(this->attribindex   ),
            ge::core::convertTo<GLint >(this->size          ),
            ge::core::convertTo<GLenum>(this->type          ),
            ge::core::convertTo<GLuint>(this->relativeoffset)
          );
        }
    };

    template<
      typename VAOBJ_TYPE        = GLuint  ,
      typename BINDINGINDEX_TYPE = GLuint  ,
      typename BUFFER_TYPE       = GLuint  ,
      typename OFFSET_TYPE       = GLintptr,
      typename STRIDE_TYPE       = GLsizei >
    class VertexArrayVertexBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj"       )return(void*)&this->vaobj       ;
          if(name == "bindingindex")return(void*)&this->bindingindex;
          if(name == "buffer"      )return(void*)&this->buffer      ;
          if(name == "offset"      )return(void*)&this->offset      ;
          if(name == "stride"      )return(void*)&this->stride      ;
          return NULL;
        }
      public:
        VAOBJ_TYPE        vaobj       ;
        BINDINGINDEX_TYPE bindingindex;
        BUFFER_TYPE       buffer      ;
        OFFSET_TYPE       offset      ;
        STRIDE_TYPE       stride      ;
        VertexArrayVertexBuffer(
            VAOBJ_TYPE        const&vaobj       ,
            BINDINGINDEX_TYPE const&bindingindex,
            BUFFER_TYPE       const&buffer      ,
            OFFSET_TYPE       const&offset      ,
            STRIDE_TYPE       const&stride      ){
          this->vaobj        = vaobj       ;
          this->bindingindex = bindingindex;
          this->buffer       = buffer      ;
          this->offset       = offset      ;
          this->stride       = stride      ;
        }
        virtual~VertexArrayVertexBuffer(){}
        virtual void operator()(){
          glVertexArrayVertexBuffer(
            ge::core::convertTo<GLuint  >(this->vaobj       ),
            ge::core::convertTo<GLuint  >(this->bindingindex),
            ge::core::convertTo<GLuint  >(this->buffer      ),
            ge::core::convertTo<GLintptr>(this->offset      ),
            ge::core::convertTo<GLsizei >(this->stride      )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename LEVEL_TYPE  = GLint ,
      typename FORMAT_TYPE = GLenum,
      typename TYPE_TYPE   = GLenum,
      typename PIXELS_TYPE = void* >
    class GetTexImage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "level" )return(void*)&this->level ;
          if(name == "format")return(void*)&this->format;
          if(name == "type"  )return(void*)&this->type  ;
          if(name == "pixels")return(void*)&this->pixels;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        LEVEL_TYPE  level ;
        FORMAT_TYPE format;
        TYPE_TYPE   type  ;
        PIXELS_TYPE pixels;
        GetTexImage(
            TARGET_TYPE const&target,
            LEVEL_TYPE  const&level ,
            FORMAT_TYPE const&format,
            TYPE_TYPE   const&type  ,
            PIXELS_TYPE const&pixels){
          this->target = target;
          this->level  = level ;
          this->format = format;
          this->type   = type  ;
          this->pixels = pixels;
        }
        virtual~GetTexImage(){}
        virtual void operator()(){
          glGetTexImage(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLint >(this->level ),
            ge::core::convertTo<GLenum>(this->format),
            ge::core::convertTo<GLenum>(this->type  ),
            ge::core::convertTo<void* >(this->pixels)
          );
        }
    };

    template<
      typename ID_TYPE     = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLint64*>
    class GetQueryObjecti64v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "id"    )return(void*)&this->id    ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        ID_TYPE     id    ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetQueryObjecti64v(
            ID_TYPE     const&id    ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->id     = id    ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetQueryObjecti64v(){}
        virtual void operator()(){
          glGetQueryObjecti64v(
            ge::core::convertTo<GLuint  >(this->id    ),
            ge::core::convertTo<GLenum  >(this->pname ),
            ge::core::convertTo<GLint64*>(this->params)
          );
        }
    };

    template<
      typename N_TYPE            = GLsizei,
      typename FRAMEBUFFERS_TYPE = GLuint*>
    class GenFramebuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"           )return(void*)&this->n           ;
          if(name == "framebuffers")return(void*)&this->framebuffers;
          return NULL;
        }
      public:
        N_TYPE            n           ;
        FRAMEBUFFERS_TYPE framebuffers;
        GenFramebuffers(
            N_TYPE            const&n           ,
            FRAMEBUFFERS_TYPE const&framebuffers){
          this->n            = n           ;
          this->framebuffers = framebuffers;
        }
        virtual~GenFramebuffers(){}
        virtual void operator()(){
          glGenFramebuffers(
            ge::core::convertTo<GLsizei>(this->n           ),
            ge::core::convertTo<GLuint*>(this->framebuffers)
          );
        }
    };

    template<
      typename XFB_TYPE    = GLuint,
      typename INDEX_TYPE  = GLuint,
      typename BUFFER_TYPE = GLuint>
    class TransformFeedbackBufferBase:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "xfb"   )return(void*)&this->xfb   ;
          if(name == "index" )return(void*)&this->index ;
          if(name == "buffer")return(void*)&this->buffer;
          return NULL;
        }
      public:
        XFB_TYPE    xfb   ;
        INDEX_TYPE  index ;
        BUFFER_TYPE buffer;
        TransformFeedbackBufferBase(
            XFB_TYPE    const&xfb   ,
            INDEX_TYPE  const&index ,
            BUFFER_TYPE const&buffer){
          this->xfb    = xfb   ;
          this->index  = index ;
          this->buffer = buffer;
        }
        virtual~TransformFeedbackBufferBase(){}
        virtual void operator()(){
          glTransformFeedbackBufferBase(
            ge::core::convertTo<GLuint>(this->xfb   ),
            ge::core::convertTo<GLuint>(this->index ),
            ge::core::convertTo<GLuint>(this->buffer)
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename ZOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename DEPTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename DATA_TYPE    = const void*>
    class ClearTexSubImage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "yoffset")return(void*)&this->yoffset;
          if(name == "zoffset")return(void*)&this->zoffset;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          if(name == "depth"  )return(void*)&this->depth  ;
          if(name == "format" )return(void*)&this->format ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "data"   )return(void*)&this->data   ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        YOFFSET_TYPE yoffset;
        ZOFFSET_TYPE zoffset;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        DEPTH_TYPE   depth  ;
        FORMAT_TYPE  format ;
        TYPE_TYPE    type   ;
        DATA_TYPE    data   ;
        ClearTexSubImage(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            YOFFSET_TYPE const&yoffset,
            ZOFFSET_TYPE const&zoffset,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ,
            DEPTH_TYPE   const&depth  ,
            FORMAT_TYPE  const&format ,
            TYPE_TYPE    const&type   ,
            DATA_TYPE    const&data   ){
          this->texture = texture;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->yoffset = yoffset;
          this->zoffset = zoffset;
          this->width   = width  ;
          this->height  = height ;
          this->depth   = depth  ;
          this->format  = format ;
          this->type    = type   ;
          this->data    = data   ;
        }
        virtual~ClearTexSubImage(){}
        virtual void operator()(){
          glClearTexSubImage(
            ge::core::convertTo<GLuint     >(this->texture),
            ge::core::convertTo<GLint      >(this->level  ),
            ge::core::convertTo<GLint      >(this->xoffset),
            ge::core::convertTo<GLint      >(this->yoffset),
            ge::core::convertTo<GLint      >(this->zoffset),
            ge::core::convertTo<GLsizei    >(this->width  ),
            ge::core::convertTo<GLsizei    >(this->height ),
            ge::core::convertTo<GLsizei    >(this->depth  ),
            ge::core::convertTo<GLenum     >(this->format ),
            ge::core::convertTo<GLenum     >(this->type   ),
            ge::core::convertTo<const void*>(this->data   )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename MAXCOUNT_TYPE = GLsizei ,
      typename COUNT_TYPE    = GLsizei*,
      typename SHADERS_TYPE  = GLuint* >
    class GetAttachedShaders:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "maxCount")return(void*)&this->maxCount;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "shaders" )return(void*)&this->shaders ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        MAXCOUNT_TYPE maxCount;
        COUNT_TYPE    count   ;
        SHADERS_TYPE  shaders ;
        GetAttachedShaders(
            PROGRAM_TYPE  const&program ,
            MAXCOUNT_TYPE const&maxCount,
            COUNT_TYPE    const&count   ,
            SHADERS_TYPE  const&shaders ){
          this->program  = program ;
          this->maxCount = maxCount;
          this->count    = count   ;
          this->shaders  = shaders ;
        }
        virtual~GetAttachedShaders(){}
        virtual void operator()(){
          glGetAttachedShaders(
            ge::core::convertTo<GLuint  >(this->program ),
            ge::core::convertTo<GLsizei >(this->maxCount),
            ge::core::convertTo<GLsizei*>(this->count   ),
            ge::core::convertTo<GLuint* >(this->shaders )
          );
        }
    };

    template<
      typename RET_TYPE          = GLboolean,
      typename RENDERBUFFER_TYPE = GLuint   >
    class IsRenderbuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"         )return(void*)&this->ret         ;
          if(name == "renderbuffer")return(void*)&this->renderbuffer;
          return NULL;
        }
      public:
        RET_TYPE          ret         ;
        RENDERBUFFER_TYPE renderbuffer;
        IsRenderbuffer(
            RET_TYPE          const&ret         ,
            RENDERBUFFER_TYPE const&renderbuffer){
          this->ret          = ret         ;
          this->renderbuffer = renderbuffer;
        }
        virtual~IsRenderbuffer(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsRenderbuffer(
              ge::core::convertTo<GLuint   >(this->renderbuffer))
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint       ,
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    class ProgramUniform3uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform3uiv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform3uiv(){}
        virtual void operator()(){
          glProgramUniform3uiv(
            ge::core::convertTo<GLuint       >(this->program ),
            ge::core::convertTo<GLint        >(this->location),
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->value   )
          );
        }
    };

    template<
      typename FIRST_TYPE   = GLuint         ,
      typename COUNT_TYPE   = GLsizei        ,
      typename BUFFERS_TYPE = const GLuint*  ,
      typename OFFSETS_TYPE = const GLintptr*,
      typename STRIDES_TYPE = const GLsizei* >
    class BindVertexBuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "first"  )return(void*)&this->first  ;
          if(name == "count"  )return(void*)&this->count  ;
          if(name == "buffers")return(void*)&this->buffers;
          if(name == "offsets")return(void*)&this->offsets;
          if(name == "strides")return(void*)&this->strides;
          return NULL;
        }
      public:
        FIRST_TYPE   first  ;
        COUNT_TYPE   count  ;
        BUFFERS_TYPE buffers;
        OFFSETS_TYPE offsets;
        STRIDES_TYPE strides;
        BindVertexBuffers(
            FIRST_TYPE   const&first  ,
            COUNT_TYPE   const&count  ,
            BUFFERS_TYPE const&buffers,
            OFFSETS_TYPE const&offsets,
            STRIDES_TYPE const&strides){
          this->first   = first  ;
          this->count   = count  ;
          this->buffers = buffers;
          this->offsets = offsets;
          this->strides = strides;
        }
        virtual~BindVertexBuffers(){}
        virtual void operator()(){
          glBindVertexBuffers(
            ge::core::convertTo<GLuint         >(this->first  ),
            ge::core::convertTo<GLsizei        >(this->count  ),
            ge::core::convertTo<const GLuint*  >(this->buffers),
            ge::core::convertTo<const GLintptr*>(this->offsets),
            ge::core::convertTo<const GLsizei* >(this->strides)
          );
        }
    };

    template<
      typename RET_TYPE    = void*     ,
      typename TARGET_TYPE = GLenum    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr,
      typename ACCESS_TYPE = GLbitfield>
    class MapBufferRange:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"   )return(void*)&this->ret   ;
          if(name == "target")return(void*)&this->target;
          if(name == "offset")return(void*)&this->offset;
          if(name == "length")return(void*)&this->length;
          if(name == "access")return(void*)&this->access;
          return NULL;
        }
      public:
        RET_TYPE    ret   ;
        TARGET_TYPE target;
        OFFSET_TYPE offset;
        LENGTH_TYPE length;
        ACCESS_TYPE access;
        MapBufferRange(
            RET_TYPE    const&ret   ,
            TARGET_TYPE const&target,
            OFFSET_TYPE const&offset,
            LENGTH_TYPE const&length,
            ACCESS_TYPE const&access){
          this->ret    = ret   ;
          this->target = target;
          this->offset = offset;
          this->length = length;
          this->access = access;
        }
        virtual~MapBufferRange(){}
        virtual void operator()(){
          ge::core::convertFrom<void*>(this->ret,glMapBufferRange(
              ge::core::convertTo<GLenum    >(this->target),
              ge::core::convertTo<GLintptr  >(this->offset),
              ge::core::convertTo<GLsizeiptr>(this->length),
              ge::core::convertTo<GLbitfield>(this->access))
          );
        }
    };

    template<
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr,
      typename DATA_TYPE   = void*     >
    class GetNamedBufferSubData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "offset")return(void*)&this->offset;
          if(name == "size"  )return(void*)&this->size  ;
          if(name == "data"  )return(void*)&this->data  ;
          return NULL;
        }
      public:
        BUFFER_TYPE buffer;
        OFFSET_TYPE offset;
        SIZE_TYPE   size  ;
        DATA_TYPE   data  ;
        GetNamedBufferSubData(
            BUFFER_TYPE const&buffer,
            OFFSET_TYPE const&offset,
            SIZE_TYPE   const&size  ,
            DATA_TYPE   const&data  ){
          this->buffer = buffer;
          this->offset = offset;
          this->size   = size  ;
          this->data   = data  ;
        }
        virtual~GetNamedBufferSubData(){}
        virtual void operator()(){
          glGetNamedBufferSubData(
            ge::core::convertTo<GLuint    >(this->buffer),
            ge::core::convertTo<GLintptr  >(this->offset),
            ge::core::convertTo<GLsizeiptr>(this->size  ),
            ge::core::convertTo<void*     >(this->data  )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint>
    class DisableVertexAttribArray:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        DisableVertexAttribArray(
            INDEX_TYPE const&index){
          this->index = index;
        }
        virtual~DisableVertexAttribArray(){}
        virtual void operator()(){
          glDisableVertexAttribArray(
            ge::core::convertTo<GLuint>(this->index)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint      ,
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    class ProgramUniform2iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform2iv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform2iv(){}
        virtual void operator()(){
          glProgramUniform2iv(
            ge::core::convertTo<GLuint      >(this->program ),
            ge::core::convertTo<GLint       >(this->location),
            ge::core::convertTo<GLsizei     >(this->count   ),
            ge::core::convertTo<const GLint*>(this->value   )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetQueryiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetQueryiv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetQueryiv(){}
        virtual void operator()(){
          glGetQueryiv(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    template<
      typename XFB_TYPE   = GLuint,
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint*>
    class GetTransformFeedbackiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "xfb"  )return(void*)&this->xfb  ;
          if(name == "pname")return(void*)&this->pname;
          if(name == "param")return(void*)&this->param;
          return NULL;
        }
      public:
        XFB_TYPE   xfb  ;
        PNAME_TYPE pname;
        PARAM_TYPE param;
        GetTransformFeedbackiv(
            XFB_TYPE   const&xfb  ,
            PNAME_TYPE const&pname,
            PARAM_TYPE const&param){
          this->xfb   = xfb  ;
          this->pname = pname;
          this->param = param;
        }
        virtual~GetTransformFeedbackiv(){}
        virtual void operator()(){
          glGetTransformFeedbackiv(
            ge::core::convertTo<GLuint>(this->xfb  ),
            ge::core::convertTo<GLenum>(this->pname),
            ge::core::convertTo<GLint*>(this->param)
          );
        }
    };

    template<
      typename READFRAMEBUFFER_TYPE = GLuint    ,
      typename DRAWFRAMEBUFFER_TYPE = GLuint    ,
      typename SRCX0_TYPE           = GLint     ,
      typename SRCY0_TYPE           = GLint     ,
      typename SRCX1_TYPE           = GLint     ,
      typename SRCY1_TYPE           = GLint     ,
      typename DSTX0_TYPE           = GLint     ,
      typename DSTY0_TYPE           = GLint     ,
      typename DSTX1_TYPE           = GLint     ,
      typename DSTY1_TYPE           = GLint     ,
      typename MASK_TYPE            = GLbitfield,
      typename FILTER_TYPE          = GLenum    >
    class BlitNamedFramebuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "readFramebuffer")return(void*)&this->readFramebuffer;
          if(name == "drawFramebuffer")return(void*)&this->drawFramebuffer;
          if(name == "srcX0"          )return(void*)&this->srcX0          ;
          if(name == "srcY0"          )return(void*)&this->srcY0          ;
          if(name == "srcX1"          )return(void*)&this->srcX1          ;
          if(name == "srcY1"          )return(void*)&this->srcY1          ;
          if(name == "dstX0"          )return(void*)&this->dstX0          ;
          if(name == "dstY0"          )return(void*)&this->dstY0          ;
          if(name == "dstX1"          )return(void*)&this->dstX1          ;
          if(name == "dstY1"          )return(void*)&this->dstY1          ;
          if(name == "mask"           )return(void*)&this->mask           ;
          if(name == "filter"         )return(void*)&this->filter         ;
          return NULL;
        }
      public:
        READFRAMEBUFFER_TYPE readFramebuffer;
        DRAWFRAMEBUFFER_TYPE drawFramebuffer;
        SRCX0_TYPE           srcX0          ;
        SRCY0_TYPE           srcY0          ;
        SRCX1_TYPE           srcX1          ;
        SRCY1_TYPE           srcY1          ;
        DSTX0_TYPE           dstX0          ;
        DSTY0_TYPE           dstY0          ;
        DSTX1_TYPE           dstX1          ;
        DSTY1_TYPE           dstY1          ;
        MASK_TYPE            mask           ;
        FILTER_TYPE          filter         ;
        BlitNamedFramebuffer(
            READFRAMEBUFFER_TYPE const&readFramebuffer,
            DRAWFRAMEBUFFER_TYPE const&drawFramebuffer,
            SRCX0_TYPE           const&srcX0          ,
            SRCY0_TYPE           const&srcY0          ,
            SRCX1_TYPE           const&srcX1          ,
            SRCY1_TYPE           const&srcY1          ,
            DSTX0_TYPE           const&dstX0          ,
            DSTY0_TYPE           const&dstY0          ,
            DSTX1_TYPE           const&dstX1          ,
            DSTY1_TYPE           const&dstY1          ,
            MASK_TYPE            const&mask           ,
            FILTER_TYPE          const&filter         ){
          this->readFramebuffer = readFramebuffer;
          this->drawFramebuffer = drawFramebuffer;
          this->srcX0           = srcX0          ;
          this->srcY0           = srcY0          ;
          this->srcX1           = srcX1          ;
          this->srcY1           = srcY1          ;
          this->dstX0           = dstX0          ;
          this->dstY0           = dstY0          ;
          this->dstX1           = dstX1          ;
          this->dstY1           = dstY1          ;
          this->mask            = mask           ;
          this->filter          = filter         ;
        }
        virtual~BlitNamedFramebuffer(){}
        virtual void operator()(){
          glBlitNamedFramebuffer(
            ge::core::convertTo<GLuint    >(this->readFramebuffer),
            ge::core::convertTo<GLuint    >(this->drawFramebuffer),
            ge::core::convertTo<GLint     >(this->srcX0          ),
            ge::core::convertTo<GLint     >(this->srcY0          ),
            ge::core::convertTo<GLint     >(this->srcX1          ),
            ge::core::convertTo<GLint     >(this->srcY1          ),
            ge::core::convertTo<GLint     >(this->dstX0          ),
            ge::core::convertTo<GLint     >(this->dstY0          ),
            ge::core::convertTo<GLint     >(this->dstX1          ),
            ge::core::convertTo<GLint     >(this->dstY1          ),
            ge::core::convertTo<GLbitfield>(this->mask           ),
            ge::core::convertTo<GLenum    >(this->filter         )
          );
        }
    };

    template<
      typename VAOBJ_TYPE          = GLuint,
      typename ATTRIBINDEX_TYPE    = GLuint,
      typename SIZE_TYPE           = GLint ,
      typename TYPE_TYPE           = GLenum,
      typename RELATIVEOFFSET_TYPE = GLuint>
    class VertexArrayAttribLFormat:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj"         )return(void*)&this->vaobj         ;
          if(name == "attribindex"   )return(void*)&this->attribindex   ;
          if(name == "size"          )return(void*)&this->size          ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "relativeoffset")return(void*)&this->relativeoffset;
          return NULL;
        }
      public:
        VAOBJ_TYPE          vaobj         ;
        ATTRIBINDEX_TYPE    attribindex   ;
        SIZE_TYPE           size          ;
        TYPE_TYPE           type          ;
        RELATIVEOFFSET_TYPE relativeoffset;
        VertexArrayAttribLFormat(
            VAOBJ_TYPE          const&vaobj         ,
            ATTRIBINDEX_TYPE    const&attribindex   ,
            SIZE_TYPE           const&size          ,
            TYPE_TYPE           const&type          ,
            RELATIVEOFFSET_TYPE const&relativeoffset){
          this->vaobj          = vaobj         ;
          this->attribindex    = attribindex   ;
          this->size           = size          ;
          this->type           = type          ;
          this->relativeoffset = relativeoffset;
        }
        virtual~VertexArrayAttribLFormat(){}
        virtual void operator()(){
          glVertexArrayAttribLFormat(
            ge::core::convertTo<GLuint>(this->vaobj         ),
            ge::core::convertTo<GLuint>(this->attribindex   ),
            ge::core::convertTo<GLint >(this->size          ),
            ge::core::convertTo<GLenum>(this->type          ),
            ge::core::convertTo<GLuint>(this->relativeoffset)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum ,
      typename N_TYPE      = GLsizei,
      typename IDS_TYPE    = GLuint*>
    class CreateQueries:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "n"     )return(void*)&this->n     ;
          if(name == "ids"   )return(void*)&this->ids   ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        N_TYPE      n     ;
        IDS_TYPE    ids   ;
        CreateQueries(
            TARGET_TYPE const&target,
            N_TYPE      const&n     ,
            IDS_TYPE    const&ids   ){
          this->target = target;
          this->n      = n     ;
          this->ids    = ids   ;
        }
        virtual~CreateQueries(){}
        virtual void operator()(){
          glCreateQueries(
            ge::core::convertTo<GLenum >(this->target),
            ge::core::convertTo<GLsizei>(this->n     ),
            ge::core::convertTo<GLuint*>(this->ids   )
          );
        }
    };

    template<
      typename SAMPLER_TYPE = GLuint  ,
      typename PNAME_TYPE   = GLenum  ,
      typename PARAMS_TYPE  = GLfloat*>
    class GetSamplerParameterfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sampler")return(void*)&this->sampler;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        SAMPLER_TYPE sampler;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        GetSamplerParameterfv(
            SAMPLER_TYPE const&sampler,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->sampler = sampler;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~GetSamplerParameterfv(){}
        virtual void operator()(){
          glGetSamplerParameterfv(
            ge::core::convertTo<GLuint  >(this->sampler),
            ge::core::convertTo<GLenum  >(this->pname  ),
            ge::core::convertTo<GLfloat*>(this->params )
          );
        }
    };

    template<
      typename PROGRAM_TYPE             = GLuint,
      typename STORAGEBLOCKINDEX_TYPE   = GLuint,
      typename STORAGEBLOCKBINDING_TYPE = GLuint>
    class ShaderStorageBlockBinding:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"            )return(void*)&this->program            ;
          if(name == "storageBlockIndex"  )return(void*)&this->storageBlockIndex  ;
          if(name == "storageBlockBinding")return(void*)&this->storageBlockBinding;
          return NULL;
        }
      public:
        PROGRAM_TYPE             program            ;
        STORAGEBLOCKINDEX_TYPE   storageBlockIndex  ;
        STORAGEBLOCKBINDING_TYPE storageBlockBinding;
        ShaderStorageBlockBinding(
            PROGRAM_TYPE             const&program            ,
            STORAGEBLOCKINDEX_TYPE   const&storageBlockIndex  ,
            STORAGEBLOCKBINDING_TYPE const&storageBlockBinding){
          this->program             = program            ;
          this->storageBlockIndex   = storageBlockIndex  ;
          this->storageBlockBinding = storageBlockBinding;
        }
        virtual~ShaderStorageBlockBinding(){}
        virtual void operator()(){
          glShaderStorageBlockBinding(
            ge::core::convertTo<GLuint>(this->program            ),
            ge::core::convertTo<GLuint>(this->storageBlockIndex  ),
            ge::core::convertTo<GLuint>(this->storageBlockBinding)
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class ProgramUniformMatrix4x2dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix4x2dv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix4x2dv(){}
        virtual void operator()(){
          glProgramUniformMatrix4x2dv(
            ge::core::convertTo<GLuint         >(this->program  ),
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE        = GLuint             ,
      typename UNIFORMCOUNT_TYPE   = GLsizei            ,
      typename UNIFORMNAMES_TYPE   = const GLchar*const*,
      typename UNIFORMINDICES_TYPE = GLuint*            >
    class GetUniformIndices:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"       )return(void*)&this->program       ;
          if(name == "uniformCount"  )return(void*)&this->uniformCount  ;
          if(name == "uniformNames"  )return(void*)&this->uniformNames  ;
          if(name == "uniformIndices")return(void*)&this->uniformIndices;
          return NULL;
        }
      public:
        PROGRAM_TYPE        program       ;
        UNIFORMCOUNT_TYPE   uniformCount  ;
        UNIFORMNAMES_TYPE   uniformNames  ;
        UNIFORMINDICES_TYPE uniformIndices;
        GetUniformIndices(
            PROGRAM_TYPE        const&program       ,
            UNIFORMCOUNT_TYPE   const&uniformCount  ,
            UNIFORMNAMES_TYPE   const&uniformNames  ,
            UNIFORMINDICES_TYPE const&uniformIndices){
          this->program        = program       ;
          this->uniformCount   = uniformCount  ;
          this->uniformNames   = uniformNames  ;
          this->uniformIndices = uniformIndices;
        }
        virtual~GetUniformIndices(){}
        virtual void operator()(){
          glGetUniformIndices(
            ge::core::convertTo<GLuint             >(this->program       ),
            ge::core::convertTo<GLsizei            >(this->uniformCount  ),
            ge::core::convertTo<const GLchar*const*>(this->uniformNames  ),
            ge::core::convertTo<GLuint*            >(this->uniformIndices)
          );
        }
    };

    template<
      typename RET_TYPE    = GLboolean,
      typename SHADER_TYPE = GLuint   >
    class IsShader:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"   )return(void*)&this->ret   ;
          if(name == "shader")return(void*)&this->shader;
          return NULL;
        }
      public:
        RET_TYPE    ret   ;
        SHADER_TYPE shader;
        IsShader(
            RET_TYPE    const&ret   ,
            SHADER_TYPE const&shader){
          this->ret    = ret   ;
          this->shader = shader;
        }
        virtual~IsShader(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsShader(
              ge::core::convertTo<GLuint   >(this->shader))
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLubyte*>
    class VertexAttribI4ubv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribI4ubv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribI4ubv(){}
        virtual void operator()(){
          glVertexAttribI4ubv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLubyte*>(this->v    )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint,
      typename ID_TYPE     = GLuint>
    class BeginQueryIndexed:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          if(name == "id"    )return(void*)&this->id    ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        ID_TYPE     id    ;
        BeginQueryIndexed(
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ,
            ID_TYPE     const&id    ){
          this->target = target;
          this->index  = index ;
          this->id     = id    ;
        }
        virtual~BeginQueryIndexed(){}
        virtual void operator()(){
          glBeginQueryIndexed(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLuint>(this->index ),
            ge::core::convertTo<GLuint>(this->id    )
          );
        }
    };

    template<
      typename PNAME_TYPE  = GLenum      ,
      typename PARAMS_TYPE = const GLint*>
    class PointParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        PointParameteriv(
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->pname  = pname ;
          this->params = params;
        }
        virtual~PointParameteriv(){}
        virtual void operator()(){
          glPointParameteriv(
            ge::core::convertTo<GLenum      >(this->pname ),
            ge::core::convertTo<const GLint*>(this->params)
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class ProgramUniformMatrix2x3fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix2x3fv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix2x3fv(){}
        virtual void operator()(){
          glProgramUniformMatrix2x3fv(
            ge::core::convertTo<GLuint        >(this->program  ),
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE        = GLuint       ,
      typename UNIFORMCOUNT_TYPE   = GLsizei      ,
      typename UNIFORMINDICES_TYPE = const GLuint*,
      typename PNAME_TYPE          = GLenum       ,
      typename PARAMS_TYPE         = GLint*       >
    class GetActiveUniformsiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"       )return(void*)&this->program       ;
          if(name == "uniformCount"  )return(void*)&this->uniformCount  ;
          if(name == "uniformIndices")return(void*)&this->uniformIndices;
          if(name == "pname"         )return(void*)&this->pname         ;
          if(name == "params"        )return(void*)&this->params        ;
          return NULL;
        }
      public:
        PROGRAM_TYPE        program       ;
        UNIFORMCOUNT_TYPE   uniformCount  ;
        UNIFORMINDICES_TYPE uniformIndices;
        PNAME_TYPE          pname         ;
        PARAMS_TYPE         params        ;
        GetActiveUniformsiv(
            PROGRAM_TYPE        const&program       ,
            UNIFORMCOUNT_TYPE   const&uniformCount  ,
            UNIFORMINDICES_TYPE const&uniformIndices,
            PNAME_TYPE          const&pname         ,
            PARAMS_TYPE         const&params        ){
          this->program        = program       ;
          this->uniformCount   = uniformCount  ;
          this->uniformIndices = uniformIndices;
          this->pname          = pname         ;
          this->params         = params        ;
        }
        virtual~GetActiveUniformsiv(){}
        virtual void operator()(){
          glGetActiveUniformsiv(
            ge::core::convertTo<GLuint       >(this->program       ),
            ge::core::convertTo<GLsizei      >(this->uniformCount  ),
            ge::core::convertTo<const GLuint*>(this->uniformIndices),
            ge::core::convertTo<GLenum       >(this->pname         ),
            ge::core::convertTo<GLint*       >(this->params        )
          );
        }
    };

    template<
      typename VAOBJ_TYPE        = GLuint,
      typename ATTRIBINDEX_TYPE  = GLuint,
      typename BINDINGINDEX_TYPE = GLuint>
    class VertexArrayAttribBinding:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj"       )return(void*)&this->vaobj       ;
          if(name == "attribindex" )return(void*)&this->attribindex ;
          if(name == "bindingindex")return(void*)&this->bindingindex;
          return NULL;
        }
      public:
        VAOBJ_TYPE        vaobj       ;
        ATTRIBINDEX_TYPE  attribindex ;
        BINDINGINDEX_TYPE bindingindex;
        VertexArrayAttribBinding(
            VAOBJ_TYPE        const&vaobj       ,
            ATTRIBINDEX_TYPE  const&attribindex ,
            BINDINGINDEX_TYPE const&bindingindex){
          this->vaobj        = vaobj       ;
          this->attribindex  = attribindex ;
          this->bindingindex = bindingindex;
        }
        virtual~VertexArrayAttribBinding(){}
        virtual void operator()(){
          glVertexArrayAttribBinding(
            ge::core::convertTo<GLuint>(this->vaobj       ),
            ge::core::convertTo<GLuint>(this->attribindex ),
            ge::core::convertTo<GLuint>(this->bindingindex)
          );
        }
    };

    template<
      typename TEXTURE_TYPE        = GLuint ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei>
    class TextureStorage1D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture"       )return(void*)&this->texture       ;
          if(name == "levels"        )return(void*)&this->levels        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          return NULL;
        }
      public:
        TEXTURE_TYPE        texture       ;
        LEVELS_TYPE         levels        ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        TextureStorage1D(
            TEXTURE_TYPE        const&texture       ,
            LEVELS_TYPE         const&levels        ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ){
          this->texture        = texture       ;
          this->levels         = levels        ;
          this->internalformat = internalformat;
          this->width          = width         ;
        }
        virtual~TextureStorage1D(){}
        virtual void operator()(){
          glTextureStorage1D(
            ge::core::convertTo<GLuint >(this->texture       ),
            ge::core::convertTo<GLsizei>(this->levels        ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLsizei>(this->width         )
          );
        }
    };

    template<
      typename BARRIERS_TYPE = GLbitfield>
    class MemoryBarrierByRegion:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "barriers")return(void*)&this->barriers;
          return NULL;
        }
      public:
        BARRIERS_TYPE barriers;
        MemoryBarrierByRegion(
            BARRIERS_TYPE const&barriers){
          this->barriers = barriers;
        }
        virtual~MemoryBarrierByRegion(){}
        virtual void operator()(){
          glMemoryBarrierByRegion(
            ge::core::convertTo<GLbitfield>(this->barriers)
          );
        }
    };

    template<
      typename BUF_TYPE  = GLuint,
      typename MODE_TYPE = GLenum>
    class BlendEquationi:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buf" )return(void*)&this->buf ;
          if(name == "mode")return(void*)&this->mode;
          return NULL;
        }
      public:
        BUF_TYPE  buf ;
        MODE_TYPE mode;
        BlendEquationi(
            BUF_TYPE  const&buf ,
            MODE_TYPE const&mode){
          this->buf  = buf ;
          this->mode = mode;
        }
        virtual~BlendEquationi(){}
        virtual void operator()(){
          glBlendEquationi(
            ge::core::convertTo<GLuint>(this->buf ),
            ge::core::convertTo<GLenum>(this->mode)
          );
        }
    };

    template<
      typename RET_TYPE     = GLint        ,
      typename PROGRAM_TYPE = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    class GetAttribLocation:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"    )return(void*)&this->ret    ;
          if(name == "program")return(void*)&this->program;
          if(name == "name"   )return(void*)&this->name   ;
          return NULL;
        }
      public:
        RET_TYPE     ret    ;
        PROGRAM_TYPE program;
        NAME_TYPE    name   ;
        GetAttribLocation(
            RET_TYPE     const&ret    ,
            PROGRAM_TYPE const&program,
            NAME_TYPE    const&name   ){
          this->ret     = ret    ;
          this->program = program;
          this->name    = name   ;
        }
        virtual~GetAttribLocation(){}
        virtual void operator()(){
          ge::core::convertFrom<GLint>(this->ret,glGetAttribLocation(
              ge::core::convertTo<GLuint       >(this->program),
              ge::core::convertTo<const GLchar*>(this->name   ))
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    class VertexAttrib4dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4dv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4dv(){}
        virtual void operator()(){
          glVertexAttrib4dv(
            ge::core::convertTo<GLuint         >(this->index),
            ge::core::convertTo<const GLdouble*>(this->v    )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    class GetTextureParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        GetTextureParameteriv(
            TEXTURE_TYPE const&texture,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->texture = texture;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~GetTextureParameteriv(){}
        virtual void operator()(){
          glGetTextureParameteriv(
            ge::core::convertTo<GLuint>(this->texture),
            ge::core::convertTo<GLenum>(this->pname  ),
            ge::core::convertTo<GLint*>(this->params )
          );
        }
    };

    template<
      typename PROGRAM_TYPE          = GLuint,
      typename PROGRAMINTERFACE_TYPE = GLenum,
      typename PNAME_TYPE            = GLenum,
      typename PARAMS_TYPE           = GLint*>
    class GetProgramInterfaceiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"         )return(void*)&this->program         ;
          if(name == "programInterface")return(void*)&this->programInterface;
          if(name == "pname"           )return(void*)&this->pname           ;
          if(name == "params"          )return(void*)&this->params          ;
          return NULL;
        }
      public:
        PROGRAM_TYPE          program         ;
        PROGRAMINTERFACE_TYPE programInterface;
        PNAME_TYPE            pname           ;
        PARAMS_TYPE           params          ;
        GetProgramInterfaceiv(
            PROGRAM_TYPE          const&program         ,
            PROGRAMINTERFACE_TYPE const&programInterface,
            PNAME_TYPE            const&pname           ,
            PARAMS_TYPE           const&params          ){
          this->program          = program         ;
          this->programInterface = programInterface;
          this->pname            = pname           ;
          this->params           = params          ;
        }
        virtual~GetProgramInterfaceiv(){}
        virtual void operator()(){
          glGetProgramInterfaceiv(
            ge::core::convertTo<GLuint>(this->program         ),
            ge::core::convertTo<GLenum>(this->programInterface),
            ge::core::convertTo<GLenum>(this->pname           ),
            ge::core::convertTo<GLint*>(this->params          )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    class Uniform2dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform2dv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform2dv(){}
        virtual void operator()(){
          glUniform2dv(
            ge::core::convertTo<GLint          >(this->location),
            ge::core::convertTo<GLsizei        >(this->count   ),
            ge::core::convertTo<const GLdouble*>(this->value   )
          );
        }
    };

    template<
      typename RET_TYPE    = void* ,
      typename BUFFER_TYPE = GLuint,
      typename ACCESS_TYPE = GLenum>
    class MapNamedBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"   )return(void*)&this->ret   ;
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "access")return(void*)&this->access;
          return NULL;
        }
      public:
        RET_TYPE    ret   ;
        BUFFER_TYPE buffer;
        ACCESS_TYPE access;
        MapNamedBuffer(
            RET_TYPE    const&ret   ,
            BUFFER_TYPE const&buffer,
            ACCESS_TYPE const&access){
          this->ret    = ret   ;
          this->buffer = buffer;
          this->access = access;
        }
        virtual~MapNamedBuffer(){}
        virtual void operator()(){
          ge::core::convertFrom<void*>(this->ret,glMapNamedBuffer(
              ge::core::convertTo<GLuint>(this->buffer),
              ge::core::convertTo<GLenum>(this->access))
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble,
      typename Z_TYPE     = GLdouble,
      typename W_TYPE     = GLdouble>
    class VertexAttrib4d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          if(name == "w"    )return(void*)&this->w    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        W_TYPE     w    ;
        VertexAttrib4d(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ,
            W_TYPE     const&w    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
          this->w     = w    ;
        }
        virtual~VertexAttrib4d(){}
        virtual void operator()(){
          glVertexAttrib4d(
            ge::core::convertTo<GLuint  >(this->index),
            ge::core::convertTo<GLdouble>(this->x    ),
            ge::core::convertTo<GLdouble>(this->y    ),
            ge::core::convertTo<GLdouble>(this->z    ),
            ge::core::convertTo<GLdouble>(this->w    )
          );
        }
    };

    template<
      typename INDEX_TYPE      = GLuint   ,
      typename TYPE_TYPE       = GLenum   ,
      typename NORMALIZED_TYPE = GLboolean,
      typename VALUE_TYPE      = GLuint   >
    class VertexAttribP3ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"     )return(void*)&this->index     ;
          if(name == "type"      )return(void*)&this->type      ;
          if(name == "normalized")return(void*)&this->normalized;
          if(name == "value"     )return(void*)&this->value     ;
          return NULL;
        }
      public:
        INDEX_TYPE      index     ;
        TYPE_TYPE       type      ;
        NORMALIZED_TYPE normalized;
        VALUE_TYPE      value     ;
        VertexAttribP3ui(
            INDEX_TYPE      const&index     ,
            TYPE_TYPE       const&type      ,
            NORMALIZED_TYPE const&normalized,
            VALUE_TYPE      const&value     ){
          this->index      = index     ;
          this->type       = type      ;
          this->normalized = normalized;
          this->value      = value     ;
        }
        virtual~VertexAttribP3ui(){}
        virtual void operator()(){
          glVertexAttribP3ui(
            ge::core::convertTo<GLuint   >(this->index     ),
            ge::core::convertTo<GLenum   >(this->type      ),
            ge::core::convertTo<GLboolean>(this->normalized),
            ge::core::convertTo<GLuint   >(this->value     )
          );
        }
    };

    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTARGET_TYPE  = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint >
    class FramebufferTexture1D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"    )return(void*)&this->target    ;
          if(name == "attachment")return(void*)&this->attachment;
          if(name == "textarget" )return(void*)&this->textarget ;
          if(name == "texture"   )return(void*)&this->texture   ;
          if(name == "level"     )return(void*)&this->level     ;
          return NULL;
        }
      public:
        TARGET_TYPE     target    ;
        ATTACHMENT_TYPE attachment;
        TEXTARGET_TYPE  textarget ;
        TEXTURE_TYPE    texture   ;
        LEVEL_TYPE      level     ;
        FramebufferTexture1D(
            TARGET_TYPE     const&target    ,
            ATTACHMENT_TYPE const&attachment,
            TEXTARGET_TYPE  const&textarget ,
            TEXTURE_TYPE    const&texture   ,
            LEVEL_TYPE      const&level     ){
          this->target     = target    ;
          this->attachment = attachment;
          this->textarget  = textarget ;
          this->texture    = texture   ;
          this->level      = level     ;
        }
        virtual~FramebufferTexture1D(){}
        virtual void operator()(){
          glFramebufferTexture1D(
            ge::core::convertTo<GLenum>(this->target    ),
            ge::core::convertTo<GLenum>(this->attachment),
            ge::core::convertTo<GLenum>(this->textarget ),
            ge::core::convertTo<GLuint>(this->texture   ),
            ge::core::convertTo<GLint >(this->level     )
          );
        }
    };

    template<
      typename TEXTURE_TYPE        = GLuint    ,
      typename INTERNALFORMAT_TYPE = GLenum    ,
      typename BUFFER_TYPE         = GLuint    ,
      typename OFFSET_TYPE         = GLintptr  ,
      typename SIZE_TYPE           = GLsizeiptr>
    class TextureBufferRange:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture"       )return(void*)&this->texture       ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "buffer"        )return(void*)&this->buffer        ;
          if(name == "offset"        )return(void*)&this->offset        ;
          if(name == "size"          )return(void*)&this->size          ;
          return NULL;
        }
      public:
        TEXTURE_TYPE        texture       ;
        INTERNALFORMAT_TYPE internalformat;
        BUFFER_TYPE         buffer        ;
        OFFSET_TYPE         offset        ;
        SIZE_TYPE           size          ;
        TextureBufferRange(
            TEXTURE_TYPE        const&texture       ,
            INTERNALFORMAT_TYPE const&internalformat,
            BUFFER_TYPE         const&buffer        ,
            OFFSET_TYPE         const&offset        ,
            SIZE_TYPE           const&size          ){
          this->texture        = texture       ;
          this->internalformat = internalformat;
          this->buffer         = buffer        ;
          this->offset         = offset        ;
          this->size           = size          ;
        }
        virtual~TextureBufferRange(){}
        virtual void operator()(){
          glTextureBufferRange(
            ge::core::convertTo<GLuint    >(this->texture       ),
            ge::core::convertTo<GLenum    >(this->internalformat),
            ge::core::convertTo<GLuint    >(this->buffer        ),
            ge::core::convertTo<GLintptr  >(this->offset        ),
            ge::core::convertTo<GLsizeiptr>(this->size          )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint   ,
      typename LOCATION_TYPE = GLint    ,
      typename BUFSIZE_TYPE  = GLsizei  ,
      typename PARAMS_TYPE   = GLdouble*>
    class GetnUniformdv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "bufSize" )return(void*)&this->bufSize ;
          if(name == "params"  )return(void*)&this->params  ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        BUFSIZE_TYPE  bufSize ;
        PARAMS_TYPE   params  ;
        GetnUniformdv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            BUFSIZE_TYPE  const&bufSize ,
            PARAMS_TYPE   const&params  ){
          this->program  = program ;
          this->location = location;
          this->bufSize  = bufSize ;
          this->params   = params  ;
        }
        virtual~GetnUniformdv(){}
        virtual void operator()(){
          glGetnUniformdv(
            ge::core::convertTo<GLuint   >(this->program ),
            ge::core::convertTo<GLint    >(this->location),
            ge::core::convertTo<GLsizei  >(this->bufSize ),
            ge::core::convertTo<GLdouble*>(this->params  )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint,
      typename V2_TYPE       = GLuint>
    class ProgramUniform3ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        ProgramUniform3ui(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
        }
        virtual~ProgramUniform3ui(){}
        virtual void operator()(){
          glProgramUniform3ui(
            ge::core::convertTo<GLuint>(this->program ),
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLuint>(this->v0      ),
            ge::core::convertTo<GLuint>(this->v1      ),
            ge::core::convertTo<GLuint>(this->v2      )
          );
        }
    };

    template<
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = void**>
    class GetPointerv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetPointerv(
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetPointerv(){}
        virtual void operator()(){
          glGetPointerv(
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<void**>(this->params)
          );
        }
    };

    template<
      typename BINDINGINDEX_TYPE = GLuint,
      typename DIVISOR_TYPE      = GLuint>
    class VertexBindingDivisor:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "bindingindex")return(void*)&this->bindingindex;
          if(name == "divisor"     )return(void*)&this->divisor     ;
          return NULL;
        }
      public:
        BINDINGINDEX_TYPE bindingindex;
        DIVISOR_TYPE      divisor     ;
        VertexBindingDivisor(
            BINDINGINDEX_TYPE const&bindingindex,
            DIVISOR_TYPE      const&divisor     ){
          this->bindingindex = bindingindex;
          this->divisor      = divisor     ;
        }
        virtual~VertexBindingDivisor(){}
        virtual void operator()(){
          glVertexBindingDivisor(
            ge::core::convertTo<GLuint>(this->bindingindex),
            ge::core::convertTo<GLuint>(this->divisor     )
          );
        }
    };

    template<
      typename FACTOR_TYPE = GLfloat,
      typename UNITS_TYPE  = GLfloat>
    class PolygonOffset:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "factor")return(void*)&this->factor;
          if(name == "units" )return(void*)&this->units ;
          return NULL;
        }
      public:
        FACTOR_TYPE factor;
        UNITS_TYPE  units ;
        PolygonOffset(
            FACTOR_TYPE const&factor,
            UNITS_TYPE  const&units ){
          this->factor = factor;
          this->units  = units ;
        }
        virtual~PolygonOffset(){}
        virtual void operator()(){
          glPolygonOffset(
            ge::core::convertTo<GLfloat>(this->factor),
            ge::core::convertTo<GLfloat>(this->units )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename PARAMS_TYPE   = GLuint*>
    class GetUniformuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "params"  )return(void*)&this->params  ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        PARAMS_TYPE   params  ;
        GetUniformuiv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            PARAMS_TYPE   const&params  ){
          this->program  = program ;
          this->location = location;
          this->params   = params  ;
        }
        virtual~GetUniformuiv(){}
        virtual void operator()(){
          glGetUniformuiv(
            ge::core::convertTo<GLuint >(this->program ),
            ge::core::convertTo<GLint  >(this->location),
            ge::core::convertTo<GLuint*>(this->params  )
          );
        }
    };

    template<
      typename CAP_TYPE = GLenum>
    class Enable:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "cap")return(void*)&this->cap;
          return NULL;
        }
      public:
        CAP_TYPE cap;
        Enable(
            CAP_TYPE const&cap){
          this->cap = cap;
        }
        virtual~Enable(){}
        virtual void operator()(){
          glEnable(
            ge::core::convertTo<GLenum>(this->cap)
          );
        }
    };

    template<
      typename INDEX_TYPE  = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetVertexAttribIiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index" )return(void*)&this->index ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        INDEX_TYPE  index ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetVertexAttribIiv(
            INDEX_TYPE  const&index ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->index  = index ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetVertexAttribIiv(){}
        virtual void operator()(){
          glGetVertexAttribIiv(
            ge::core::convertTo<GLuint>(this->index ),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    template<
      typename VAOBJ_TYPE        = GLuint,
      typename BINDINGINDEX_TYPE = GLuint,
      typename DIVISOR_TYPE      = GLuint>
    class VertexArrayBindingDivisor:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj"       )return(void*)&this->vaobj       ;
          if(name == "bindingindex")return(void*)&this->bindingindex;
          if(name == "divisor"     )return(void*)&this->divisor     ;
          return NULL;
        }
      public:
        VAOBJ_TYPE        vaobj       ;
        BINDINGINDEX_TYPE bindingindex;
        DIVISOR_TYPE      divisor     ;
        VertexArrayBindingDivisor(
            VAOBJ_TYPE        const&vaobj       ,
            BINDINGINDEX_TYPE const&bindingindex,
            DIVISOR_TYPE      const&divisor     ){
          this->vaobj        = vaobj       ;
          this->bindingindex = bindingindex;
          this->divisor      = divisor     ;
        }
        virtual~VertexArrayBindingDivisor(){}
        virtual void operator()(){
          glVertexArrayBindingDivisor(
            ge::core::convertTo<GLuint>(this->vaobj       ),
            ge::core::convertTo<GLuint>(this->bindingindex),
            ge::core::convertTo<GLuint>(this->divisor     )
          );
        }
    };

    template<
      typename BUF_TYPE = GLenum>
    class DrawBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buf")return(void*)&this->buf;
          return NULL;
        }
      public:
        BUF_TYPE buf;
        DrawBuffer(
            BUF_TYPE const&buf){
          this->buf = buf;
        }
        virtual~DrawBuffer(){}
        virtual void operator()(){
          glDrawBuffer(
            ge::core::convertTo<GLenum>(this->buf)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint>
    class EndQueryIndexed:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        EndQueryIndexed(
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ){
          this->target = target;
          this->index  = index ;
        }
        virtual~EndQueryIndexed(){}
        virtual void operator()(){
          glEndQueryIndexed(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLuint>(this->index )
          );
        }
    };

    template<
      typename BUFFER_TYPE     = GLenum       ,
      typename DRAWBUFFER_TYPE = GLint        ,
      typename VALUE_TYPE      = const GLuint*>
    class ClearBufferuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer"    )return(void*)&this->buffer    ;
          if(name == "drawbuffer")return(void*)&this->drawbuffer;
          if(name == "value"     )return(void*)&this->value     ;
          return NULL;
        }
      public:
        BUFFER_TYPE     buffer    ;
        DRAWBUFFER_TYPE drawbuffer;
        VALUE_TYPE      value     ;
        ClearBufferuiv(
            BUFFER_TYPE     const&buffer    ,
            DRAWBUFFER_TYPE const&drawbuffer,
            VALUE_TYPE      const&value     ){
          this->buffer     = buffer    ;
          this->drawbuffer = drawbuffer;
          this->value      = value     ;
        }
        virtual~ClearBufferuiv(){}
        virtual void operator()(){
          glClearBufferuiv(
            ge::core::convertTo<GLenum       >(this->buffer    ),
            ge::core::convertTo<GLint        >(this->drawbuffer),
            ge::core::convertTo<const GLuint*>(this->value     )
          );
        }
    };

    template<
      typename MODE_TYPE          = GLenum     ,
      typename COUNT_TYPE         = GLsizei    ,
      typename TYPE_TYPE          = GLenum     ,
      typename INDICES_TYPE       = const void*,
      typename INSTANCECOUNT_TYPE = GLsizei    >
    class DrawElementsInstanced:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"         )return(void*)&this->mode         ;
          if(name == "count"        )return(void*)&this->count        ;
          if(name == "type"         )return(void*)&this->type         ;
          if(name == "indices"      )return(void*)&this->indices      ;
          if(name == "instancecount")return(void*)&this->instancecount;
          return NULL;
        }
      public:
        MODE_TYPE          mode         ;
        COUNT_TYPE         count        ;
        TYPE_TYPE          type         ;
        INDICES_TYPE       indices      ;
        INSTANCECOUNT_TYPE instancecount;
        DrawElementsInstanced(
            MODE_TYPE          const&mode         ,
            COUNT_TYPE         const&count        ,
            TYPE_TYPE          const&type         ,
            INDICES_TYPE       const&indices      ,
            INSTANCECOUNT_TYPE const&instancecount){
          this->mode          = mode         ;
          this->count         = count        ;
          this->type          = type         ;
          this->indices       = indices      ;
          this->instancecount = instancecount;
        }
        virtual~DrawElementsInstanced(){}
        virtual void operator()(){
          glDrawElementsInstanced(
            ge::core::convertTo<GLenum     >(this->mode         ),
            ge::core::convertTo<GLsizei    >(this->count        ),
            ge::core::convertTo<GLenum     >(this->type         ),
            ge::core::convertTo<const void*>(this->indices      ),
            ge::core::convertTo<GLsizei    >(this->instancecount)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLint >
    class ProgramUniform1i:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        ProgramUniform1i(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
        }
        virtual~ProgramUniform1i(){}
        virtual void operator()(){
          glProgramUniform1i(
            ge::core::convertTo<GLuint>(this->program ),
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLint >(this->v0      )
          );
        }
    };

    template<
      typename PNAME_TYPE = GLenum,
      typename VALUE_TYPE = GLint >
    class PatchParameteri:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname")return(void*)&this->pname;
          if(name == "value")return(void*)&this->value;
          return NULL;
        }
      public:
        PNAME_TYPE pname;
        VALUE_TYPE value;
        PatchParameteri(
            PNAME_TYPE const&pname,
            VALUE_TYPE const&value){
          this->pname = pname;
          this->value = value;
        }
        virtual~PatchParameteri(){}
        virtual void operator()(){
          glPatchParameteri(
            ge::core::convertTo<GLenum>(this->pname),
            ge::core::convertTo<GLint >(this->value)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename V0_TYPE       = GLdouble>
    class ProgramUniform1d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        ProgramUniform1d(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
        }
        virtual~ProgramUniform1d(){}
        virtual void operator()(){
          glProgramUniform1d(
            ge::core::convertTo<GLuint  >(this->program ),
            ge::core::convertTo<GLint   >(this->location),
            ge::core::convertTo<GLdouble>(this->v0      )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat>
    class ProgramUniform1f:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        ProgramUniform1f(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
        }
        virtual~ProgramUniform1f(){}
        virtual void operator()(){
          glProgramUniform1f(
            ge::core::convertTo<GLuint >(this->program ),
            ge::core::convertTo<GLint  >(this->location),
            ge::core::convertTo<GLfloat>(this->v0      )
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename PNAME_TYPE       = GLenum,
      typename PARAM_TYPE       = GLint*>
    class GetNamedFramebufferParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "pname"      )return(void*)&this->pname      ;
          if(name == "param"      )return(void*)&this->param      ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE framebuffer;
        PNAME_TYPE       pname      ;
        PARAM_TYPE       param      ;
        GetNamedFramebufferParameteriv(
            FRAMEBUFFER_TYPE const&framebuffer,
            PNAME_TYPE       const&pname      ,
            PARAM_TYPE       const&param      ){
          this->framebuffer = framebuffer;
          this->pname       = pname      ;
          this->param       = param      ;
        }
        virtual~GetNamedFramebufferParameteriv(){}
        virtual void operator()(){
          glGetNamedFramebufferParameteriv(
            ge::core::convertTo<GLuint>(this->framebuffer),
            ge::core::convertTo<GLenum>(this->pname      ),
            ge::core::convertTo<GLint*>(this->param      )
          );
        }
    };

    class Flush:
        public ge::core::Command{
      public:
        Flush(
            ){
        }
        virtual~Flush(){}
        virtual void operator()(){
          glFlush(

          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetRenderbufferParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetRenderbufferParameteriv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetRenderbufferParameteriv(){}
        virtual void operator()(){
          glGetRenderbufferParameteriv(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint      ,
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    class ProgramUniform3iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform3iv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform3iv(){}
        virtual void operator()(){
          glProgramUniform3iv(
            ge::core::convertTo<GLuint      >(this->program ),
            ge::core::convertTo<GLint       >(this->location),
            ge::core::convertTo<GLsizei     >(this->count   ),
            ge::core::convertTo<const GLint*>(this->value   )
          );
        }
    };

    template<
      typename RET_TYPE        = GLuint  ,
      typename COUNT_TYPE      = GLuint  ,
      typename BUFSIZE_TYPE    = GLsizei ,
      typename SOURCES_TYPE    = GLenum* ,
      typename TYPES_TYPE      = GLenum* ,
      typename IDS_TYPE        = GLuint* ,
      typename SEVERITIES_TYPE = GLenum* ,
      typename LENGTHS_TYPE    = GLsizei*,
      typename MESSAGELOG_TYPE = GLchar* >
    class GetDebugMessageLog:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"       )return(void*)&this->ret       ;
          if(name == "count"     )return(void*)&this->count     ;
          if(name == "bufSize"   )return(void*)&this->bufSize   ;
          if(name == "sources"   )return(void*)&this->sources   ;
          if(name == "types"     )return(void*)&this->types     ;
          if(name == "ids"       )return(void*)&this->ids       ;
          if(name == "severities")return(void*)&this->severities;
          if(name == "lengths"   )return(void*)&this->lengths   ;
          if(name == "messageLog")return(void*)&this->messageLog;
          return NULL;
        }
      public:
        RET_TYPE        ret       ;
        COUNT_TYPE      count     ;
        BUFSIZE_TYPE    bufSize   ;
        SOURCES_TYPE    sources   ;
        TYPES_TYPE      types     ;
        IDS_TYPE        ids       ;
        SEVERITIES_TYPE severities;
        LENGTHS_TYPE    lengths   ;
        MESSAGELOG_TYPE messageLog;
        GetDebugMessageLog(
            RET_TYPE        const&ret       ,
            COUNT_TYPE      const&count     ,
            BUFSIZE_TYPE    const&bufSize   ,
            SOURCES_TYPE    const&sources   ,
            TYPES_TYPE      const&types     ,
            IDS_TYPE        const&ids       ,
            SEVERITIES_TYPE const&severities,
            LENGTHS_TYPE    const&lengths   ,
            MESSAGELOG_TYPE const&messageLog){
          this->ret        = ret       ;
          this->count      = count     ;
          this->bufSize    = bufSize   ;
          this->sources    = sources   ;
          this->types      = types     ;
          this->ids        = ids       ;
          this->severities = severities;
          this->lengths    = lengths   ;
          this->messageLog = messageLog;
        }
        virtual~GetDebugMessageLog(){}
        virtual void operator()(){
          ge::core::convertFrom<GLuint>(this->ret,glGetDebugMessageLog(
              ge::core::convertTo<GLuint  >(this->count     ),
              ge::core::convertTo<GLsizei >(this->bufSize   ),
              ge::core::convertTo<GLenum* >(this->sources   ),
              ge::core::convertTo<GLenum* >(this->types     ),
              ge::core::convertTo<GLuint* >(this->ids       ),
              ge::core::convertTo<GLenum* >(this->severities),
              ge::core::convertTo<GLsizei*>(this->lengths   ),
              ge::core::convertTo<GLchar* >(this->messageLog))
          );
        }
    };

    template<
      typename RENDERBUFFER_TYPE   = GLuint ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    class NamedRenderbufferStorage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "renderbuffer"  )return(void*)&this->renderbuffer  ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          return NULL;
        }
      public:
        RENDERBUFFER_TYPE   renderbuffer  ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        NamedRenderbufferStorage(
            RENDERBUFFER_TYPE   const&renderbuffer  ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ){
          this->renderbuffer   = renderbuffer  ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->height         = height        ;
        }
        virtual~NamedRenderbufferStorage(){}
        virtual void operator()(){
          glNamedRenderbufferStorage(
            ge::core::convertTo<GLuint >(this->renderbuffer  ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLsizei>(this->width         ),
            ge::core::convertTo<GLsizei>(this->height        )
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename ATTACHMENT_TYPE  = GLenum,
      typename PNAME_TYPE       = GLenum,
      typename PARAMS_TYPE      = GLint*>
    class GetNamedFramebufferAttachmentParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "attachment" )return(void*)&this->attachment ;
          if(name == "pname"      )return(void*)&this->pname      ;
          if(name == "params"     )return(void*)&this->params     ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE framebuffer;
        ATTACHMENT_TYPE  attachment ;
        PNAME_TYPE       pname      ;
        PARAMS_TYPE      params     ;
        GetNamedFramebufferAttachmentParameteriv(
            FRAMEBUFFER_TYPE const&framebuffer,
            ATTACHMENT_TYPE  const&attachment ,
            PNAME_TYPE       const&pname      ,
            PARAMS_TYPE      const&params     ){
          this->framebuffer = framebuffer;
          this->attachment  = attachment ;
          this->pname       = pname      ;
          this->params      = params     ;
        }
        virtual~GetNamedFramebufferAttachmentParameteriv(){}
        virtual void operator()(){
          glGetNamedFramebufferAttachmentParameteriv(
            ge::core::convertTo<GLuint>(this->framebuffer),
            ge::core::convertTo<GLenum>(this->attachment ),
            ge::core::convertTo<GLenum>(this->pname      ),
            ge::core::convertTo<GLint*>(this->params     )
          );
        }
    };

    template<
      typename INDEX_TYPE   = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename POINTER_TYPE = void**>
    class GetVertexAttribPointerv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"  )return(void*)&this->index  ;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "pointer")return(void*)&this->pointer;
          return NULL;
        }
      public:
        INDEX_TYPE   index  ;
        PNAME_TYPE   pname  ;
        POINTER_TYPE pointer;
        GetVertexAttribPointerv(
            INDEX_TYPE   const&index  ,
            PNAME_TYPE   const&pname  ,
            POINTER_TYPE const&pointer){
          this->index   = index  ;
          this->pname   = pname  ;
          this->pointer = pointer;
        }
        virtual~GetVertexAttribPointerv(){}
        virtual void operator()(){
          glGetVertexAttribPointerv(
            ge::core::convertTo<GLuint>(this->index  ),
            ge::core::convertTo<GLenum>(this->pname  ),
            ge::core::convertTo<void**>(this->pointer)
          );
        }
    };

    template<
      typename RET_TYPE       = GLsync    ,
      typename CONDITION_TYPE = GLenum    ,
      typename FLAGS_TYPE     = GLbitfield>
    class FenceSync:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"      )return(void*)&this->ret      ;
          if(name == "condition")return(void*)&this->condition;
          if(name == "flags"    )return(void*)&this->flags    ;
          return NULL;
        }
      public:
        RET_TYPE       ret      ;
        CONDITION_TYPE condition;
        FLAGS_TYPE     flags    ;
        FenceSync(
            RET_TYPE       const&ret      ,
            CONDITION_TYPE const&condition,
            FLAGS_TYPE     const&flags    ){
          this->ret       = ret      ;
          this->condition = condition;
          this->flags     = flags    ;
        }
        virtual~FenceSync(){}
        virtual void operator()(){
          ge::core::convertFrom<GLsync>(this->ret,glFenceSync(
              ge::core::convertTo<GLenum    >(this->condition),
              ge::core::convertTo<GLbitfield>(this->flags    ))
          );
        }
    };

    template<
      typename N_TYPE      = GLsizei      ,
      typename ARRAYS_TYPE = const GLuint*>
    class DeleteVertexArrays:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"     )return(void*)&this->n     ;
          if(name == "arrays")return(void*)&this->arrays;
          return NULL;
        }
      public:
        N_TYPE      n     ;
        ARRAYS_TYPE arrays;
        DeleteVertexArrays(
            N_TYPE      const&n     ,
            ARRAYS_TYPE const&arrays){
          this->n      = n     ;
          this->arrays = arrays;
        }
        virtual~DeleteVertexArrays(){}
        virtual void operator()(){
          glDeleteVertexArrays(
            ge::core::convertTo<GLsizei      >(this->n     ),
            ge::core::convertTo<const GLuint*>(this->arrays)
          );
        }
    };

    template<
      typename MODE_TYPE          = GLenum     ,
      typename COUNT_TYPE         = GLsizei    ,
      typename TYPE_TYPE          = GLenum     ,
      typename INDICES_TYPE       = const void*,
      typename INSTANCECOUNT_TYPE = GLsizei    ,
      typename BASEVERTEX_TYPE    = GLint      ,
      typename BASEINSTANCE_TYPE  = GLuint     >
    class DrawElementsInstancedBaseVertexBaseInstance:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"         )return(void*)&this->mode         ;
          if(name == "count"        )return(void*)&this->count        ;
          if(name == "type"         )return(void*)&this->type         ;
          if(name == "indices"      )return(void*)&this->indices      ;
          if(name == "instancecount")return(void*)&this->instancecount;
          if(name == "basevertex"   )return(void*)&this->basevertex   ;
          if(name == "baseinstance" )return(void*)&this->baseinstance ;
          return NULL;
        }
      public:
        MODE_TYPE          mode         ;
        COUNT_TYPE         count        ;
        TYPE_TYPE          type         ;
        INDICES_TYPE       indices      ;
        INSTANCECOUNT_TYPE instancecount;
        BASEVERTEX_TYPE    basevertex   ;
        BASEINSTANCE_TYPE  baseinstance ;
        DrawElementsInstancedBaseVertexBaseInstance(
            MODE_TYPE          const&mode         ,
            COUNT_TYPE         const&count        ,
            TYPE_TYPE          const&type         ,
            INDICES_TYPE       const&indices      ,
            INSTANCECOUNT_TYPE const&instancecount,
            BASEVERTEX_TYPE    const&basevertex   ,
            BASEINSTANCE_TYPE  const&baseinstance ){
          this->mode          = mode         ;
          this->count         = count        ;
          this->type          = type         ;
          this->indices       = indices      ;
          this->instancecount = instancecount;
          this->basevertex    = basevertex   ;
          this->baseinstance  = baseinstance ;
        }
        virtual~DrawElementsInstancedBaseVertexBaseInstance(){}
        virtual void operator()(){
          glDrawElementsInstancedBaseVertexBaseInstance(
            ge::core::convertTo<GLenum     >(this->mode         ),
            ge::core::convertTo<GLsizei    >(this->count        ),
            ge::core::convertTo<GLenum     >(this->type         ),
            ge::core::convertTo<const void*>(this->indices      ),
            ge::core::convertTo<GLsizei    >(this->instancecount),
            ge::core::convertTo<GLint      >(this->basevertex   ),
            ge::core::convertTo<GLuint     >(this->baseinstance )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    class VertexAttrib3sv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib3sv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib3sv(){}
        virtual void operator()(){
          glVertexAttrib3sv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLshort*>(this->v    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLshort,
      typename Y_TYPE     = GLshort,
      typename Z_TYPE     = GLshort,
      typename W_TYPE     = GLshort>
    class VertexAttrib4s:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          if(name == "w"    )return(void*)&this->w    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        W_TYPE     w    ;
        VertexAttrib4s(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ,
            W_TYPE     const&w    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
          this->w     = w    ;
        }
        virtual~VertexAttrib4s(){}
        virtual void operator()(){
          glVertexAttrib4s(
            ge::core::convertTo<GLuint >(this->index),
            ge::core::convertTo<GLshort>(this->x    ),
            ge::core::convertTo<GLshort>(this->y    ),
            ge::core::convertTo<GLshort>(this->z    ),
            ge::core::convertTo<GLshort>(this->w    )
          );
        }
    };

    template<
      typename PIPELINE_TYPE = GLuint>
    class ValidateProgramPipeline:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pipeline")return(void*)&this->pipeline;
          return NULL;
        }
      public:
        PIPELINE_TYPE pipeline;
        ValidateProgramPipeline(
            PIPELINE_TYPE const&pipeline){
          this->pipeline = pipeline;
        }
        virtual~ValidateProgramPipeline(){}
        virtual void operator()(){
          glValidateProgramPipeline(
            ge::core::convertTo<GLuint>(this->pipeline)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename LEVEL_TYPE  = GLint ,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetTexLevelParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "level" )return(void*)&this->level ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        LEVEL_TYPE  level ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetTexLevelParameteriv(
            TARGET_TYPE const&target,
            LEVEL_TYPE  const&level ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->level  = level ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetTexLevelParameteriv(){}
        virtual void operator()(){
          glGetTexLevelParameteriv(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLint >(this->level ),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    template<
      typename FIRST_TYPE = GLuint      ,
      typename COUNT_TYPE = GLsizei     ,
      typename V_TYPE     = const GLint*>
    class ScissorArrayv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "first")return(void*)&this->first;
          if(name == "count")return(void*)&this->count;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        FIRST_TYPE first;
        COUNT_TYPE count;
        V_TYPE     v    ;
        ScissorArrayv(
            FIRST_TYPE const&first,
            COUNT_TYPE const&count,
            V_TYPE     const&v    ){
          this->first = first;
          this->count = count;
          this->v     = v    ;
        }
        virtual~ScissorArrayv(){}
        virtual void operator()(){
          glScissorArrayv(
            ge::core::convertTo<GLuint      >(this->first),
            ge::core::convertTo<GLsizei     >(this->count),
            ge::core::convertTo<const GLint*>(this->v    )
          );
        }
    };

    template<
      typename TARGET_TYPE               = GLenum   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename DEPTH_TYPE                = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    class TexStorage3DMultisample:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"              )return(void*)&this->target              ;
          if(name == "samples"             )return(void*)&this->samples             ;
          if(name == "internalformat"      )return(void*)&this->internalformat      ;
          if(name == "width"               )return(void*)&this->width               ;
          if(name == "height"              )return(void*)&this->height              ;
          if(name == "depth"               )return(void*)&this->depth               ;
          if(name == "fixedsamplelocations")return(void*)&this->fixedsamplelocations;
          return NULL;
        }
      public:
        TARGET_TYPE               target              ;
        SAMPLES_TYPE              samples             ;
        INTERNALFORMAT_TYPE       internalformat      ;
        WIDTH_TYPE                width               ;
        HEIGHT_TYPE               height              ;
        DEPTH_TYPE                depth               ;
        FIXEDSAMPLELOCATIONS_TYPE fixedsamplelocations;
        TexStorage3DMultisample(
            TARGET_TYPE               const&target              ,
            SAMPLES_TYPE              const&samples             ,
            INTERNALFORMAT_TYPE       const&internalformat      ,
            WIDTH_TYPE                const&width               ,
            HEIGHT_TYPE               const&height              ,
            DEPTH_TYPE                const&depth               ,
            FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
          this->target               = target              ;
          this->samples              = samples             ;
          this->internalformat       = internalformat      ;
          this->width                = width               ;
          this->height               = height              ;
          this->depth                = depth               ;
          this->fixedsamplelocations = fixedsamplelocations;
        }
        virtual~TexStorage3DMultisample(){}
        virtual void operator()(){
          glTexStorage3DMultisample(
            ge::core::convertTo<GLenum   >(this->target              ),
            ge::core::convertTo<GLsizei  >(this->samples             ),
            ge::core::convertTo<GLenum   >(this->internalformat      ),
            ge::core::convertTo<GLsizei  >(this->width               ),
            ge::core::convertTo<GLsizei  >(this->height              ),
            ge::core::convertTo<GLsizei  >(this->depth               ),
            ge::core::convertTo<GLboolean>(this->fixedsamplelocations)
          );
        }
    };

    template<
      typename FACE_TYPE = GLenum,
      typename FUNC_TYPE = GLenum,
      typename REF_TYPE  = GLint ,
      typename MASK_TYPE = GLuint>
    class StencilFuncSeparate:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "face")return(void*)&this->face;
          if(name == "func")return(void*)&this->func;
          if(name == "ref" )return(void*)&this->ref ;
          if(name == "mask")return(void*)&this->mask;
          return NULL;
        }
      public:
        FACE_TYPE face;
        FUNC_TYPE func;
        REF_TYPE  ref ;
        MASK_TYPE mask;
        StencilFuncSeparate(
            FACE_TYPE const&face,
            FUNC_TYPE const&func,
            REF_TYPE  const&ref ,
            MASK_TYPE const&mask){
          this->face = face;
          this->func = func;
          this->ref  = ref ;
          this->mask = mask;
        }
        virtual~StencilFuncSeparate(){}
        virtual void operator()(){
          glStencilFuncSeparate(
            ge::core::convertTo<GLenum>(this->face),
            ge::core::convertTo<GLenum>(this->func),
            ge::core::convertTo<GLint >(this->ref ),
            ge::core::convertTo<GLuint>(this->mask)
          );
        }
    };

    template<
      typename VAOBJ_TYPE = GLuint,
      typename INDEX_TYPE = GLuint>
    class DisableVertexArrayAttrib:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj")return(void*)&this->vaobj;
          if(name == "index")return(void*)&this->index;
          return NULL;
        }
      public:
        VAOBJ_TYPE vaobj;
        INDEX_TYPE index;
        DisableVertexArrayAttrib(
            VAOBJ_TYPE const&vaobj,
            INDEX_TYPE const&index){
          this->vaobj = vaobj;
          this->index = index;
        }
        virtual~DisableVertexArrayAttrib(){}
        virtual void operator()(){
          glDisableVertexArrayAttrib(
            ge::core::convertTo<GLuint>(this->vaobj),
            ge::core::convertTo<GLuint>(this->index)
          );
        }
    };

    template<
      typename COUNT_TYPE    = GLsizei,
      typename SAMPLERS_TYPE = GLuint*>
    class GenSamplers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "samplers")return(void*)&this->samplers;
          return NULL;
        }
      public:
        COUNT_TYPE    count   ;
        SAMPLERS_TYPE samplers;
        GenSamplers(
            COUNT_TYPE    const&count   ,
            SAMPLERS_TYPE const&samplers){
          this->count    = count   ;
          this->samplers = samplers;
        }
        virtual~GenSamplers(){}
        virtual void operator()(){
          glGenSamplers(
            ge::core::convertTo<GLsizei>(this->count   ),
            ge::core::convertTo<GLuint*>(this->samplers)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename CLAMP_TYPE  = GLenum>
    class ClampColor:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "clamp" )return(void*)&this->clamp ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        CLAMP_TYPE  clamp ;
        ClampColor(
            TARGET_TYPE const&target,
            CLAMP_TYPE  const&clamp ){
          this->target = target;
          this->clamp  = clamp ;
        }
        virtual~ClampColor(){}
        virtual void operator()(){
          glClampColor(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLenum>(this->clamp )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    class Uniform4iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform4iv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform4iv(){}
        virtual void operator()(){
          glUniform4iv(
            ge::core::convertTo<GLint       >(this->location),
            ge::core::convertTo<GLsizei     >(this->count   ),
            ge::core::convertTo<const GLint*>(this->value   )
          );
        }
    };

    template<
      typename S_TYPE = GLint>
    class ClearStencil:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "s")return(void*)&this->s;
          return NULL;
        }
      public:
        S_TYPE s;
        ClearStencil(
            S_TYPE const&s){
          this->s = s;
        }
        virtual~ClearStencil(){}
        virtual void operator()(){
          glClearStencil(
            ge::core::convertTo<GLint>(this->s)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    class VertexAttribI4uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribI4uiv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribI4uiv(){}
        virtual void operator()(){
          glVertexAttribI4uiv(
            ge::core::convertTo<GLuint       >(this->index),
            ge::core::convertTo<const GLuint*>(this->v    )
          );
        }
    };

    template<
      typename RENDERBUFFER_TYPE = GLuint,
      typename PNAME_TYPE        = GLenum,
      typename PARAMS_TYPE       = GLint*>
    class GetNamedRenderbufferParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "renderbuffer")return(void*)&this->renderbuffer;
          if(name == "pname"       )return(void*)&this->pname       ;
          if(name == "params"      )return(void*)&this->params      ;
          return NULL;
        }
      public:
        RENDERBUFFER_TYPE renderbuffer;
        PNAME_TYPE        pname       ;
        PARAMS_TYPE       params      ;
        GetNamedRenderbufferParameteriv(
            RENDERBUFFER_TYPE const&renderbuffer,
            PNAME_TYPE        const&pname       ,
            PARAMS_TYPE       const&params      ){
          this->renderbuffer = renderbuffer;
          this->pname        = pname       ;
          this->params       = params      ;
        }
        virtual~GetNamedRenderbufferParameteriv(){}
        virtual void operator()(){
          glGetNamedRenderbufferParameteriv(
            ge::core::convertTo<GLuint>(this->renderbuffer),
            ge::core::convertTo<GLenum>(this->pname       ),
            ge::core::convertTo<GLint*>(this->params      )
          );
        }
    };

    template<
      typename MODE_TYPE          = GLenum ,
      typename ID_TYPE            = GLuint ,
      typename INSTANCECOUNT_TYPE = GLsizei>
    class DrawTransformFeedbackInstanced:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"         )return(void*)&this->mode         ;
          if(name == "id"           )return(void*)&this->id           ;
          if(name == "instancecount")return(void*)&this->instancecount;
          return NULL;
        }
      public:
        MODE_TYPE          mode         ;
        ID_TYPE            id           ;
        INSTANCECOUNT_TYPE instancecount;
        DrawTransformFeedbackInstanced(
            MODE_TYPE          const&mode         ,
            ID_TYPE            const&id           ,
            INSTANCECOUNT_TYPE const&instancecount){
          this->mode          = mode         ;
          this->id            = id           ;
          this->instancecount = instancecount;
        }
        virtual~DrawTransformFeedbackInstanced(){}
        virtual void operator()(){
          glDrawTransformFeedbackInstanced(
            ge::core::convertTo<GLenum >(this->mode         ),
            ge::core::convertTo<GLuint >(this->id           ),
            ge::core::convertTo<GLsizei>(this->instancecount)
          );
        }
    };

    template<
      typename N_TYPE        = GLsizei,
      typename TEXTURES_TYPE = GLuint*>
    class GenTextures:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"       )return(void*)&this->n       ;
          if(name == "textures")return(void*)&this->textures;
          return NULL;
        }
      public:
        N_TYPE        n       ;
        TEXTURES_TYPE textures;
        GenTextures(
            N_TYPE        const&n       ,
            TEXTURES_TYPE const&textures){
          this->n        = n       ;
          this->textures = textures;
        }
        virtual~GenTextures(){}
        virtual void operator()(){
          glGenTextures(
            ge::core::convertTo<GLsizei>(this->n       ),
            ge::core::convertTo<GLuint*>(this->textures)
          );
        }
    };

    template<
      typename TEXTURE_TYPE              = GLuint   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    class TextureStorage2DMultisample:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture"             )return(void*)&this->texture             ;
          if(name == "samples"             )return(void*)&this->samples             ;
          if(name == "internalformat"      )return(void*)&this->internalformat      ;
          if(name == "width"               )return(void*)&this->width               ;
          if(name == "height"              )return(void*)&this->height              ;
          if(name == "fixedsamplelocations")return(void*)&this->fixedsamplelocations;
          return NULL;
        }
      public:
        TEXTURE_TYPE              texture             ;
        SAMPLES_TYPE              samples             ;
        INTERNALFORMAT_TYPE       internalformat      ;
        WIDTH_TYPE                width               ;
        HEIGHT_TYPE               height              ;
        FIXEDSAMPLELOCATIONS_TYPE fixedsamplelocations;
        TextureStorage2DMultisample(
            TEXTURE_TYPE              const&texture             ,
            SAMPLES_TYPE              const&samples             ,
            INTERNALFORMAT_TYPE       const&internalformat      ,
            WIDTH_TYPE                const&width               ,
            HEIGHT_TYPE               const&height              ,
            FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
          this->texture              = texture             ;
          this->samples              = samples             ;
          this->internalformat       = internalformat      ;
          this->width                = width               ;
          this->height               = height              ;
          this->fixedsamplelocations = fixedsamplelocations;
        }
        virtual~TextureStorage2DMultisample(){}
        virtual void operator()(){
          glTextureStorage2DMultisample(
            ge::core::convertTo<GLuint   >(this->texture             ),
            ge::core::convertTo<GLsizei  >(this->samples             ),
            ge::core::convertTo<GLenum   >(this->internalformat      ),
            ge::core::convertTo<GLsizei  >(this->width               ),
            ge::core::convertTo<GLsizei  >(this->height              ),
            ge::core::convertTo<GLboolean>(this->fixedsamplelocations)
          );
        }
    };

    template<
      typename MODE_TYPE = GLenum,
      typename ID_TYPE   = GLuint>
    class DrawTransformFeedback:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode")return(void*)&this->mode;
          if(name == "id"  )return(void*)&this->id  ;
          return NULL;
        }
      public:
        MODE_TYPE mode;
        ID_TYPE   id  ;
        DrawTransformFeedback(
            MODE_TYPE const&mode,
            ID_TYPE   const&id  ){
          this->mode = mode;
          this->id   = id  ;
        }
        virtual~DrawTransformFeedback(){}
        virtual void operator()(){
          glDrawTransformFeedback(
            ge::core::convertTo<GLenum>(this->mode),
            ge::core::convertTo<GLuint>(this->id  )
          );
        }
    };

    template<
      typename PNAME_TYPE = GLenum   ,
      typename DATA_TYPE  = GLdouble*>
    class GetDoublev:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname")return(void*)&this->pname;
          if(name == "data" )return(void*)&this->data ;
          return NULL;
        }
      public:
        PNAME_TYPE pname;
        DATA_TYPE  data ;
        GetDoublev(
            PNAME_TYPE const&pname,
            DATA_TYPE  const&data ){
          this->pname = pname;
          this->data  = data ;
        }
        virtual~GetDoublev(){}
        virtual void operator()(){
          glGetDoublev(
            ge::core::convertTo<GLenum   >(this->pname),
            ge::core::convertTo<GLdouble*>(this->data )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum ,
      typename PNAME_TYPE  = GLenum ,
      typename PARAMS_TYPE = GLuint*>
    class GetTexParameterIuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetTexParameterIuiv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetTexParameterIuiv(){}
        virtual void operator()(){
          glGetTexParameterIuiv(
            ge::core::convertTo<GLenum >(this->target),
            ge::core::convertTo<GLenum >(this->pname ),
            ge::core::convertTo<GLuint*>(this->params)
          );
        }
    };

    template<
      typename XFB_TYPE   = GLuint,
      typename PNAME_TYPE = GLenum,
      typename INDEX_TYPE = GLuint,
      typename PARAM_TYPE = GLint*>
    class GetTransformFeedbacki_v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "xfb"  )return(void*)&this->xfb  ;
          if(name == "pname")return(void*)&this->pname;
          if(name == "index")return(void*)&this->index;
          if(name == "param")return(void*)&this->param;
          return NULL;
        }
      public:
        XFB_TYPE   xfb  ;
        PNAME_TYPE pname;
        INDEX_TYPE index;
        PARAM_TYPE param;
        GetTransformFeedbacki_v(
            XFB_TYPE   const&xfb  ,
            PNAME_TYPE const&pname,
            INDEX_TYPE const&index,
            PARAM_TYPE const&param){
          this->xfb   = xfb  ;
          this->pname = pname;
          this->index = index;
          this->param = param;
        }
        virtual~GetTransformFeedbacki_v(){}
        virtual void operator()(){
          glGetTransformFeedbacki_v(
            ge::core::convertTo<GLuint>(this->xfb  ),
            ge::core::convertTo<GLenum>(this->pname),
            ge::core::convertTo<GLuint>(this->index),
            ge::core::convertTo<GLint*>(this->param)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLbyte*>
    class VertexAttrib4Nbv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4Nbv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4Nbv(){}
        virtual void operator()(){
          glVertexAttrib4Nbv(
            ge::core::convertTo<GLuint       >(this->index),
            ge::core::convertTo<const GLbyte*>(this->v    )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei>
    class TexStorage1D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "levels"        )return(void*)&this->levels        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        LEVELS_TYPE         levels        ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        TexStorage1D(
            TARGET_TYPE         const&target        ,
            LEVELS_TYPE         const&levels        ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ){
          this->target         = target        ;
          this->levels         = levels        ;
          this->internalformat = internalformat;
          this->width          = width         ;
        }
        virtual~TexStorage1D(){}
        virtual void operator()(){
          glTexStorage1D(
            ge::core::convertTo<GLenum >(this->target        ),
            ge::core::convertTo<GLsizei>(this->levels        ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLsizei>(this->width         )
          );
        }
    };

    template<
      typename RET_TYPE  = GLboolean,
      typename SYNC_TYPE = GLsync   >
    class IsSync:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret" )return(void*)&this->ret ;
          if(name == "sync")return(void*)&this->sync;
          return NULL;
        }
      public:
        RET_TYPE  ret ;
        SYNC_TYPE sync;
        IsSync(
            RET_TYPE  const&ret ,
            SYNC_TYPE const&sync){
          this->ret  = ret ;
          this->sync = sync;
        }
        virtual~IsSync(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsSync(
              ge::core::convertTo<GLsync   >(this->sync))
          );
        }
    };

    template<
      typename RET_TYPE = GLuint>
    class CreateProgram:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret")return(void*)&this->ret;
          return NULL;
        }
      public:
        RET_TYPE ret;
        CreateProgram(
            RET_TYPE const&ret){
          this->ret = ret;
        }
        virtual~CreateProgram(){}
        virtual void operator()(){
          ge::core::convertFrom<GLuint>(this->ret,glCreateProgram()
          );
        }
    };

    template<
      typename PROGRAM_TYPE           = GLuint  ,
      typename UNIFORMBLOCKINDEX_TYPE = GLuint  ,
      typename BUFSIZE_TYPE           = GLsizei ,
      typename LENGTH_TYPE            = GLsizei*,
      typename UNIFORMBLOCKNAME_TYPE  = GLchar* >
    class GetActiveUniformBlockName:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"          )return(void*)&this->program          ;
          if(name == "uniformBlockIndex")return(void*)&this->uniformBlockIndex;
          if(name == "bufSize"          )return(void*)&this->bufSize          ;
          if(name == "length"           )return(void*)&this->length           ;
          if(name == "uniformBlockName" )return(void*)&this->uniformBlockName ;
          return NULL;
        }
      public:
        PROGRAM_TYPE           program          ;
        UNIFORMBLOCKINDEX_TYPE uniformBlockIndex;
        BUFSIZE_TYPE           bufSize          ;
        LENGTH_TYPE            length           ;
        UNIFORMBLOCKNAME_TYPE  uniformBlockName ;
        GetActiveUniformBlockName(
            PROGRAM_TYPE           const&program          ,
            UNIFORMBLOCKINDEX_TYPE const&uniformBlockIndex,
            BUFSIZE_TYPE           const&bufSize          ,
            LENGTH_TYPE            const&length           ,
            UNIFORMBLOCKNAME_TYPE  const&uniformBlockName ){
          this->program           = program          ;
          this->uniformBlockIndex = uniformBlockIndex;
          this->bufSize           = bufSize          ;
          this->length            = length           ;
          this->uniformBlockName  = uniformBlockName ;
        }
        virtual~GetActiveUniformBlockName(){}
        virtual void operator()(){
          glGetActiveUniformBlockName(
            ge::core::convertTo<GLuint  >(this->program          ),
            ge::core::convertTo<GLuint  >(this->uniformBlockIndex),
            ge::core::convertTo<GLsizei >(this->bufSize          ),
            ge::core::convertTo<GLsizei*>(this->length           ),
            ge::core::convertTo<GLchar* >(this->uniformBlockName )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint,
      typename V0_TYPE       = GLint,
      typename V1_TYPE       = GLint>
    class Uniform2i:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        Uniform2i(
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ){
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
        }
        virtual~Uniform2i(){}
        virtual void operator()(){
          glUniform2i(
            ge::core::convertTo<GLint>(this->location),
            ge::core::convertTo<GLint>(this->v0      ),
            ge::core::convertTo<GLint>(this->v1      )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat>
    class Uniform2f:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        Uniform2f(
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ){
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
        }
        virtual~Uniform2f(){}
        virtual void operator()(){
          glUniform2f(
            ge::core::convertTo<GLint  >(this->location),
            ge::core::convertTo<GLfloat>(this->v0      ),
            ge::core::convertTo<GLfloat>(this->v1      )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint   ,
      typename X_TYPE        = GLdouble,
      typename Y_TYPE        = GLdouble>
    class Uniform2d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "x"       )return(void*)&this->x       ;
          if(name == "y"       )return(void*)&this->y       ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        X_TYPE        x       ;
        Y_TYPE        y       ;
        Uniform2d(
            LOCATION_TYPE const&location,
            X_TYPE        const&x       ,
            Y_TYPE        const&y       ){
          this->location = location;
          this->x        = x       ;
          this->y        = y       ;
        }
        virtual~Uniform2d(){}
        virtual void operator()(){
          glUniform2d(
            ge::core::convertTo<GLint   >(this->location),
            ge::core::convertTo<GLdouble>(this->x       ),
            ge::core::convertTo<GLdouble>(this->y       )
          );
        }
    };

    template<
      typename SHADER_TYPE = GLuint             ,
      typename COUNT_TYPE  = GLsizei            ,
      typename STRING_TYPE = const GLchar*const*,
      typename LENGTH_TYPE = const GLint*       >
    class ShaderSource:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "shader")return(void*)&this->shader;
          if(name == "count" )return(void*)&this->count ;
          if(name == "string")return(void*)&this->string;
          if(name == "length")return(void*)&this->length;
          return NULL;
        }
      public:
        SHADER_TYPE shader;
        COUNT_TYPE  count ;
        STRING_TYPE string;
        LENGTH_TYPE length;
        ShaderSource(
            SHADER_TYPE const&shader,
            COUNT_TYPE  const&count ,
            STRING_TYPE const&string,
            LENGTH_TYPE const&length){
          this->shader = shader;
          this->count  = count ;
          this->string = string;
          this->length = length;
        }
        virtual~ShaderSource(){}
        virtual void operator()(){
          glShaderSource(
            ge::core::convertTo<GLuint             >(this->shader),
            ge::core::convertTo<GLsizei            >(this->count ),
            ge::core::convertTo<const GLchar*const*>(this->string),
            ge::core::convertTo<const GLint*       >(this->length)
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    class GetProgramiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        GetProgramiv(
            PROGRAM_TYPE const&program,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->program = program;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~GetProgramiv(){}
        virtual void operator()(){
          glGetProgramiv(
            ge::core::convertTo<GLuint>(this->program),
            ge::core::convertTo<GLenum>(this->pname  ),
            ge::core::convertTo<GLint*>(this->params )
          );
        }
    };

    template<
      typename INDEX_TYPE      = GLuint     ,
      typename SIZE_TYPE       = GLint      ,
      typename TYPE_TYPE       = GLenum     ,
      typename NORMALIZED_TYPE = GLboolean  ,
      typename STRIDE_TYPE     = GLsizei    ,
      typename POINTER_TYPE    = const void*>
    class VertexAttribPointer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"     )return(void*)&this->index     ;
          if(name == "size"      )return(void*)&this->size      ;
          if(name == "type"      )return(void*)&this->type      ;
          if(name == "normalized")return(void*)&this->normalized;
          if(name == "stride"    )return(void*)&this->stride    ;
          if(name == "pointer"   )return(void*)&this->pointer   ;
          return NULL;
        }
      public:
        INDEX_TYPE      index     ;
        SIZE_TYPE       size      ;
        TYPE_TYPE       type      ;
        NORMALIZED_TYPE normalized;
        STRIDE_TYPE     stride    ;
        POINTER_TYPE    pointer   ;
        VertexAttribPointer(
            INDEX_TYPE      const&index     ,
            SIZE_TYPE       const&size      ,
            TYPE_TYPE       const&type      ,
            NORMALIZED_TYPE const&normalized,
            STRIDE_TYPE     const&stride    ,
            POINTER_TYPE    const&pointer   ){
          this->index      = index     ;
          this->size       = size      ;
          this->type       = type      ;
          this->normalized = normalized;
          this->stride     = stride    ;
          this->pointer    = pointer   ;
        }
        virtual~VertexAttribPointer(){}
        virtual void operator()(){
          glVertexAttribPointer(
            ge::core::convertTo<GLuint     >(this->index     ),
            ge::core::convertTo<GLint      >(this->size      ),
            ge::core::convertTo<GLenum     >(this->type      ),
            ge::core::convertTo<GLboolean  >(this->normalized),
            ge::core::convertTo<GLsizei    >(this->stride    ),
            ge::core::convertTo<const void*>(this->pointer   )
          );
        }
    };

    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint ,
      typename LAYER_TYPE      = GLint >
    class FramebufferTextureLayer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"    )return(void*)&this->target    ;
          if(name == "attachment")return(void*)&this->attachment;
          if(name == "texture"   )return(void*)&this->texture   ;
          if(name == "level"     )return(void*)&this->level     ;
          if(name == "layer"     )return(void*)&this->layer     ;
          return NULL;
        }
      public:
        TARGET_TYPE     target    ;
        ATTACHMENT_TYPE attachment;
        TEXTURE_TYPE    texture   ;
        LEVEL_TYPE      level     ;
        LAYER_TYPE      layer     ;
        FramebufferTextureLayer(
            TARGET_TYPE     const&target    ,
            ATTACHMENT_TYPE const&attachment,
            TEXTURE_TYPE    const&texture   ,
            LEVEL_TYPE      const&level     ,
            LAYER_TYPE      const&layer     ){
          this->target     = target    ;
          this->attachment = attachment;
          this->texture    = texture   ;
          this->level      = level     ;
          this->layer      = layer     ;
        }
        virtual~FramebufferTextureLayer(){}
        virtual void operator()(){
          glFramebufferTextureLayer(
            ge::core::convertTo<GLenum>(this->target    ),
            ge::core::convertTo<GLenum>(this->attachment),
            ge::core::convertTo<GLuint>(this->texture   ),
            ge::core::convertTo<GLint >(this->level     ),
            ge::core::convertTo<GLint >(this->layer     )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint        ,
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    class ProgramUniform4fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform4fv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform4fv(){}
        virtual void operator()(){
          glProgramUniform4fv(
            ge::core::convertTo<GLuint        >(this->program ),
            ge::core::convertTo<GLint         >(this->location),
            ge::core::convertTo<GLsizei       >(this->count   ),
            ge::core::convertTo<const GLfloat*>(this->value   )
          );
        }
    };

    template<
      typename PTR_TYPE     = const void*,
      typename BUFSIZE_TYPE = GLsizei    ,
      typename LENGTH_TYPE  = GLsizei*   ,
      typename LABEL_TYPE   = GLchar*    >
    class GetObjectPtrLabel:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ptr"    )return(void*)&this->ptr    ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "length" )return(void*)&this->length ;
          if(name == "label"  )return(void*)&this->label  ;
          return NULL;
        }
      public:
        PTR_TYPE     ptr    ;
        BUFSIZE_TYPE bufSize;
        LENGTH_TYPE  length ;
        LABEL_TYPE   label  ;
        GetObjectPtrLabel(
            PTR_TYPE     const&ptr    ,
            BUFSIZE_TYPE const&bufSize,
            LENGTH_TYPE  const&length ,
            LABEL_TYPE   const&label  ){
          this->ptr     = ptr    ;
          this->bufSize = bufSize;
          this->length  = length ;
          this->label   = label  ;
        }
        virtual~GetObjectPtrLabel(){}
        virtual void operator()(){
          glGetObjectPtrLabel(
            ge::core::convertTo<const void*>(this->ptr    ),
            ge::core::convertTo<GLsizei    >(this->bufSize),
            ge::core::convertTo<GLsizei*   >(this->length ),
            ge::core::convertTo<GLchar*    >(this->label  )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAM_TYPE   = GLint >
    class TextureParameteri:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "param"  )return(void*)&this->param  ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        PNAME_TYPE   pname  ;
        PARAM_TYPE   param  ;
        TextureParameteri(
            TEXTURE_TYPE const&texture,
            PNAME_TYPE   const&pname  ,
            PARAM_TYPE   const&param  ){
          this->texture = texture;
          this->pname   = pname  ;
          this->param   = param  ;
        }
        virtual~TextureParameteri(){}
        virtual void operator()(){
          glTextureParameteri(
            ge::core::convertTo<GLuint>(this->texture),
            ge::core::convertTo<GLenum>(this->pname  ),
            ge::core::convertTo<GLint >(this->param  )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename PNAME_TYPE   = GLenum ,
      typename PARAM_TYPE   = GLfloat>
    class TextureParameterf:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "param"  )return(void*)&this->param  ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        PNAME_TYPE   pname  ;
        PARAM_TYPE   param  ;
        TextureParameterf(
            TEXTURE_TYPE const&texture,
            PNAME_TYPE   const&pname  ,
            PARAM_TYPE   const&param  ){
          this->texture = texture;
          this->pname   = pname  ;
          this->param   = param  ;
        }
        virtual~TextureParameterf(){}
        virtual void operator()(){
          glTextureParameterf(
            ge::core::convertTo<GLuint >(this->texture),
            ge::core::convertTo<GLenum >(this->pname  ),
            ge::core::convertTo<GLfloat>(this->param  )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr>
    class FlushMappedBufferRange:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "offset")return(void*)&this->offset;
          if(name == "length")return(void*)&this->length;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        OFFSET_TYPE offset;
        LENGTH_TYPE length;
        FlushMappedBufferRange(
            TARGET_TYPE const&target,
            OFFSET_TYPE const&offset,
            LENGTH_TYPE const&length){
          this->target = target;
          this->offset = offset;
          this->length = length;
        }
        virtual~FlushMappedBufferRange(){}
        virtual void operator()(){
          glFlushMappedBufferRange(
            ge::core::convertTo<GLenum    >(this->target),
            ge::core::convertTo<GLintptr  >(this->offset),
            ge::core::convertTo<GLsizeiptr>(this->length)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint        ,
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    class ProgramUniform2fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform2fv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform2fv(){}
        virtual void operator()(){
          glProgramUniform2fv(
            ge::core::convertTo<GLuint        >(this->program ),
            ge::core::convertTo<GLint         >(this->location),
            ge::core::convertTo<GLsizei       >(this->count   ),
            ge::core::convertTo<const GLfloat*>(this->value   )
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class UniformMatrix2x3dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix2x3dv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix2x3dv(){}
        virtual void operator()(){
          glUniformMatrix2x3dv(
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble,
      typename Z_TYPE     = GLdouble>
    class VertexAttribL3d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        VertexAttribL3d(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
        }
        virtual~VertexAttribL3d(){}
        virtual void operator()(){
          glVertexAttribL3d(
            ge::core::convertTo<GLuint  >(this->index),
            ge::core::convertTo<GLdouble>(this->x    ),
            ge::core::convertTo<GLdouble>(this->y    ),
            ge::core::convertTo<GLdouble>(this->z    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class ProgramUniformMatrix2x4dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix2x4dv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix2x4dv(){}
        virtual void operator()(){
          glProgramUniformMatrix2x4dv(
            ge::core::convertTo<GLuint         >(this->program  ),
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint   ,
      typename X_TYPE        = GLdouble>
    class Uniform1d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "x"       )return(void*)&this->x       ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        X_TYPE        x       ;
        Uniform1d(
            LOCATION_TYPE const&location,
            X_TYPE        const&x       ){
          this->location = location;
          this->x        = x       ;
        }
        virtual~Uniform1d(){}
        virtual void operator()(){
          glUniform1d(
            ge::core::convertTo<GLint   >(this->location),
            ge::core::convertTo<GLdouble>(this->x       )
          );
        }
    };

    template<
      typename N_TYPE   = GLsizei,
      typename IDS_TYPE = GLuint*>
    class GenQueries:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"  )return(void*)&this->n  ;
          if(name == "ids")return(void*)&this->ids;
          return NULL;
        }
      public:
        N_TYPE   n  ;
        IDS_TYPE ids;
        GenQueries(
            N_TYPE   const&n  ,
            IDS_TYPE const&ids){
          this->n   = n  ;
          this->ids = ids;
        }
        virtual~GenQueries(){}
        virtual void operator()(){
          glGenQueries(
            ge::core::convertTo<GLsizei>(this->n  ),
            ge::core::convertTo<GLuint*>(this->ids)
          );
        }
    };

    template<
      typename INDEX_TYPE      = GLuint   ,
      typename TYPE_TYPE       = GLenum   ,
      typename NORMALIZED_TYPE = GLboolean,
      typename VALUE_TYPE      = GLuint   >
    class VertexAttribP1ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"     )return(void*)&this->index     ;
          if(name == "type"      )return(void*)&this->type      ;
          if(name == "normalized")return(void*)&this->normalized;
          if(name == "value"     )return(void*)&this->value     ;
          return NULL;
        }
      public:
        INDEX_TYPE      index     ;
        TYPE_TYPE       type      ;
        NORMALIZED_TYPE normalized;
        VALUE_TYPE      value     ;
        VertexAttribP1ui(
            INDEX_TYPE      const&index     ,
            TYPE_TYPE       const&type      ,
            NORMALIZED_TYPE const&normalized,
            VALUE_TYPE      const&value     ){
          this->index      = index     ;
          this->type       = type      ;
          this->normalized = normalized;
          this->value      = value     ;
        }
        virtual~VertexAttribP1ui(){}
        virtual void operator()(){
          glVertexAttribP1ui(
            ge::core::convertTo<GLuint   >(this->index     ),
            ge::core::convertTo<GLenum   >(this->type      ),
            ge::core::convertTo<GLboolean>(this->normalized),
            ge::core::convertTo<GLuint   >(this->value     )
          );
        }
    };

    template<
      typename TARGET_TYPE  = GLenum     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename ZOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename DEPTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    class TexSubImage3D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target" )return(void*)&this->target ;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "yoffset")return(void*)&this->yoffset;
          if(name == "zoffset")return(void*)&this->zoffset;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          if(name == "depth"  )return(void*)&this->depth  ;
          if(name == "format" )return(void*)&this->format ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "pixels" )return(void*)&this->pixels ;
          return NULL;
        }
      public:
        TARGET_TYPE  target ;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        YOFFSET_TYPE yoffset;
        ZOFFSET_TYPE zoffset;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        DEPTH_TYPE   depth  ;
        FORMAT_TYPE  format ;
        TYPE_TYPE    type   ;
        PIXELS_TYPE  pixels ;
        TexSubImage3D(
            TARGET_TYPE  const&target ,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            YOFFSET_TYPE const&yoffset,
            ZOFFSET_TYPE const&zoffset,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ,
            DEPTH_TYPE   const&depth  ,
            FORMAT_TYPE  const&format ,
            TYPE_TYPE    const&type   ,
            PIXELS_TYPE  const&pixels ){
          this->target  = target ;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->yoffset = yoffset;
          this->zoffset = zoffset;
          this->width   = width  ;
          this->height  = height ;
          this->depth   = depth  ;
          this->format  = format ;
          this->type    = type   ;
          this->pixels  = pixels ;
        }
        virtual~TexSubImage3D(){}
        virtual void operator()(){
          glTexSubImage3D(
            ge::core::convertTo<GLenum     >(this->target ),
            ge::core::convertTo<GLint      >(this->level  ),
            ge::core::convertTo<GLint      >(this->xoffset),
            ge::core::convertTo<GLint      >(this->yoffset),
            ge::core::convertTo<GLint      >(this->zoffset),
            ge::core::convertTo<GLsizei    >(this->width  ),
            ge::core::convertTo<GLsizei    >(this->height ),
            ge::core::convertTo<GLsizei    >(this->depth  ),
            ge::core::convertTo<GLenum     >(this->format ),
            ge::core::convertTo<GLenum     >(this->type   ),
            ge::core::convertTo<const void*>(this->pixels )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum  ,
      typename INDEX_TYPE  = GLuint  ,
      typename DATA_TYPE   = GLint64*>
    class GetInteger64i_v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          if(name == "data"  )return(void*)&this->data  ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        DATA_TYPE   data  ;
        GetInteger64i_v(
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ,
            DATA_TYPE   const&data  ){
          this->target = target;
          this->index  = index ;
          this->data   = data  ;
        }
        virtual~GetInteger64i_v(){}
        virtual void operator()(){
          glGetInteger64i_v(
            ge::core::convertTo<GLenum  >(this->target),
            ge::core::convertTo<GLuint  >(this->index ),
            ge::core::convertTo<GLint64*>(this->data  )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint>
    class ProgramUniform1ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        ProgramUniform1ui(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
        }
        virtual~ProgramUniform1ui(){}
        virtual void operator()(){
          glProgramUniform1ui(
            ge::core::convertTo<GLuint>(this->program ),
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLuint>(this->v0      )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVEL_TYPE          = GLint  ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename X_TYPE              = GLint  ,
      typename Y_TYPE              = GLint  ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei,
      typename BORDER_TYPE         = GLint  >
    class CopyTexImage2D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "level"         )return(void*)&this->level         ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "x"             )return(void*)&this->x             ;
          if(name == "y"             )return(void*)&this->y             ;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          if(name == "border"        )return(void*)&this->border        ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        LEVEL_TYPE          level         ;
        INTERNALFORMAT_TYPE internalformat;
        X_TYPE              x             ;
        Y_TYPE              y             ;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        BORDER_TYPE         border        ;
        CopyTexImage2D(
            TARGET_TYPE         const&target        ,
            LEVEL_TYPE          const&level         ,
            INTERNALFORMAT_TYPE const&internalformat,
            X_TYPE              const&x             ,
            Y_TYPE              const&y             ,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ,
            BORDER_TYPE         const&border        ){
          this->target         = target        ;
          this->level          = level         ;
          this->internalformat = internalformat;
          this->x              = x             ;
          this->y              = y             ;
          this->width          = width         ;
          this->height         = height        ;
          this->border         = border        ;
        }
        virtual~CopyTexImage2D(){}
        virtual void operator()(){
          glCopyTexImage2D(
            ge::core::convertTo<GLenum >(this->target        ),
            ge::core::convertTo<GLint  >(this->level         ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLint  >(this->x             ),
            ge::core::convertTo<GLint  >(this->y             ),
            ge::core::convertTo<GLsizei>(this->width         ),
            ge::core::convertTo<GLsizei>(this->height        ),
            ge::core::convertTo<GLint  >(this->border        )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei,
      typename DEPTH_TYPE   = GLsizei,
      typename FORMAT_TYPE  = GLenum ,
      typename TYPE_TYPE    = GLenum ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    class GetTextureSubImage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "yoffset")return(void*)&this->yoffset;
          if(name == "zoffset")return(void*)&this->zoffset;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          if(name == "depth"  )return(void*)&this->depth  ;
          if(name == "format" )return(void*)&this->format ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "pixels" )return(void*)&this->pixels ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        YOFFSET_TYPE yoffset;
        ZOFFSET_TYPE zoffset;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        DEPTH_TYPE   depth  ;
        FORMAT_TYPE  format ;
        TYPE_TYPE    type   ;
        BUFSIZE_TYPE bufSize;
        PIXELS_TYPE  pixels ;
        GetTextureSubImage(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            YOFFSET_TYPE const&yoffset,
            ZOFFSET_TYPE const&zoffset,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ,
            DEPTH_TYPE   const&depth  ,
            FORMAT_TYPE  const&format ,
            TYPE_TYPE    const&type   ,
            BUFSIZE_TYPE const&bufSize,
            PIXELS_TYPE  const&pixels ){
          this->texture = texture;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->yoffset = yoffset;
          this->zoffset = zoffset;
          this->width   = width  ;
          this->height  = height ;
          this->depth   = depth  ;
          this->format  = format ;
          this->type    = type   ;
          this->bufSize = bufSize;
          this->pixels  = pixels ;
        }
        virtual~GetTextureSubImage(){}
        virtual void operator()(){
          glGetTextureSubImage(
            ge::core::convertTo<GLuint >(this->texture),
            ge::core::convertTo<GLint  >(this->level  ),
            ge::core::convertTo<GLint  >(this->xoffset),
            ge::core::convertTo<GLint  >(this->yoffset),
            ge::core::convertTo<GLint  >(this->zoffset),
            ge::core::convertTo<GLsizei>(this->width  ),
            ge::core::convertTo<GLsizei>(this->height ),
            ge::core::convertTo<GLsizei>(this->depth  ),
            ge::core::convertTo<GLenum >(this->format ),
            ge::core::convertTo<GLenum >(this->type   ),
            ge::core::convertTo<GLsizei>(this->bufSize),
            ge::core::convertTo<void*  >(this->pixels )
          );
        }
    };

    template<
      typename SRCX0_TYPE  = GLint     ,
      typename SRCY0_TYPE  = GLint     ,
      typename SRCX1_TYPE  = GLint     ,
      typename SRCY1_TYPE  = GLint     ,
      typename DSTX0_TYPE  = GLint     ,
      typename DSTY0_TYPE  = GLint     ,
      typename DSTX1_TYPE  = GLint     ,
      typename DSTY1_TYPE  = GLint     ,
      typename MASK_TYPE   = GLbitfield,
      typename FILTER_TYPE = GLenum    >
    class BlitFramebuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "srcX0" )return(void*)&this->srcX0 ;
          if(name == "srcY0" )return(void*)&this->srcY0 ;
          if(name == "srcX1" )return(void*)&this->srcX1 ;
          if(name == "srcY1" )return(void*)&this->srcY1 ;
          if(name == "dstX0" )return(void*)&this->dstX0 ;
          if(name == "dstY0" )return(void*)&this->dstY0 ;
          if(name == "dstX1" )return(void*)&this->dstX1 ;
          if(name == "dstY1" )return(void*)&this->dstY1 ;
          if(name == "mask"  )return(void*)&this->mask  ;
          if(name == "filter")return(void*)&this->filter;
          return NULL;
        }
      public:
        SRCX0_TYPE  srcX0 ;
        SRCY0_TYPE  srcY0 ;
        SRCX1_TYPE  srcX1 ;
        SRCY1_TYPE  srcY1 ;
        DSTX0_TYPE  dstX0 ;
        DSTY0_TYPE  dstY0 ;
        DSTX1_TYPE  dstX1 ;
        DSTY1_TYPE  dstY1 ;
        MASK_TYPE   mask  ;
        FILTER_TYPE filter;
        BlitFramebuffer(
            SRCX0_TYPE  const&srcX0 ,
            SRCY0_TYPE  const&srcY0 ,
            SRCX1_TYPE  const&srcX1 ,
            SRCY1_TYPE  const&srcY1 ,
            DSTX0_TYPE  const&dstX0 ,
            DSTY0_TYPE  const&dstY0 ,
            DSTX1_TYPE  const&dstX1 ,
            DSTY1_TYPE  const&dstY1 ,
            MASK_TYPE   const&mask  ,
            FILTER_TYPE const&filter){
          this->srcX0  = srcX0 ;
          this->srcY0  = srcY0 ;
          this->srcX1  = srcX1 ;
          this->srcY1  = srcY1 ;
          this->dstX0  = dstX0 ;
          this->dstY0  = dstY0 ;
          this->dstX1  = dstX1 ;
          this->dstY1  = dstY1 ;
          this->mask   = mask  ;
          this->filter = filter;
        }
        virtual~BlitFramebuffer(){}
        virtual void operator()(){
          glBlitFramebuffer(
            ge::core::convertTo<GLint     >(this->srcX0 ),
            ge::core::convertTo<GLint     >(this->srcY0 ),
            ge::core::convertTo<GLint     >(this->srcX1 ),
            ge::core::convertTo<GLint     >(this->srcY1 ),
            ge::core::convertTo<GLint     >(this->dstX0 ),
            ge::core::convertTo<GLint     >(this->dstY0 ),
            ge::core::convertTo<GLint     >(this->dstX1 ),
            ge::core::convertTo<GLint     >(this->dstY1 ),
            ge::core::convertTo<GLbitfield>(this->mask  ),
            ge::core::convertTo<GLenum    >(this->filter)
          );
        }
    };

    template<
      typename RET_TYPE    = GLboolean,
      typename TARGET_TYPE = GLenum   ,
      typename INDEX_TYPE  = GLuint   >
    class IsEnabledi:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"   )return(void*)&this->ret   ;
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          return NULL;
        }
      public:
        RET_TYPE    ret   ;
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        IsEnabledi(
            RET_TYPE    const&ret   ,
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ){
          this->ret    = ret   ;
          this->target = target;
          this->index  = index ;
        }
        virtual~IsEnabledi(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsEnabledi(
              ge::core::convertTo<GLenum   >(this->target),
              ge::core::convertTo<GLuint   >(this->index ))
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint  ,
      typename PNAME_TYPE   = GLenum  ,
      typename PARAMS_TYPE  = GLfloat*>
    class GetTextureParameterfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        GetTextureParameterfv(
            TEXTURE_TYPE const&texture,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->texture = texture;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~GetTextureParameterfv(){}
        virtual void operator()(){
          glGetTextureParameterfv(
            ge::core::convertTo<GLuint  >(this->texture),
            ge::core::convertTo<GLenum  >(this->pname  ),
            ge::core::convertTo<GLfloat*>(this->params )
          );
        }
    };

    template<
      typename PROGRAM_TYPE     = GLuint       ,
      typename COLORNUMBER_TYPE = GLuint       ,
      typename INDEX_TYPE       = GLuint       ,
      typename NAME_TYPE        = const GLchar*>
    class BindFragDataLocationIndexed:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"    )return(void*)&this->program    ;
          if(name == "colorNumber")return(void*)&this->colorNumber;
          if(name == "index"      )return(void*)&this->index      ;
          if(name == "name"       )return(void*)&this->name       ;
          return NULL;
        }
      public:
        PROGRAM_TYPE     program    ;
        COLORNUMBER_TYPE colorNumber;
        INDEX_TYPE       index      ;
        NAME_TYPE        name       ;
        BindFragDataLocationIndexed(
            PROGRAM_TYPE     const&program    ,
            COLORNUMBER_TYPE const&colorNumber,
            INDEX_TYPE       const&index      ,
            NAME_TYPE        const&name       ){
          this->program     = program    ;
          this->colorNumber = colorNumber;
          this->index       = index      ;
          this->name        = name       ;
        }
        virtual~BindFragDataLocationIndexed(){}
        virtual void operator()(){
          glBindFragDataLocationIndexed(
            ge::core::convertTo<GLuint       >(this->program    ),
            ge::core::convertTo<GLuint       >(this->colorNumber),
            ge::core::convertTo<GLuint       >(this->index      ),
            ge::core::convertTo<const GLchar*>(this->name       )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    class Uniform2iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform2iv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform2iv(){}
        virtual void operator()(){
          glUniform2iv(
            ge::core::convertTo<GLint       >(this->location),
            ge::core::convertTo<GLsizei     >(this->count   ),
            ge::core::convertTo<const GLint*>(this->value   )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    class VertexAttrib1fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib1fv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib1fv(){}
        virtual void operator()(){
          glVertexAttrib1fv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLfloat*>(this->v    )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    class Uniform4uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform4uiv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform4uiv(){}
        virtual void operator()(){
          glUniform4uiv(
            ge::core::convertTo<GLint        >(this->location),
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->value   )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename ZOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename DEPTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    class TextureSubImage3D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "yoffset")return(void*)&this->yoffset;
          if(name == "zoffset")return(void*)&this->zoffset;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          if(name == "depth"  )return(void*)&this->depth  ;
          if(name == "format" )return(void*)&this->format ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "pixels" )return(void*)&this->pixels ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        YOFFSET_TYPE yoffset;
        ZOFFSET_TYPE zoffset;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        DEPTH_TYPE   depth  ;
        FORMAT_TYPE  format ;
        TYPE_TYPE    type   ;
        PIXELS_TYPE  pixels ;
        TextureSubImage3D(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            YOFFSET_TYPE const&yoffset,
            ZOFFSET_TYPE const&zoffset,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ,
            DEPTH_TYPE   const&depth  ,
            FORMAT_TYPE  const&format ,
            TYPE_TYPE    const&type   ,
            PIXELS_TYPE  const&pixels ){
          this->texture = texture;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->yoffset = yoffset;
          this->zoffset = zoffset;
          this->width   = width  ;
          this->height  = height ;
          this->depth   = depth  ;
          this->format  = format ;
          this->type    = type   ;
          this->pixels  = pixels ;
        }
        virtual~TextureSubImage3D(){}
        virtual void operator()(){
          glTextureSubImage3D(
            ge::core::convertTo<GLuint     >(this->texture),
            ge::core::convertTo<GLint      >(this->level  ),
            ge::core::convertTo<GLint      >(this->xoffset),
            ge::core::convertTo<GLint      >(this->yoffset),
            ge::core::convertTo<GLint      >(this->zoffset),
            ge::core::convertTo<GLsizei    >(this->width  ),
            ge::core::convertTo<GLsizei    >(this->height ),
            ge::core::convertTo<GLsizei    >(this->depth  ),
            ge::core::convertTo<GLenum     >(this->format ),
            ge::core::convertTo<GLenum     >(this->type   ),
            ge::core::convertTo<const void*>(this->pixels )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    class VertexAttribL1dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribL1dv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribL1dv(){}
        virtual void operator()(){
          glVertexAttribL1dv(
            ge::core::convertTo<GLuint         >(this->index),
            ge::core::convertTo<const GLdouble*>(this->v    )
          );
        }
    };

    template<
      typename SHADER_TYPE = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetShaderiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "shader")return(void*)&this->shader;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        SHADER_TYPE shader;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetShaderiv(
            SHADER_TYPE const&shader,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->shader = shader;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetShaderiv(){}
        virtual void operator()(){
          glGetShaderiv(
            ge::core::convertTo<GLuint>(this->shader),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class ProgramUniformMatrix3fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix3fv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix3fv(){}
        virtual void operator()(){
          glProgramUniformMatrix3fv(
            ge::core::convertTo<GLuint        >(this->program  ),
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename PTR_TYPE    = const void*  ,
      typename LENGTH_TYPE = GLsizei      ,
      typename LABEL_TYPE  = const GLchar*>
    class ObjectPtrLabel:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ptr"   )return(void*)&this->ptr   ;
          if(name == "length")return(void*)&this->length;
          if(name == "label" )return(void*)&this->label ;
          return NULL;
        }
      public:
        PTR_TYPE    ptr   ;
        LENGTH_TYPE length;
        LABEL_TYPE  label ;
        ObjectPtrLabel(
            PTR_TYPE    const&ptr   ,
            LENGTH_TYPE const&length,
            LABEL_TYPE  const&label ){
          this->ptr    = ptr   ;
          this->length = length;
          this->label  = label ;
        }
        virtual~ObjectPtrLabel(){}
        virtual void operator()(){
          glObjectPtrLabel(
            ge::core::convertTo<const void*  >(this->ptr   ),
            ge::core::convertTo<GLsizei      >(this->length),
            ge::core::convertTo<const GLchar*>(this->label )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum       ,
      typename NUMATTACHMENTS_TYPE = GLsizei      ,
      typename ATTACHMENTS_TYPE    = const GLenum*>
    class InvalidateFramebuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "numAttachments")return(void*)&this->numAttachments;
          if(name == "attachments"   )return(void*)&this->attachments   ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        NUMATTACHMENTS_TYPE numAttachments;
        ATTACHMENTS_TYPE    attachments   ;
        InvalidateFramebuffer(
            TARGET_TYPE         const&target        ,
            NUMATTACHMENTS_TYPE const&numAttachments,
            ATTACHMENTS_TYPE    const&attachments   ){
          this->target         = target        ;
          this->numAttachments = numAttachments;
          this->attachments    = attachments   ;
        }
        virtual~InvalidateFramebuffer(){}
        virtual void operator()(){
          glInvalidateFramebuffer(
            ge::core::convertTo<GLenum       >(this->target        ),
            ge::core::convertTo<GLsizei      >(this->numAttachments),
            ge::core::convertTo<const GLenum*>(this->attachments   )
          );
        }
    };

    template<
      typename FIRST_TYPE    = GLuint       ,
      typename COUNT_TYPE    = GLsizei      ,
      typename TEXTURES_TYPE = const GLuint*>
    class BindTextures:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "first"   )return(void*)&this->first   ;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "textures")return(void*)&this->textures;
          return NULL;
        }
      public:
        FIRST_TYPE    first   ;
        COUNT_TYPE    count   ;
        TEXTURES_TYPE textures;
        BindTextures(
            FIRST_TYPE    const&first   ,
            COUNT_TYPE    const&count   ,
            TEXTURES_TYPE const&textures){
          this->first    = first   ;
          this->count    = count   ;
          this->textures = textures;
        }
        virtual~BindTextures(){}
        virtual void operator()(){
          glBindTextures(
            ge::core::convertTo<GLuint       >(this->first   ),
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->textures)
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint       ,
      typename COLOR_TYPE   = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    class BindFragDataLocation:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          if(name == "color"  )return(void*)&this->color  ;
          if(name == "name"   )return(void*)&this->name   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        COLOR_TYPE   color  ;
        NAME_TYPE    name   ;
        BindFragDataLocation(
            PROGRAM_TYPE const&program,
            COLOR_TYPE   const&color  ,
            NAME_TYPE    const&name   ){
          this->program = program;
          this->color   = color  ;
          this->name    = name   ;
        }
        virtual~BindFragDataLocation(){}
        virtual void operator()(){
          glBindFragDataLocation(
            ge::core::convertTo<GLuint       >(this->program),
            ge::core::convertTo<GLuint       >(this->color  ),
            ge::core::convertTo<const GLchar*>(this->name   )
          );
        }
    };

    template<
      typename BUFFER_TYPE = GLuint     ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*,
      typename FLAGS_TYPE  = GLbitfield >
    class NamedBufferStorage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "size"  )return(void*)&this->size  ;
          if(name == "data"  )return(void*)&this->data  ;
          if(name == "flags" )return(void*)&this->flags ;
          return NULL;
        }
      public:
        BUFFER_TYPE buffer;
        SIZE_TYPE   size  ;
        DATA_TYPE   data  ;
        FLAGS_TYPE  flags ;
        NamedBufferStorage(
            BUFFER_TYPE const&buffer,
            SIZE_TYPE   const&size  ,
            DATA_TYPE   const&data  ,
            FLAGS_TYPE  const&flags ){
          this->buffer = buffer;
          this->size   = size  ;
          this->data   = data  ;
          this->flags  = flags ;
        }
        virtual~NamedBufferStorage(){}
        virtual void operator()(){
          glNamedBufferStorage(
            ge::core::convertTo<GLuint     >(this->buffer),
            ge::core::convertTo<GLsizeiptr >(this->size  ),
            ge::core::convertTo<const void*>(this->data  ),
            ge::core::convertTo<GLbitfield >(this->flags )
          );
        }
    };

    template<
      typename TARGET_TYPE   = GLenum ,
      typename N_TYPE        = GLsizei,
      typename TEXTURES_TYPE = GLuint*>
    class CreateTextures:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"  )return(void*)&this->target  ;
          if(name == "n"       )return(void*)&this->n       ;
          if(name == "textures")return(void*)&this->textures;
          return NULL;
        }
      public:
        TARGET_TYPE   target  ;
        N_TYPE        n       ;
        TEXTURES_TYPE textures;
        CreateTextures(
            TARGET_TYPE   const&target  ,
            N_TYPE        const&n       ,
            TEXTURES_TYPE const&textures){
          this->target   = target  ;
          this->n        = n       ;
          this->textures = textures;
        }
        virtual~CreateTextures(){}
        virtual void operator()(){
          glCreateTextures(
            ge::core::convertTo<GLenum >(this->target  ),
            ge::core::convertTo<GLsizei>(this->n       ),
            ge::core::convertTo<GLuint*>(this->textures)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename PARAMS_TYPE   = GLfloat*>
    class GetUniformfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "params"  )return(void*)&this->params  ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        PARAMS_TYPE   params  ;
        GetUniformfv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            PARAMS_TYPE   const&params  ){
          this->program  = program ;
          this->location = location;
          this->params   = params  ;
        }
        virtual~GetUniformfv(){}
        virtual void operator()(){
          glGetUniformfv(
            ge::core::convertTo<GLuint  >(this->program ),
            ge::core::convertTo<GLint   >(this->location),
            ge::core::convertTo<GLfloat*>(this->params  )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    class Uniform1dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform1dv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform1dv(){}
        virtual void operator()(){
          glUniform1dv(
            ge::core::convertTo<GLint          >(this->location),
            ge::core::convertTo<GLsizei        >(this->count   ),
            ge::core::convertTo<const GLdouble*>(this->value   )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename HEIGHT_TYPE         = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename IMAGESIZE_TYPE      = GLsizei    ,
      typename DATA_TYPE           = const void*>
    class CompressedTexImage2D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "level"         )return(void*)&this->level         ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          if(name == "border"        )return(void*)&this->border        ;
          if(name == "imageSize"     )return(void*)&this->imageSize     ;
          if(name == "data"          )return(void*)&this->data          ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        LEVEL_TYPE          level         ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        BORDER_TYPE         border        ;
        IMAGESIZE_TYPE      imageSize     ;
        DATA_TYPE           data          ;
        CompressedTexImage2D(
            TARGET_TYPE         const&target        ,
            LEVEL_TYPE          const&level         ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ,
            BORDER_TYPE         const&border        ,
            IMAGESIZE_TYPE      const&imageSize     ,
            DATA_TYPE           const&data          ){
          this->target         = target        ;
          this->level          = level         ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->height         = height        ;
          this->border         = border        ;
          this->imageSize      = imageSize     ;
          this->data           = data          ;
        }
        virtual~CompressedTexImage2D(){}
        virtual void operator()(){
          glCompressedTexImage2D(
            ge::core::convertTo<GLenum     >(this->target        ),
            ge::core::convertTo<GLint      >(this->level         ),
            ge::core::convertTo<GLenum     >(this->internalformat),
            ge::core::convertTo<GLsizei    >(this->width         ),
            ge::core::convertTo<GLsizei    >(this->height        ),
            ge::core::convertTo<GLint      >(this->border        ),
            ge::core::convertTo<GLsizei    >(this->imageSize     ),
            ge::core::convertTo<const void*>(this->data          )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    class Uniform4dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform4dv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform4dv(){}
        virtual void operator()(){
          glUniform4dv(
            ge::core::convertTo<GLint          >(this->location),
            ge::core::convertTo<GLsizei        >(this->count   ),
            ge::core::convertTo<const GLdouble*>(this->value   )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint         ,
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    class ProgramUniform3dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform3dv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform3dv(){}
        virtual void operator()(){
          glProgramUniform3dv(
            ge::core::convertTo<GLuint         >(this->program ),
            ge::core::convertTo<GLint          >(this->location),
            ge::core::convertTo<GLsizei        >(this->count   ),
            ge::core::convertTo<const GLdouble*>(this->value   )
          );
        }
    };

    template<
      typename CAP_TYPE = GLenum>
    class Disable:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "cap")return(void*)&this->cap;
          return NULL;
        }
      public:
        CAP_TYPE cap;
        Disable(
            CAP_TYPE const&cap){
          this->cap = cap;
        }
        virtual~Disable(){}
        virtual void operator()(){
          glDisable(
            ge::core::convertTo<GLenum>(this->cap)
          );
        }
    };

    template<
      typename BUFFER_TYPE = GLuint>
    class InvalidateBufferData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer")return(void*)&this->buffer;
          return NULL;
        }
      public:
        BUFFER_TYPE buffer;
        InvalidateBufferData(
            BUFFER_TYPE const&buffer){
          this->buffer = buffer;
        }
        virtual~InvalidateBufferData(){}
        virtual void operator()(){
          glInvalidateBufferData(
            ge::core::convertTo<GLuint>(this->buffer)
          );
        }
    };

    template<
      typename TEXTURE_TYPE   = GLuint     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    class CompressedTextureSubImage1D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture"  )return(void*)&this->texture  ;
          if(name == "level"    )return(void*)&this->level    ;
          if(name == "xoffset"  )return(void*)&this->xoffset  ;
          if(name == "width"    )return(void*)&this->width    ;
          if(name == "format"   )return(void*)&this->format   ;
          if(name == "imageSize")return(void*)&this->imageSize;
          if(name == "data"     )return(void*)&this->data     ;
          return NULL;
        }
      public:
        TEXTURE_TYPE   texture  ;
        LEVEL_TYPE     level    ;
        XOFFSET_TYPE   xoffset  ;
        WIDTH_TYPE     width    ;
        FORMAT_TYPE    format   ;
        IMAGESIZE_TYPE imageSize;
        DATA_TYPE      data     ;
        CompressedTextureSubImage1D(
            TEXTURE_TYPE   const&texture  ,
            LEVEL_TYPE     const&level    ,
            XOFFSET_TYPE   const&xoffset  ,
            WIDTH_TYPE     const&width    ,
            FORMAT_TYPE    const&format   ,
            IMAGESIZE_TYPE const&imageSize,
            DATA_TYPE      const&data     ){
          this->texture   = texture  ;
          this->level     = level    ;
          this->xoffset   = xoffset  ;
          this->width     = width    ;
          this->format    = format   ;
          this->imageSize = imageSize;
          this->data      = data     ;
        }
        virtual~CompressedTextureSubImage1D(){}
        virtual void operator()(){
          glCompressedTextureSubImage1D(
            ge::core::convertTo<GLuint     >(this->texture  ),
            ge::core::convertTo<GLint      >(this->level    ),
            ge::core::convertTo<GLint      >(this->xoffset  ),
            ge::core::convertTo<GLsizei    >(this->width    ),
            ge::core::convertTo<GLenum     >(this->format   ),
            ge::core::convertTo<GLsizei    >(this->imageSize),
            ge::core::convertTo<const void*>(this->data     )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    class Uniform3fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform3fv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform3fv(){}
        virtual void operator()(){
          glUniform3fv(
            ge::core::convertTo<GLint         >(this->location),
            ge::core::convertTo<GLsizei       >(this->count   ),
            ge::core::convertTo<const GLfloat*>(this->value   )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename ID_TYPE     = GLuint>
    class BeginQuery:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "id"    )return(void*)&this->id    ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        ID_TYPE     id    ;
        BeginQuery(
            TARGET_TYPE const&target,
            ID_TYPE     const&id    ){
          this->target = target;
          this->id     = id    ;
        }
        virtual~BeginQuery(){}
        virtual void operator()(){
          glBeginQuery(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLuint>(this->id    )
          );
        }
    };

    template<
      typename NEAR__TYPE = GLdouble,
      typename FAR__TYPE  = GLdouble>
    class DepthRange:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "near_")return(void*)&this->near_;
          if(name == "far_" )return(void*)&this->far_ ;
          return NULL;
        }
      public:
        NEAR__TYPE near_;
        FAR__TYPE  far_ ;
        DepthRange(
            NEAR__TYPE const&near_,
            FAR__TYPE  const&far_ ){
          this->near_ = near_;
          this->far_  = far_ ;
        }
        virtual~DepthRange(){}
        virtual void operator()(){
          glDepthRange(
            ge::core::convertTo<GLdouble>(this->near_),
            ge::core::convertTo<GLdouble>(this->far_ )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum       ,
      typename NUMATTACHMENTS_TYPE = GLsizei      ,
      typename ATTACHMENTS_TYPE    = const GLenum*,
      typename X_TYPE              = GLint        ,
      typename Y_TYPE              = GLint        ,
      typename WIDTH_TYPE          = GLsizei      ,
      typename HEIGHT_TYPE         = GLsizei      >
    class InvalidateSubFramebuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "numAttachments")return(void*)&this->numAttachments;
          if(name == "attachments"   )return(void*)&this->attachments   ;
          if(name == "x"             )return(void*)&this->x             ;
          if(name == "y"             )return(void*)&this->y             ;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        NUMATTACHMENTS_TYPE numAttachments;
        ATTACHMENTS_TYPE    attachments   ;
        X_TYPE              x             ;
        Y_TYPE              y             ;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        InvalidateSubFramebuffer(
            TARGET_TYPE         const&target        ,
            NUMATTACHMENTS_TYPE const&numAttachments,
            ATTACHMENTS_TYPE    const&attachments   ,
            X_TYPE              const&x             ,
            Y_TYPE              const&y             ,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ){
          this->target         = target        ;
          this->numAttachments = numAttachments;
          this->attachments    = attachments   ;
          this->x              = x             ;
          this->y              = y             ;
          this->width          = width         ;
          this->height         = height        ;
        }
        virtual~InvalidateSubFramebuffer(){}
        virtual void operator()(){
          glInvalidateSubFramebuffer(
            ge::core::convertTo<GLenum       >(this->target        ),
            ge::core::convertTo<GLsizei      >(this->numAttachments),
            ge::core::convertTo<const GLenum*>(this->attachments   ),
            ge::core::convertTo<GLint        >(this->x             ),
            ge::core::convertTo<GLint        >(this->y             ),
            ge::core::convertTo<GLsizei      >(this->width         ),
            ge::core::convertTo<GLsizei      >(this->height        )
          );
        }
    };

    template<
      typename RET_TYPE    = void* ,
      typename TARGET_TYPE = GLenum,
      typename ACCESS_TYPE = GLenum>
    class MapBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"   )return(void*)&this->ret   ;
          if(name == "target")return(void*)&this->target;
          if(name == "access")return(void*)&this->access;
          return NULL;
        }
      public:
        RET_TYPE    ret   ;
        TARGET_TYPE target;
        ACCESS_TYPE access;
        MapBuffer(
            RET_TYPE    const&ret   ,
            TARGET_TYPE const&target,
            ACCESS_TYPE const&access){
          this->ret    = ret   ;
          this->target = target;
          this->access = access;
        }
        virtual~MapBuffer(){}
        virtual void operator()(){
          ge::core::convertFrom<void*>(this->ret,glMapBuffer(
              ge::core::convertTo<GLenum>(this->target),
              ge::core::convertTo<GLenum>(this->access))
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename DATA_TYPE    = const void*>
    class ClearTexImage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "format" )return(void*)&this->format ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "data"   )return(void*)&this->data   ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        FORMAT_TYPE  format ;
        TYPE_TYPE    type   ;
        DATA_TYPE    data   ;
        ClearTexImage(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            FORMAT_TYPE  const&format ,
            TYPE_TYPE    const&type   ,
            DATA_TYPE    const&data   ){
          this->texture = texture;
          this->level   = level  ;
          this->format  = format ;
          this->type    = type   ;
          this->data    = data   ;
        }
        virtual~ClearTexImage(){}
        virtual void operator()(){
          glClearTexImage(
            ge::core::convertTo<GLuint     >(this->texture),
            ge::core::convertTo<GLint      >(this->level  ),
            ge::core::convertTo<GLenum     >(this->format ),
            ge::core::convertTo<GLenum     >(this->type   ),
            ge::core::convertTo<const void*>(this->data   )
          );
        }
    };

    template<
      typename ATTRIBINDEX_TYPE    = GLuint,
      typename SIZE_TYPE           = GLint ,
      typename TYPE_TYPE           = GLenum,
      typename RELATIVEOFFSET_TYPE = GLuint>
    class VertexAttribLFormat:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "attribindex"   )return(void*)&this->attribindex   ;
          if(name == "size"          )return(void*)&this->size          ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "relativeoffset")return(void*)&this->relativeoffset;
          return NULL;
        }
      public:
        ATTRIBINDEX_TYPE    attribindex   ;
        SIZE_TYPE           size          ;
        TYPE_TYPE           type          ;
        RELATIVEOFFSET_TYPE relativeoffset;
        VertexAttribLFormat(
            ATTRIBINDEX_TYPE    const&attribindex   ,
            SIZE_TYPE           const&size          ,
            TYPE_TYPE           const&type          ,
            RELATIVEOFFSET_TYPE const&relativeoffset){
          this->attribindex    = attribindex   ;
          this->size           = size          ;
          this->type           = type          ;
          this->relativeoffset = relativeoffset;
        }
        virtual~VertexAttribLFormat(){}
        virtual void operator()(){
          glVertexAttribLFormat(
            ge::core::convertTo<GLuint>(this->attribindex   ),
            ge::core::convertTo<GLint >(this->size          ),
            ge::core::convertTo<GLenum>(this->type          ),
            ge::core::convertTo<GLuint>(this->relativeoffset)
          );
        }
    };

    template<
      typename SOURCE_TYPE  = GLenum       ,
      typename ID_TYPE      = GLuint       ,
      typename LENGTH_TYPE  = GLsizei      ,
      typename MESSAGE_TYPE = const GLchar*>
    class PushDebugGroup:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "source" )return(void*)&this->source ;
          if(name == "id"     )return(void*)&this->id     ;
          if(name == "length" )return(void*)&this->length ;
          if(name == "message")return(void*)&this->message;
          return NULL;
        }
      public:
        SOURCE_TYPE  source ;
        ID_TYPE      id     ;
        LENGTH_TYPE  length ;
        MESSAGE_TYPE message;
        PushDebugGroup(
            SOURCE_TYPE  const&source ,
            ID_TYPE      const&id     ,
            LENGTH_TYPE  const&length ,
            MESSAGE_TYPE const&message){
          this->source  = source ;
          this->id      = id     ;
          this->length  = length ;
          this->message = message;
        }
        virtual~PushDebugGroup(){}
        virtual void operator()(){
          glPushDebugGroup(
            ge::core::convertTo<GLenum       >(this->source ),
            ge::core::convertTo<GLuint       >(this->id     ),
            ge::core::convertTo<GLsizei      >(this->length ),
            ge::core::convertTo<const GLchar*>(this->message)
          );
        }
    };

    template<
      typename SYNC_TYPE = GLsync>
    class DeleteSync:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sync")return(void*)&this->sync;
          return NULL;
        }
      public:
        SYNC_TYPE sync;
        DeleteSync(
            SYNC_TYPE const&sync){
          this->sync = sync;
        }
        virtual~DeleteSync(){}
        virtual void operator()(){
          glDeleteSync(
            ge::core::convertTo<GLsync>(this->sync)
          );
        }
    };

    template<
      typename TARGET_TYPE  = GLenum ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei>
    class CopyTexSubImage3D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target" )return(void*)&this->target ;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "yoffset")return(void*)&this->yoffset;
          if(name == "zoffset")return(void*)&this->zoffset;
          if(name == "x"      )return(void*)&this->x      ;
          if(name == "y"      )return(void*)&this->y      ;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          return NULL;
        }
      public:
        TARGET_TYPE  target ;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        YOFFSET_TYPE yoffset;
        ZOFFSET_TYPE zoffset;
        X_TYPE       x      ;
        Y_TYPE       y      ;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        CopyTexSubImage3D(
            TARGET_TYPE  const&target ,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            YOFFSET_TYPE const&yoffset,
            ZOFFSET_TYPE const&zoffset,
            X_TYPE       const&x      ,
            Y_TYPE       const&y      ,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ){
          this->target  = target ;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->yoffset = yoffset;
          this->zoffset = zoffset;
          this->x       = x      ;
          this->y       = y      ;
          this->width   = width  ;
          this->height  = height ;
        }
        virtual~CopyTexSubImage3D(){}
        virtual void operator()(){
          glCopyTexSubImage3D(
            ge::core::convertTo<GLenum >(this->target ),
            ge::core::convertTo<GLint  >(this->level  ),
            ge::core::convertTo<GLint  >(this->xoffset),
            ge::core::convertTo<GLint  >(this->yoffset),
            ge::core::convertTo<GLint  >(this->zoffset),
            ge::core::convertTo<GLint  >(this->x      ),
            ge::core::convertTo<GLint  >(this->y      ),
            ge::core::convertTo<GLsizei>(this->width  ),
            ge::core::convertTo<GLsizei>(this->height )
          );
        }
    };

    template<
      typename XFB_TYPE   = GLuint  ,
      typename PNAME_TYPE = GLenum  ,
      typename INDEX_TYPE = GLuint  ,
      typename PARAM_TYPE = GLint64*>
    class GetTransformFeedbacki64_v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "xfb"  )return(void*)&this->xfb  ;
          if(name == "pname")return(void*)&this->pname;
          if(name == "index")return(void*)&this->index;
          if(name == "param")return(void*)&this->param;
          return NULL;
        }
      public:
        XFB_TYPE   xfb  ;
        PNAME_TYPE pname;
        INDEX_TYPE index;
        PARAM_TYPE param;
        GetTransformFeedbacki64_v(
            XFB_TYPE   const&xfb  ,
            PNAME_TYPE const&pname,
            INDEX_TYPE const&index,
            PARAM_TYPE const&param){
          this->xfb   = xfb  ;
          this->pname = pname;
          this->index = index;
          this->param = param;
        }
        virtual~GetTransformFeedbacki64_v(){}
        virtual void operator()(){
          glGetTransformFeedbacki64_v(
            ge::core::convertTo<GLuint  >(this->xfb  ),
            ge::core::convertTo<GLenum  >(this->pname),
            ge::core::convertTo<GLuint  >(this->index),
            ge::core::convertTo<GLint64*>(this->param)
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class UniformMatrix4dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix4dv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix4dv(){}
        virtual void operator()(){
          glUniformMatrix4dv(
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename INDEX_TYPE  = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetVertexAttribiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index" )return(void*)&this->index ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        INDEX_TYPE  index ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetVertexAttribiv(
            INDEX_TYPE  const&index ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->index  = index ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetVertexAttribiv(){}
        virtual void operator()(){
          glGetVertexAttribiv(
            ge::core::convertTo<GLuint>(this->index ),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class UniformMatrix4x2dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix4x2dv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix4x2dv(){}
        virtual void operator()(){
          glUniformMatrix4x2dv(
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename MODE_TYPE      = GLenum           ,
      typename COUNT_TYPE     = const GLsizei*   ,
      typename TYPE_TYPE      = GLenum           ,
      typename INDICES_TYPE   = const void*const*,
      typename DRAWCOUNT_TYPE = GLsizei          >
    class MultiDrawElements:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"     )return(void*)&this->mode     ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "type"     )return(void*)&this->type     ;
          if(name == "indices"  )return(void*)&this->indices  ;
          if(name == "drawcount")return(void*)&this->drawcount;
          return NULL;
        }
      public:
        MODE_TYPE      mode     ;
        COUNT_TYPE     count    ;
        TYPE_TYPE      type     ;
        INDICES_TYPE   indices  ;
        DRAWCOUNT_TYPE drawcount;
        MultiDrawElements(
            MODE_TYPE      const&mode     ,
            COUNT_TYPE     const&count    ,
            TYPE_TYPE      const&type     ,
            INDICES_TYPE   const&indices  ,
            DRAWCOUNT_TYPE const&drawcount){
          this->mode      = mode     ;
          this->count     = count    ;
          this->type      = type     ;
          this->indices   = indices  ;
          this->drawcount = drawcount;
        }
        virtual~MultiDrawElements(){}
        virtual void operator()(){
          glMultiDrawElements(
            ge::core::convertTo<GLenum           >(this->mode     ),
            ge::core::convertTo<const GLsizei*   >(this->count    ),
            ge::core::convertTo<GLenum           >(this->type     ),
            ge::core::convertTo<const void*const*>(this->indices  ),
            ge::core::convertTo<GLsizei          >(this->drawcount)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    class VertexAttrib3fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib3fv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib3fv(){}
        virtual void operator()(){
          glVertexAttrib3fv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLfloat*>(this->v    )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    class Uniform3iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform3iv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform3iv(){}
        virtual void operator()(){
          glUniform3iv(
            ge::core::convertTo<GLint       >(this->location),
            ge::core::convertTo<GLsizei     >(this->count   ),
            ge::core::convertTo<const GLint*>(this->value   )
          );
        }
    };

    template<
      typename FACE_TYPE = GLenum,
      typename MODE_TYPE = GLenum>
    class PolygonMode:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "face")return(void*)&this->face;
          if(name == "mode")return(void*)&this->mode;
          return NULL;
        }
      public:
        FACE_TYPE face;
        MODE_TYPE mode;
        PolygonMode(
            FACE_TYPE const&face,
            MODE_TYPE const&mode){
          this->face = face;
          this->mode = mode;
        }
        virtual~PolygonMode(){}
        virtual void operator()(){
          glPolygonMode(
            ge::core::convertTo<GLenum>(this->face),
            ge::core::convertTo<GLenum>(this->mode)
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class ProgramUniformMatrix4dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix4dv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix4dv(){}
        virtual void operator()(){
          glProgramUniformMatrix4dv(
            ge::core::convertTo<GLuint         >(this->program  ),
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE           = GLuint,
      typename UNIFORMBLOCKINDEX_TYPE = GLuint,
      typename PNAME_TYPE             = GLenum,
      typename PARAMS_TYPE            = GLint*>
    class GetActiveUniformBlockiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"          )return(void*)&this->program          ;
          if(name == "uniformBlockIndex")return(void*)&this->uniformBlockIndex;
          if(name == "pname"            )return(void*)&this->pname            ;
          if(name == "params"           )return(void*)&this->params           ;
          return NULL;
        }
      public:
        PROGRAM_TYPE           program          ;
        UNIFORMBLOCKINDEX_TYPE uniformBlockIndex;
        PNAME_TYPE             pname            ;
        PARAMS_TYPE            params           ;
        GetActiveUniformBlockiv(
            PROGRAM_TYPE           const&program          ,
            UNIFORMBLOCKINDEX_TYPE const&uniformBlockIndex,
            PNAME_TYPE             const&pname            ,
            PARAMS_TYPE            const&params           ){
          this->program           = program          ;
          this->uniformBlockIndex = uniformBlockIndex;
          this->pname             = pname            ;
          this->params            = params           ;
        }
        virtual~GetActiveUniformBlockiv(){}
        virtual void operator()(){
          glGetActiveUniformBlockiv(
            ge::core::convertTo<GLuint>(this->program          ),
            ge::core::convertTo<GLuint>(this->uniformBlockIndex),
            ge::core::convertTo<GLenum>(this->pname            ),
            ge::core::convertTo<GLint*>(this->params           )
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename SRC_TYPE         = GLenum>
    class NamedFramebufferReadBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "src"        )return(void*)&this->src        ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE framebuffer;
        SRC_TYPE         src        ;
        NamedFramebufferReadBuffer(
            FRAMEBUFFER_TYPE const&framebuffer,
            SRC_TYPE         const&src        ){
          this->framebuffer = framebuffer;
          this->src         = src        ;
        }
        virtual~NamedFramebufferReadBuffer(){}
        virtual void operator()(){
          glNamedFramebufferReadBuffer(
            ge::core::convertTo<GLuint>(this->framebuffer),
            ge::core::convertTo<GLenum>(this->src        )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint      ,
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    class ProgramUniform4iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform4iv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform4iv(){}
        virtual void operator()(){
          glProgramUniform4iv(
            ge::core::convertTo<GLuint      >(this->program ),
            ge::core::convertTo<GLint       >(this->location),
            ge::core::convertTo<GLsizei     >(this->count   ),
            ge::core::convertTo<const GLint*>(this->value   )
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class UniformMatrix2fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix2fv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix2fv(){}
        virtual void operator()(){
          glUniformMatrix2fv(
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint>
    class UseProgram:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        UseProgram(
            PROGRAM_TYPE const&program){
          this->program = program;
        }
        virtual~UseProgram(){}
        virtual void operator()(){
          glUseProgram(
            ge::core::convertTo<GLuint>(this->program)
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename INFOLOG_TYPE = GLchar* >
    class GetProgramInfoLog:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "length" )return(void*)&this->length ;
          if(name == "infoLog")return(void*)&this->infoLog;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        BUFSIZE_TYPE bufSize;
        LENGTH_TYPE  length ;
        INFOLOG_TYPE infoLog;
        GetProgramInfoLog(
            PROGRAM_TYPE const&program,
            BUFSIZE_TYPE const&bufSize,
            LENGTH_TYPE  const&length ,
            INFOLOG_TYPE const&infoLog){
          this->program = program;
          this->bufSize = bufSize;
          this->length  = length ;
          this->infoLog = infoLog;
        }
        virtual~GetProgramInfoLog(){}
        virtual void operator()(){
          glGetProgramInfoLog(
            ge::core::convertTo<GLuint  >(this->program),
            ge::core::convertTo<GLsizei >(this->bufSize),
            ge::core::convertTo<GLsizei*>(this->length ),
            ge::core::convertTo<GLchar* >(this->infoLog)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename ID_TYPE     = GLuint>
    class BindTransformFeedback:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "id"    )return(void*)&this->id    ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        ID_TYPE     id    ;
        BindTransformFeedback(
            TARGET_TYPE const&target,
            ID_TYPE     const&id    ){
          this->target = target;
          this->id     = id    ;
        }
        virtual~BindTransformFeedback(){}
        virtual void operator()(){
          glBindTransformFeedback(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLuint>(this->id    )
          );
        }
    };

    template<
      typename ARRAY_TYPE = GLuint>
    class BindVertexArray:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "array")return(void*)&this->array;
          return NULL;
        }
      public:
        ARRAY_TYPE array;
        BindVertexArray(
            ARRAY_TYPE const&array){
          this->array = array;
        }
        virtual~BindVertexArray(){}
        virtual void operator()(){
          glBindVertexArray(
            ge::core::convertTo<GLuint>(this->array)
          );
        }
    };

    template<
      typename N_TYPE       = GLsizei      ,
      typename BUFFERS_TYPE = const GLuint*>
    class DeleteBuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"      )return(void*)&this->n      ;
          if(name == "buffers")return(void*)&this->buffers;
          return NULL;
        }
      public:
        N_TYPE       n      ;
        BUFFERS_TYPE buffers;
        DeleteBuffers(
            N_TYPE       const&n      ,
            BUFFERS_TYPE const&buffers){
          this->n       = n      ;
          this->buffers = buffers;
        }
        virtual~DeleteBuffers(){}
        virtual void operator()(){
          glDeleteBuffers(
            ge::core::convertTo<GLsizei      >(this->n      ),
            ge::core::convertTo<const GLuint*>(this->buffers)
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint>
    class GenerateTextureMipmap:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        GenerateTextureMipmap(
            TEXTURE_TYPE const&texture){
          this->texture = texture;
        }
        virtual~GenerateTextureMipmap(){}
        virtual void operator()(){
          glGenerateTextureMipmap(
            ge::core::convertTo<GLuint>(this->texture)
          );
        }
    };

    template<
      typename SAMPLER_TYPE = GLuint      ,
      typename PNAME_TYPE   = GLenum      ,
      typename PARAM_TYPE   = const GLint*>
    class SamplerParameterIiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sampler")return(void*)&this->sampler;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "param"  )return(void*)&this->param  ;
          return NULL;
        }
      public:
        SAMPLER_TYPE sampler;
        PNAME_TYPE   pname  ;
        PARAM_TYPE   param  ;
        SamplerParameterIiv(
            SAMPLER_TYPE const&sampler,
            PNAME_TYPE   const&pname  ,
            PARAM_TYPE   const&param  ){
          this->sampler = sampler;
          this->pname   = pname  ;
          this->param   = param  ;
        }
        virtual~SamplerParameterIiv(){}
        virtual void operator()(){
          glSamplerParameterIiv(
            ge::core::convertTo<GLuint      >(this->sampler),
            ge::core::convertTo<GLenum      >(this->pname  ),
            ge::core::convertTo<const GLint*>(this->param  )
          );
        }
    };

    template<
      typename MODE_TYPE       = GLenum           ,
      typename COUNT_TYPE      = const GLsizei*   ,
      typename TYPE_TYPE       = GLenum           ,
      typename INDICES_TYPE    = const void*const*,
      typename DRAWCOUNT_TYPE  = GLsizei          ,
      typename BASEVERTEX_TYPE = const GLint*     >
    class MultiDrawElementsBaseVertex:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"      )return(void*)&this->mode      ;
          if(name == "count"     )return(void*)&this->count     ;
          if(name == "type"      )return(void*)&this->type      ;
          if(name == "indices"   )return(void*)&this->indices   ;
          if(name == "drawcount" )return(void*)&this->drawcount ;
          if(name == "basevertex")return(void*)&this->basevertex;
          return NULL;
        }
      public:
        MODE_TYPE       mode      ;
        COUNT_TYPE      count     ;
        TYPE_TYPE       type      ;
        INDICES_TYPE    indices   ;
        DRAWCOUNT_TYPE  drawcount ;
        BASEVERTEX_TYPE basevertex;
        MultiDrawElementsBaseVertex(
            MODE_TYPE       const&mode      ,
            COUNT_TYPE      const&count     ,
            TYPE_TYPE       const&type      ,
            INDICES_TYPE    const&indices   ,
            DRAWCOUNT_TYPE  const&drawcount ,
            BASEVERTEX_TYPE const&basevertex){
          this->mode       = mode      ;
          this->count      = count     ;
          this->type       = type      ;
          this->indices    = indices   ;
          this->drawcount  = drawcount ;
          this->basevertex = basevertex;
        }
        virtual~MultiDrawElementsBaseVertex(){}
        virtual void operator()(){
          glMultiDrawElementsBaseVertex(
            ge::core::convertTo<GLenum           >(this->mode      ),
            ge::core::convertTo<const GLsizei*   >(this->count     ),
            ge::core::convertTo<GLenum           >(this->type      ),
            ge::core::convertTo<const void*const*>(this->indices   ),
            ge::core::convertTo<GLsizei          >(this->drawcount ),
            ge::core::convertTo<const GLint*     >(this->basevertex)
          );
        }
    };

    template<
      typename BUFFER_TYPE = GLuint     ,
      typename OFFSET_TYPE = GLintptr   ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*>
    class NamedBufferSubData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "offset")return(void*)&this->offset;
          if(name == "size"  )return(void*)&this->size  ;
          if(name == "data"  )return(void*)&this->data  ;
          return NULL;
        }
      public:
        BUFFER_TYPE buffer;
        OFFSET_TYPE offset;
        SIZE_TYPE   size  ;
        DATA_TYPE   data  ;
        NamedBufferSubData(
            BUFFER_TYPE const&buffer,
            OFFSET_TYPE const&offset,
            SIZE_TYPE   const&size  ,
            DATA_TYPE   const&data  ){
          this->buffer = buffer;
          this->offset = offset;
          this->size   = size  ;
          this->data   = data  ;
        }
        virtual~NamedBufferSubData(){}
        virtual void operator()(){
          glNamedBufferSubData(
            ge::core::convertTo<GLuint     >(this->buffer),
            ge::core::convertTo<GLintptr   >(this->offset),
            ge::core::convertTo<GLsizeiptr >(this->size  ),
            ge::core::convertTo<const void*>(this->data  )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    class Uniform2uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform2uiv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform2uiv(){}
        virtual void operator()(){
          glUniform2uiv(
            ge::core::convertTo<GLint        >(this->location),
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->value   )
          );
        }
    };

    template<
      typename TARGET_TYPE    = GLenum     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    class CompressedTexSubImage1D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"   )return(void*)&this->target   ;
          if(name == "level"    )return(void*)&this->level    ;
          if(name == "xoffset"  )return(void*)&this->xoffset  ;
          if(name == "width"    )return(void*)&this->width    ;
          if(name == "format"   )return(void*)&this->format   ;
          if(name == "imageSize")return(void*)&this->imageSize;
          if(name == "data"     )return(void*)&this->data     ;
          return NULL;
        }
      public:
        TARGET_TYPE    target   ;
        LEVEL_TYPE     level    ;
        XOFFSET_TYPE   xoffset  ;
        WIDTH_TYPE     width    ;
        FORMAT_TYPE    format   ;
        IMAGESIZE_TYPE imageSize;
        DATA_TYPE      data     ;
        CompressedTexSubImage1D(
            TARGET_TYPE    const&target   ,
            LEVEL_TYPE     const&level    ,
            XOFFSET_TYPE   const&xoffset  ,
            WIDTH_TYPE     const&width    ,
            FORMAT_TYPE    const&format   ,
            IMAGESIZE_TYPE const&imageSize,
            DATA_TYPE      const&data     ){
          this->target    = target   ;
          this->level     = level    ;
          this->xoffset   = xoffset  ;
          this->width     = width    ;
          this->format    = format   ;
          this->imageSize = imageSize;
          this->data      = data     ;
        }
        virtual~CompressedTexSubImage1D(){}
        virtual void operator()(){
          glCompressedTexSubImage1D(
            ge::core::convertTo<GLenum     >(this->target   ),
            ge::core::convertTo<GLint      >(this->level    ),
            ge::core::convertTo<GLint      >(this->xoffset  ),
            ge::core::convertTo<GLsizei    >(this->width    ),
            ge::core::convertTo<GLenum     >(this->format   ),
            ge::core::convertTo<GLsizei    >(this->imageSize),
            ge::core::convertTo<const void*>(this->data     )
          );
        }
    };

    class Finish:
        public ge::core::Command{
      public:
        Finish(
            ){
        }
        virtual~Finish(){}
        virtual void operator()(){
          glFinish(

          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint  ,
      typename N_TYPE     = GLdouble,
      typename F_TYPE     = GLdouble>
    class DepthRangeIndexed:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "n"    )return(void*)&this->n    ;
          if(name == "f"    )return(void*)&this->f    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        N_TYPE     n    ;
        F_TYPE     f    ;
        DepthRangeIndexed(
            INDEX_TYPE const&index,
            N_TYPE     const&n    ,
            F_TYPE     const&f    ){
          this->index = index;
          this->n     = n    ;
          this->f     = f    ;
        }
        virtual~DepthRangeIndexed(){}
        virtual void operator()(){
          glDepthRangeIndexed(
            ge::core::convertTo<GLuint  >(this->index),
            ge::core::convertTo<GLdouble>(this->n    ),
            ge::core::convertTo<GLdouble>(this->f    )
          );
        }
    };

    template<
      typename SHADER_TYPE = GLuint>
    class DeleteShader:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "shader")return(void*)&this->shader;
          return NULL;
        }
      public:
        SHADER_TYPE shader;
        DeleteShader(
            SHADER_TYPE const&shader){
          this->shader = shader;
        }
        virtual~DeleteShader(){}
        virtual void operator()(){
          glDeleteShader(
            ge::core::convertTo<GLuint>(this->shader)
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum  ,
      typename INTERNALFORMAT_TYPE = GLenum  ,
      typename PNAME_TYPE          = GLenum  ,
      typename BUFSIZE_TYPE        = GLsizei ,
      typename PARAMS_TYPE         = GLint64*>
    class GetInternalformati64v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "pname"         )return(void*)&this->pname         ;
          if(name == "bufSize"       )return(void*)&this->bufSize       ;
          if(name == "params"        )return(void*)&this->params        ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        INTERNALFORMAT_TYPE internalformat;
        PNAME_TYPE          pname         ;
        BUFSIZE_TYPE        bufSize       ;
        PARAMS_TYPE         params        ;
        GetInternalformati64v(
            TARGET_TYPE         const&target        ,
            INTERNALFORMAT_TYPE const&internalformat,
            PNAME_TYPE          const&pname         ,
            BUFSIZE_TYPE        const&bufSize       ,
            PARAMS_TYPE         const&params        ){
          this->target         = target        ;
          this->internalformat = internalformat;
          this->pname          = pname         ;
          this->bufSize        = bufSize       ;
          this->params         = params        ;
        }
        virtual~GetInternalformati64v(){}
        virtual void operator()(){
          glGetInternalformati64v(
            ge::core::convertTo<GLenum  >(this->target        ),
            ge::core::convertTo<GLenum  >(this->internalformat),
            ge::core::convertTo<GLenum  >(this->pname         ),
            ge::core::convertTo<GLsizei >(this->bufSize       ),
            ge::core::convertTo<GLint64*>(this->params        )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei>
    class CopyTextureSubImage1D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "x"      )return(void*)&this->x      ;
          if(name == "y"      )return(void*)&this->y      ;
          if(name == "width"  )return(void*)&this->width  ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        X_TYPE       x      ;
        Y_TYPE       y      ;
        WIDTH_TYPE   width  ;
        CopyTextureSubImage1D(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            X_TYPE       const&x      ,
            Y_TYPE       const&y      ,
            WIDTH_TYPE   const&width  ){
          this->texture = texture;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->x       = x      ;
          this->y       = y      ;
          this->width   = width  ;
        }
        virtual~CopyTextureSubImage1D(){}
        virtual void operator()(){
          glCopyTextureSubImage1D(
            ge::core::convertTo<GLuint >(this->texture),
            ge::core::convertTo<GLint  >(this->level  ),
            ge::core::convertTo<GLint  >(this->xoffset),
            ge::core::convertTo<GLint  >(this->x      ),
            ge::core::convertTo<GLint  >(this->y      ),
            ge::core::convertTo<GLsizei>(this->width  )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename HEIGHT_TYPE         = GLsizei    ,
      typename DEPTH_TYPE          = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename IMAGESIZE_TYPE      = GLsizei    ,
      typename DATA_TYPE           = const void*>
    class CompressedTexImage3D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "level"         )return(void*)&this->level         ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          if(name == "depth"         )return(void*)&this->depth         ;
          if(name == "border"        )return(void*)&this->border        ;
          if(name == "imageSize"     )return(void*)&this->imageSize     ;
          if(name == "data"          )return(void*)&this->data          ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        LEVEL_TYPE          level         ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        DEPTH_TYPE          depth         ;
        BORDER_TYPE         border        ;
        IMAGESIZE_TYPE      imageSize     ;
        DATA_TYPE           data          ;
        CompressedTexImage3D(
            TARGET_TYPE         const&target        ,
            LEVEL_TYPE          const&level         ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ,
            DEPTH_TYPE          const&depth         ,
            BORDER_TYPE         const&border        ,
            IMAGESIZE_TYPE      const&imageSize     ,
            DATA_TYPE           const&data          ){
          this->target         = target        ;
          this->level          = level         ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->height         = height        ;
          this->depth          = depth         ;
          this->border         = border        ;
          this->imageSize      = imageSize     ;
          this->data           = data          ;
        }
        virtual~CompressedTexImage3D(){}
        virtual void operator()(){
          glCompressedTexImage3D(
            ge::core::convertTo<GLenum     >(this->target        ),
            ge::core::convertTo<GLint      >(this->level         ),
            ge::core::convertTo<GLenum     >(this->internalformat),
            ge::core::convertTo<GLsizei    >(this->width         ),
            ge::core::convertTo<GLsizei    >(this->height        ),
            ge::core::convertTo<GLsizei    >(this->depth         ),
            ge::core::convertTo<GLint      >(this->border        ),
            ge::core::convertTo<GLsizei    >(this->imageSize     ),
            ge::core::convertTo<const void*>(this->data          )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    class VertexAttrib4Nsv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4Nsv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4Nsv(){}
        virtual void operator()(){
          glVertexAttrib4Nsv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLshort*>(this->v    )
          );
        }
    };

    template<
      typename RET_TYPE              = GLint        ,
      typename PROGRAM_TYPE          = GLuint       ,
      typename PROGRAMINTERFACE_TYPE = GLenum       ,
      typename NAME_TYPE             = const GLchar*>
    class GetProgramResourceLocationIndex:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"             )return(void*)&this->ret             ;
          if(name == "program"         )return(void*)&this->program         ;
          if(name == "programInterface")return(void*)&this->programInterface;
          if(name == "name"            )return(void*)&this->name            ;
          return NULL;
        }
      public:
        RET_TYPE              ret             ;
        PROGRAM_TYPE          program         ;
        PROGRAMINTERFACE_TYPE programInterface;
        NAME_TYPE             name            ;
        GetProgramResourceLocationIndex(
            RET_TYPE              const&ret             ,
            PROGRAM_TYPE          const&program         ,
            PROGRAMINTERFACE_TYPE const&programInterface,
            NAME_TYPE             const&name            ){
          this->ret              = ret             ;
          this->program          = program         ;
          this->programInterface = programInterface;
          this->name             = name            ;
        }
        virtual~GetProgramResourceLocationIndex(){}
        virtual void operator()(){
          ge::core::convertFrom<GLint>(this->ret,glGetProgramResourceLocationIndex(
              ge::core::convertTo<GLuint       >(this->program         ),
              ge::core::convertTo<GLenum       >(this->programInterface),
              ge::core::convertTo<const GLchar*>(this->name            ))
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint       ,
      typename PNAME_TYPE   = GLenum       ,
      typename PARAMS_TYPE  = const GLuint*>
    class TextureParameterIuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        TextureParameterIuiv(
            TEXTURE_TYPE const&texture,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->texture = texture;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~TextureParameterIuiv(){}
        virtual void operator()(){
          glTextureParameterIuiv(
            ge::core::convertTo<GLuint       >(this->texture),
            ge::core::convertTo<GLenum       >(this->pname  ),
            ge::core::convertTo<const GLuint*>(this->params )
          );
        }
    };

    template<
      typename X_TYPE      = GLint  ,
      typename Y_TYPE      = GLint  ,
      typename WIDTH_TYPE  = GLsizei,
      typename HEIGHT_TYPE = GLsizei>
    class Viewport:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "x"     )return(void*)&this->x     ;
          if(name == "y"     )return(void*)&this->y     ;
          if(name == "width" )return(void*)&this->width ;
          if(name == "height")return(void*)&this->height;
          return NULL;
        }
      public:
        X_TYPE      x     ;
        Y_TYPE      y     ;
        WIDTH_TYPE  width ;
        HEIGHT_TYPE height;
        Viewport(
            X_TYPE      const&x     ,
            Y_TYPE      const&y     ,
            WIDTH_TYPE  const&width ,
            HEIGHT_TYPE const&height){
          this->x      = x     ;
          this->y      = y     ;
          this->width  = width ;
          this->height = height;
        }
        virtual~Viewport(){}
        virtual void operator()(){
          glViewport(
            ge::core::convertTo<GLint  >(this->x     ),
            ge::core::convertTo<GLint  >(this->y     ),
            ge::core::convertTo<GLsizei>(this->width ),
            ge::core::convertTo<GLsizei>(this->height)
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    class Uniform1uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform1uiv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform1uiv(){}
        virtual void operator()(){
          glUniform1uiv(
            ge::core::convertTo<GLint        >(this->location),
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->value   )
          );
        }
    };

    template<
      typename PROGRAM_TYPE    = GLuint             ,
      typename COUNT_TYPE      = GLsizei            ,
      typename VARYINGS_TYPE   = const GLchar*const*,
      typename BUFFERMODE_TYPE = GLenum             >
    class TransformFeedbackVaryings:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"   )return(void*)&this->program   ;
          if(name == "count"     )return(void*)&this->count     ;
          if(name == "varyings"  )return(void*)&this->varyings  ;
          if(name == "bufferMode")return(void*)&this->bufferMode;
          return NULL;
        }
      public:
        PROGRAM_TYPE    program   ;
        COUNT_TYPE      count     ;
        VARYINGS_TYPE   varyings  ;
        BUFFERMODE_TYPE bufferMode;
        TransformFeedbackVaryings(
            PROGRAM_TYPE    const&program   ,
            COUNT_TYPE      const&count     ,
            VARYINGS_TYPE   const&varyings  ,
            BUFFERMODE_TYPE const&bufferMode){
          this->program    = program   ;
          this->count      = count     ;
          this->varyings   = varyings  ;
          this->bufferMode = bufferMode;
        }
        virtual~TransformFeedbackVaryings(){}
        virtual void operator()(){
          glTransformFeedbackVaryings(
            ge::core::convertTo<GLuint             >(this->program   ),
            ge::core::convertTo<GLsizei            >(this->count     ),
            ge::core::convertTo<const GLchar*const*>(this->varyings  ),
            ge::core::convertTo<GLenum             >(this->bufferMode)
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint>
    class Uniform2ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        Uniform2ui(
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ){
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
        }
        virtual~Uniform2ui(){}
        virtual void operator()(){
          glUniform2ui(
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLuint>(this->v0      ),
            ge::core::convertTo<GLuint>(this->v1      )
          );
        }
    };

    template<
      typename CALLBACK_TYPE  = GLDEBUGPROC,
      typename USERPARAM_TYPE = const void*>
    class DebugMessageCallback:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "callback" )return(void*)&this->callback ;
          if(name == "userParam")return(void*)&this->userParam;
          return NULL;
        }
      public:
        CALLBACK_TYPE  callback ;
        USERPARAM_TYPE userParam;
        DebugMessageCallback(
            CALLBACK_TYPE  const&callback ,
            USERPARAM_TYPE const&userParam){
          this->callback  = callback ;
          this->userParam = userParam;
        }
        virtual~DebugMessageCallback(){}
        virtual void operator()(){
          glDebugMessageCallback(
            ge::core::convertTo<GLDEBUGPROC>(this->callback ),
            ge::core::convertTo<const void*>(this->userParam)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLint ,
      typename Y_TYPE     = GLint ,
      typename Z_TYPE     = GLint >
    class VertexAttribI3i:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        VertexAttribI3i(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
        }
        virtual~VertexAttribI3i(){}
        virtual void operator()(){
          glVertexAttribI3i(
            ge::core::convertTo<GLuint>(this->index),
            ge::core::convertTo<GLint >(this->x    ),
            ge::core::convertTo<GLint >(this->y    ),
            ge::core::convertTo<GLint >(this->z    )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint,
      typename LEVEL_TYPE   = GLint >
    class InvalidateTexImage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        InvalidateTexImage(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ){
          this->texture = texture;
          this->level   = level  ;
        }
        virtual~InvalidateTexImage(){}
        virtual void operator()(){
          glInvalidateTexImage(
            ge::core::convertTo<GLuint>(this->texture),
            ge::core::convertTo<GLint >(this->level  )
          );
        }
    };

    template<
      typename ATTRIBINDEX_TYPE    = GLuint   ,
      typename SIZE_TYPE           = GLint    ,
      typename TYPE_TYPE           = GLenum   ,
      typename NORMALIZED_TYPE     = GLboolean,
      typename RELATIVEOFFSET_TYPE = GLuint   >
    class VertexAttribFormat:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "attribindex"   )return(void*)&this->attribindex   ;
          if(name == "size"          )return(void*)&this->size          ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "normalized"    )return(void*)&this->normalized    ;
          if(name == "relativeoffset")return(void*)&this->relativeoffset;
          return NULL;
        }
      public:
        ATTRIBINDEX_TYPE    attribindex   ;
        SIZE_TYPE           size          ;
        TYPE_TYPE           type          ;
        NORMALIZED_TYPE     normalized    ;
        RELATIVEOFFSET_TYPE relativeoffset;
        VertexAttribFormat(
            ATTRIBINDEX_TYPE    const&attribindex   ,
            SIZE_TYPE           const&size          ,
            TYPE_TYPE           const&type          ,
            NORMALIZED_TYPE     const&normalized    ,
            RELATIVEOFFSET_TYPE const&relativeoffset){
          this->attribindex    = attribindex   ;
          this->size           = size          ;
          this->type           = type          ;
          this->normalized     = normalized    ;
          this->relativeoffset = relativeoffset;
        }
        virtual~VertexAttribFormat(){}
        virtual void operator()(){
          glVertexAttribFormat(
            ge::core::convertTo<GLuint   >(this->attribindex   ),
            ge::core::convertTo<GLint    >(this->size          ),
            ge::core::convertTo<GLenum   >(this->type          ),
            ge::core::convertTo<GLboolean>(this->normalized    ),
            ge::core::convertTo<GLuint   >(this->relativeoffset)
          );
        }
    };

    template<
      typename TARGET_TYPE               = GLenum   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    class TexStorage2DMultisample:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"              )return(void*)&this->target              ;
          if(name == "samples"             )return(void*)&this->samples             ;
          if(name == "internalformat"      )return(void*)&this->internalformat      ;
          if(name == "width"               )return(void*)&this->width               ;
          if(name == "height"              )return(void*)&this->height              ;
          if(name == "fixedsamplelocations")return(void*)&this->fixedsamplelocations;
          return NULL;
        }
      public:
        TARGET_TYPE               target              ;
        SAMPLES_TYPE              samples             ;
        INTERNALFORMAT_TYPE       internalformat      ;
        WIDTH_TYPE                width               ;
        HEIGHT_TYPE               height              ;
        FIXEDSAMPLELOCATIONS_TYPE fixedsamplelocations;
        TexStorage2DMultisample(
            TARGET_TYPE               const&target              ,
            SAMPLES_TYPE              const&samples             ,
            INTERNALFORMAT_TYPE       const&internalformat      ,
            WIDTH_TYPE                const&width               ,
            HEIGHT_TYPE               const&height              ,
            FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
          this->target               = target              ;
          this->samples              = samples             ;
          this->internalformat       = internalformat      ;
          this->width                = width               ;
          this->height               = height              ;
          this->fixedsamplelocations = fixedsamplelocations;
        }
        virtual~TexStorage2DMultisample(){}
        virtual void operator()(){
          glTexStorage2DMultisample(
            ge::core::convertTo<GLenum   >(this->target              ),
            ge::core::convertTo<GLsizei  >(this->samples             ),
            ge::core::convertTo<GLenum   >(this->internalformat      ),
            ge::core::convertTo<GLsizei  >(this->width               ),
            ge::core::convertTo<GLsizei  >(this->height              ),
            ge::core::convertTo<GLboolean>(this->fixedsamplelocations)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLushort*>
    class VertexAttribI4usv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribI4usv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribI4usv(){}
        virtual void operator()(){
          glVertexAttribI4usv(
            ge::core::convertTo<GLuint         >(this->index),
            ge::core::convertTo<const GLushort*>(this->v    )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum ,
      typename PNAME_TYPE  = GLenum ,
      typename PARAM_TYPE  = GLfloat>
    class TexParameterf:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "param" )return(void*)&this->param ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAM_TYPE  param ;
        TexParameterf(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAM_TYPE  const&param ){
          this->target = target;
          this->pname  = pname ;
          this->param  = param ;
        }
        virtual~TexParameterf(){}
        virtual void operator()(){
          glTexParameterf(
            ge::core::convertTo<GLenum >(this->target),
            ge::core::convertTo<GLenum >(this->pname ),
            ge::core::convertTo<GLfloat>(this->param )
          );
        }
    };

    template<
      typename ATTRIBINDEX_TYPE  = GLuint,
      typename BINDINGINDEX_TYPE = GLuint>
    class VertexAttribBinding:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "attribindex" )return(void*)&this->attribindex ;
          if(name == "bindingindex")return(void*)&this->bindingindex;
          return NULL;
        }
      public:
        ATTRIBINDEX_TYPE  attribindex ;
        BINDINGINDEX_TYPE bindingindex;
        VertexAttribBinding(
            ATTRIBINDEX_TYPE  const&attribindex ,
            BINDINGINDEX_TYPE const&bindingindex){
          this->attribindex  = attribindex ;
          this->bindingindex = bindingindex;
        }
        virtual~VertexAttribBinding(){}
        virtual void operator()(){
          glVertexAttribBinding(
            ge::core::convertTo<GLuint>(this->attribindex ),
            ge::core::convertTo<GLuint>(this->bindingindex)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAM_TYPE  = GLint >
    class TexParameteri:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "param" )return(void*)&this->param ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAM_TYPE  param ;
        TexParameteri(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAM_TYPE  const&param ){
          this->target = target;
          this->pname  = pname ;
          this->param  = param ;
        }
        virtual~TexParameteri(){}
        virtual void operator()(){
          glTexParameteri(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint >(this->param )
          );
        }
    };

    template<
      typename PROGRAM_TYPE    = GLuint,
      typename SHADERTYPE_TYPE = GLenum,
      typename INDEX_TYPE      = GLuint,
      typename PNAME_TYPE      = GLenum,
      typename VALUES_TYPE     = GLint*>
    class GetActiveSubroutineUniformiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"   )return(void*)&this->program   ;
          if(name == "shadertype")return(void*)&this->shadertype;
          if(name == "index"     )return(void*)&this->index     ;
          if(name == "pname"     )return(void*)&this->pname     ;
          if(name == "values"    )return(void*)&this->values    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE    program   ;
        SHADERTYPE_TYPE shadertype;
        INDEX_TYPE      index     ;
        PNAME_TYPE      pname     ;
        VALUES_TYPE     values    ;
        GetActiveSubroutineUniformiv(
            PROGRAM_TYPE    const&program   ,
            SHADERTYPE_TYPE const&shadertype,
            INDEX_TYPE      const&index     ,
            PNAME_TYPE      const&pname     ,
            VALUES_TYPE     const&values    ){
          this->program    = program   ;
          this->shadertype = shadertype;
          this->index      = index     ;
          this->pname      = pname     ;
          this->values     = values    ;
        }
        virtual~GetActiveSubroutineUniformiv(){}
        virtual void operator()(){
          glGetActiveSubroutineUniformiv(
            ge::core::convertTo<GLuint>(this->program   ),
            ge::core::convertTo<GLenum>(this->shadertype),
            ge::core::convertTo<GLuint>(this->index     ),
            ge::core::convertTo<GLenum>(this->pname     ),
            ge::core::convertTo<GLint*>(this->values    )
          );
        }
    };

    template<
      typename SHADER_TYPE  = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename SOURCE_TYPE  = GLchar* >
    class GetShaderSource:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "shader" )return(void*)&this->shader ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "length" )return(void*)&this->length ;
          if(name == "source" )return(void*)&this->source ;
          return NULL;
        }
      public:
        SHADER_TYPE  shader ;
        BUFSIZE_TYPE bufSize;
        LENGTH_TYPE  length ;
        SOURCE_TYPE  source ;
        GetShaderSource(
            SHADER_TYPE  const&shader ,
            BUFSIZE_TYPE const&bufSize,
            LENGTH_TYPE  const&length ,
            SOURCE_TYPE  const&source ){
          this->shader  = shader ;
          this->bufSize = bufSize;
          this->length  = length ;
          this->source  = source ;
        }
        virtual~GetShaderSource(){}
        virtual void operator()(){
          glGetShaderSource(
            ge::core::convertTo<GLuint  >(this->shader ),
            ge::core::convertTo<GLsizei >(this->bufSize),
            ge::core::convertTo<GLsizei*>(this->length ),
            ge::core::convertTo<GLchar* >(this->source )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum,
      typename INTERNALFORMAT_TYPE = GLenum,
      typename BUFFER_TYPE         = GLuint>
    class TexBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "buffer"        )return(void*)&this->buffer        ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        INTERNALFORMAT_TYPE internalformat;
        BUFFER_TYPE         buffer        ;
        TexBuffer(
            TARGET_TYPE         const&target        ,
            INTERNALFORMAT_TYPE const&internalformat,
            BUFFER_TYPE         const&buffer        ){
          this->target         = target        ;
          this->internalformat = internalformat;
          this->buffer         = buffer        ;
        }
        virtual~TexBuffer(){}
        virtual void operator()(){
          glTexBuffer(
            ge::core::convertTo<GLenum>(this->target        ),
            ge::core::convertTo<GLenum>(this->internalformat),
            ge::core::convertTo<GLuint>(this->buffer        )
          );
        }
    };

    template<
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint >
    class PixelStorei:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname")return(void*)&this->pname;
          if(name == "param")return(void*)&this->param;
          return NULL;
        }
      public:
        PNAME_TYPE pname;
        PARAM_TYPE param;
        PixelStorei(
            PNAME_TYPE const&pname,
            PARAM_TYPE const&param){
          this->pname = pname;
          this->param = param;
        }
        virtual~PixelStorei(){}
        virtual void operator()(){
          glPixelStorei(
            ge::core::convertTo<GLenum>(this->pname),
            ge::core::convertTo<GLint >(this->param)
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint>
    class ValidateProgram:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        ValidateProgram(
            PROGRAM_TYPE const&program){
          this->program = program;
        }
        virtual~ValidateProgram(){}
        virtual void operator()(){
          glValidateProgram(
            ge::core::convertTo<GLuint>(this->program)
          );
        }
    };

    template<
      typename PNAME_TYPE = GLenum ,
      typename PARAM_TYPE = GLfloat>
    class PixelStoref:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname")return(void*)&this->pname;
          if(name == "param")return(void*)&this->param;
          return NULL;
        }
      public:
        PNAME_TYPE pname;
        PARAM_TYPE param;
        PixelStoref(
            PNAME_TYPE const&pname,
            PARAM_TYPE const&param){
          this->pname = pname;
          this->param = param;
        }
        virtual~PixelStoref(){}
        virtual void operator()(){
          glPixelStoref(
            ge::core::convertTo<GLenum >(this->pname),
            ge::core::convertTo<GLfloat>(this->param)
          );
        }
    };

    template<
      typename N_TYPE       = GLsizei,
      typename BUFFERS_TYPE = GLuint*>
    class CreateBuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"      )return(void*)&this->n      ;
          if(name == "buffers")return(void*)&this->buffers;
          return NULL;
        }
      public:
        N_TYPE       n      ;
        BUFFERS_TYPE buffers;
        CreateBuffers(
            N_TYPE       const&n      ,
            BUFFERS_TYPE const&buffers){
          this->n       = n      ;
          this->buffers = buffers;
        }
        virtual~CreateBuffers(){}
        virtual void operator()(){
          glCreateBuffers(
            ge::core::convertTo<GLsizei>(this->n      ),
            ge::core::convertTo<GLuint*>(this->buffers)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum    ,
      typename INDEX_TYPE  = GLuint    ,
      typename DATA_TYPE   = GLboolean*>
    class GetBooleani_v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          if(name == "data"  )return(void*)&this->data  ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        DATA_TYPE   data  ;
        GetBooleani_v(
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ,
            DATA_TYPE   const&data  ){
          this->target = target;
          this->index  = index ;
          this->data   = data  ;
        }
        virtual~GetBooleani_v(){}
        virtual void operator()(){
          glGetBooleani_v(
            ge::core::convertTo<GLenum    >(this->target),
            ge::core::convertTo<GLuint    >(this->index ),
            ge::core::convertTo<GLboolean*>(this->data  )
          );
        }
    };

    template<
      typename ORIGIN_TYPE = GLenum,
      typename DEPTH_TYPE  = GLenum>
    class ClipControl:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "origin")return(void*)&this->origin;
          if(name == "depth" )return(void*)&this->depth ;
          return NULL;
        }
      public:
        ORIGIN_TYPE origin;
        DEPTH_TYPE  depth ;
        ClipControl(
            ORIGIN_TYPE const&origin,
            DEPTH_TYPE  const&depth ){
          this->origin = origin;
          this->depth  = depth ;
        }
        virtual~ClipControl(){}
        virtual void operator()(){
          glClipControl(
            ge::core::convertTo<GLenum>(this->origin),
            ge::core::convertTo<GLenum>(this->depth )
          );
        }
    };

    template<
      typename N_TYPE         = GLsizei,
      typename PIPELINES_TYPE = GLuint*>
    class GenProgramPipelines:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"        )return(void*)&this->n        ;
          if(name == "pipelines")return(void*)&this->pipelines;
          return NULL;
        }
      public:
        N_TYPE         n        ;
        PIPELINES_TYPE pipelines;
        GenProgramPipelines(
            N_TYPE         const&n        ,
            PIPELINES_TYPE const&pipelines){
          this->n         = n        ;
          this->pipelines = pipelines;
        }
        virtual~GenProgramPipelines(){}
        virtual void operator()(){
          glGenProgramPipelines(
            ge::core::convertTo<GLsizei>(this->n        ),
            ge::core::convertTo<GLuint*>(this->pipelines)
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename PNAME_TYPE          = GLenum ,
      typename BUFSIZE_TYPE        = GLsizei,
      typename PARAMS_TYPE         = GLint* >
    class GetInternalformativ:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "pname"         )return(void*)&this->pname         ;
          if(name == "bufSize"       )return(void*)&this->bufSize       ;
          if(name == "params"        )return(void*)&this->params        ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        INTERNALFORMAT_TYPE internalformat;
        PNAME_TYPE          pname         ;
        BUFSIZE_TYPE        bufSize       ;
        PARAMS_TYPE         params        ;
        GetInternalformativ(
            TARGET_TYPE         const&target        ,
            INTERNALFORMAT_TYPE const&internalformat,
            PNAME_TYPE          const&pname         ,
            BUFSIZE_TYPE        const&bufSize       ,
            PARAMS_TYPE         const&params        ){
          this->target         = target        ;
          this->internalformat = internalformat;
          this->pname          = pname         ;
          this->bufSize        = bufSize       ;
          this->params         = params        ;
        }
        virtual~GetInternalformativ(){}
        virtual void operator()(){
          glGetInternalformativ(
            ge::core::convertTo<GLenum >(this->target        ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLenum >(this->pname         ),
            ge::core::convertTo<GLsizei>(this->bufSize       ),
            ge::core::convertTo<GLint* >(this->params        )
          );
        }
    };

    template<
      typename PNAME_TYPE = GLenum  ,
      typename DATA_TYPE  = GLfloat*>
    class GetFloatv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname")return(void*)&this->pname;
          if(name == "data" )return(void*)&this->data ;
          return NULL;
        }
      public:
        PNAME_TYPE pname;
        DATA_TYPE  data ;
        GetFloatv(
            PNAME_TYPE const&pname,
            DATA_TYPE  const&data ){
          this->pname = pname;
          this->data  = data ;
        }
        virtual~GetFloatv(){}
        virtual void operator()(){
          glGetFloatv(
            ge::core::convertTo<GLenum  >(this->pname),
            ge::core::convertTo<GLfloat*>(this->data )
          );
        }
    };

    template<
      typename INDEX_TYPE      = GLuint       ,
      typename TYPE_TYPE       = GLenum       ,
      typename NORMALIZED_TYPE = GLboolean    ,
      typename VALUE_TYPE      = const GLuint*>
    class VertexAttribP1uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"     )return(void*)&this->index     ;
          if(name == "type"      )return(void*)&this->type      ;
          if(name == "normalized")return(void*)&this->normalized;
          if(name == "value"     )return(void*)&this->value     ;
          return NULL;
        }
      public:
        INDEX_TYPE      index     ;
        TYPE_TYPE       type      ;
        NORMALIZED_TYPE normalized;
        VALUE_TYPE      value     ;
        VertexAttribP1uiv(
            INDEX_TYPE      const&index     ,
            TYPE_TYPE       const&type      ,
            NORMALIZED_TYPE const&normalized,
            VALUE_TYPE      const&value     ){
          this->index      = index     ;
          this->type       = type      ;
          this->normalized = normalized;
          this->value      = value     ;
        }
        virtual~VertexAttribP1uiv(){}
        virtual void operator()(){
          glVertexAttribP1uiv(
            ge::core::convertTo<GLuint       >(this->index     ),
            ge::core::convertTo<GLenum       >(this->type      ),
            ge::core::convertTo<GLboolean    >(this->normalized),
            ge::core::convertTo<const GLuint*>(this->value     )
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint>
    class LinkProgram:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        LinkProgram(
            PROGRAM_TYPE const&program){
          this->program = program;
        }
        virtual~LinkProgram(){}
        virtual void operator()(){
          glLinkProgram(
            ge::core::convertTo<GLuint>(this->program)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename MODE_TYPE   = GLenum>
    class Hint:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "mode"  )return(void*)&this->mode  ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        MODE_TYPE   mode  ;
        Hint(
            TARGET_TYPE const&target,
            MODE_TYPE   const&mode  ){
          this->target = target;
          this->mode   = mode  ;
        }
        virtual~Hint(){}
        virtual void operator()(){
          glHint(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLenum>(this->mode  )
          );
        }
    };

    template<
      typename MODE_TYPE      = GLenum     ,
      typename INDIRECT_TYPE  = const void*,
      typename DRAWCOUNT_TYPE = GLsizei    ,
      typename STRIDE_TYPE    = GLsizei    >
    class MultiDrawArraysIndirect:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"     )return(void*)&this->mode     ;
          if(name == "indirect" )return(void*)&this->indirect ;
          if(name == "drawcount")return(void*)&this->drawcount;
          if(name == "stride"   )return(void*)&this->stride   ;
          return NULL;
        }
      public:
        MODE_TYPE      mode     ;
        INDIRECT_TYPE  indirect ;
        DRAWCOUNT_TYPE drawcount;
        STRIDE_TYPE    stride   ;
        MultiDrawArraysIndirect(
            MODE_TYPE      const&mode     ,
            INDIRECT_TYPE  const&indirect ,
            DRAWCOUNT_TYPE const&drawcount,
            STRIDE_TYPE    const&stride   ){
          this->mode      = mode     ;
          this->indirect  = indirect ;
          this->drawcount = drawcount;
          this->stride    = stride   ;
        }
        virtual~MultiDrawArraysIndirect(){}
        virtual void operator()(){
          glMultiDrawArraysIndirect(
            ge::core::convertTo<GLenum     >(this->mode     ),
            ge::core::convertTo<const void*>(this->indirect ),
            ge::core::convertTo<GLsizei    >(this->drawcount),
            ge::core::convertTo<GLsizei    >(this->stride   )
          );
        }
    };

    template<
      typename FIRST_TYPE    = GLuint       ,
      typename COUNT_TYPE    = GLsizei      ,
      typename TEXTURES_TYPE = const GLuint*>
    class BindImageTextures:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "first"   )return(void*)&this->first   ;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "textures")return(void*)&this->textures;
          return NULL;
        }
      public:
        FIRST_TYPE    first   ;
        COUNT_TYPE    count   ;
        TEXTURES_TYPE textures;
        BindImageTextures(
            FIRST_TYPE    const&first   ,
            COUNT_TYPE    const&count   ,
            TEXTURES_TYPE const&textures){
          this->first    = first   ;
          this->count    = count   ;
          this->textures = textures;
        }
        virtual~BindImageTextures(){}
        virtual void operator()(){
          glBindImageTextures(
            ge::core::convertTo<GLuint       >(this->first   ),
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->textures)
          );
        }
    };

    template<
      typename PIPELINE_TYPE = GLuint  ,
      typename BUFSIZE_TYPE  = GLsizei ,
      typename LENGTH_TYPE   = GLsizei*,
      typename INFOLOG_TYPE  = GLchar* >
    class GetProgramPipelineInfoLog:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pipeline")return(void*)&this->pipeline;
          if(name == "bufSize" )return(void*)&this->bufSize ;
          if(name == "length"  )return(void*)&this->length  ;
          if(name == "infoLog" )return(void*)&this->infoLog ;
          return NULL;
        }
      public:
        PIPELINE_TYPE pipeline;
        BUFSIZE_TYPE  bufSize ;
        LENGTH_TYPE   length  ;
        INFOLOG_TYPE  infoLog ;
        GetProgramPipelineInfoLog(
            PIPELINE_TYPE const&pipeline,
            BUFSIZE_TYPE  const&bufSize ,
            LENGTH_TYPE   const&length  ,
            INFOLOG_TYPE  const&infoLog ){
          this->pipeline = pipeline;
          this->bufSize  = bufSize ;
          this->length   = length  ;
          this->infoLog  = infoLog ;
        }
        virtual~GetProgramPipelineInfoLog(){}
        virtual void operator()(){
          glGetProgramPipelineInfoLog(
            ge::core::convertTo<GLuint  >(this->pipeline),
            ge::core::convertTo<GLsizei >(this->bufSize ),
            ge::core::convertTo<GLsizei*>(this->length  ),
            ge::core::convertTo<GLchar* >(this->infoLog )
          );
        }
    };

    template<
      typename RET_TYPE  = const GLubyte*,
      typename NAME_TYPE = GLenum        >
    class GetString:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret" )return(void*)&this->ret ;
          if(name == "name")return(void*)&this->name;
          return NULL;
        }
      public:
        RET_TYPE  ret ;
        NAME_TYPE name;
        GetString(
            RET_TYPE  const&ret ,
            NAME_TYPE const&name){
          this->ret  = ret ;
          this->name = name;
        }
        virtual~GetString(){}
        virtual void operator()(){
          ge::core::convertFrom<const GLubyte*>(this->ret,glGetString(
              ge::core::convertTo<GLenum        >(this->name))
          );
        }
    };

    template<
      typename INDEX_TYPE      = GLuint       ,
      typename TYPE_TYPE       = GLenum       ,
      typename NORMALIZED_TYPE = GLboolean    ,
      typename VALUE_TYPE      = const GLuint*>
    class VertexAttribP2uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"     )return(void*)&this->index     ;
          if(name == "type"      )return(void*)&this->type      ;
          if(name == "normalized")return(void*)&this->normalized;
          if(name == "value"     )return(void*)&this->value     ;
          return NULL;
        }
      public:
        INDEX_TYPE      index     ;
        TYPE_TYPE       type      ;
        NORMALIZED_TYPE normalized;
        VALUE_TYPE      value     ;
        VertexAttribP2uiv(
            INDEX_TYPE      const&index     ,
            TYPE_TYPE       const&type      ,
            NORMALIZED_TYPE const&normalized,
            VALUE_TYPE      const&value     ){
          this->index      = index     ;
          this->type       = type      ;
          this->normalized = normalized;
          this->value      = value     ;
        }
        virtual~VertexAttribP2uiv(){}
        virtual void operator()(){
          glVertexAttribP2uiv(
            ge::core::convertTo<GLuint       >(this->index     ),
            ge::core::convertTo<GLenum       >(this->type      ),
            ge::core::convertTo<GLboolean    >(this->normalized),
            ge::core::convertTo<const GLuint*>(this->value     )
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint,
      typename SHADER_TYPE  = GLuint>
    class DetachShader:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          if(name == "shader" )return(void*)&this->shader ;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        SHADER_TYPE  shader ;
        DetachShader(
            PROGRAM_TYPE const&program,
            SHADER_TYPE  const&shader ){
          this->program = program;
          this->shader  = shader ;
        }
        virtual~DetachShader(){}
        virtual void operator()(){
          glDetachShader(
            ge::core::convertTo<GLuint>(this->program),
            ge::core::convertTo<GLuint>(this->shader )
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class UniformMatrix3x4dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix3x4dv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix3x4dv(){}
        virtual void operator()(){
          glUniformMatrix3x4dv(
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum>
    class EndQuery:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        EndQuery(
            TARGET_TYPE const&target){
          this->target = target;
        }
        virtual~EndQuery(){}
        virtual void operator()(){
          glEndQuery(
            ge::core::convertTo<GLenum>(this->target)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAM_TYPE  = GLint >
    class FramebufferParameteri:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "param" )return(void*)&this->param ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAM_TYPE  param ;
        FramebufferParameteri(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAM_TYPE  const&param ){
          this->target = target;
          this->pname  = pname ;
          this->param  = param ;
        }
        virtual~FramebufferParameteri(){}
        virtual void operator()(){
          glFramebufferParameteri(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint >(this->param )
          );
        }
    };

    template<
      typename PROGRAM_TYPE          = GLuint  ,
      typename PROGRAMINTERFACE_TYPE = GLenum  ,
      typename INDEX_TYPE            = GLuint  ,
      typename BUFSIZE_TYPE          = GLsizei ,
      typename LENGTH_TYPE           = GLsizei*,
      typename NAME_TYPE             = GLchar* >
    class GetProgramResourceName:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"         )return(void*)&this->program         ;
          if(name == "programInterface")return(void*)&this->programInterface;
          if(name == "index"           )return(void*)&this->index           ;
          if(name == "bufSize"         )return(void*)&this->bufSize         ;
          if(name == "length"          )return(void*)&this->length          ;
          if(name == "name"            )return(void*)&this->name            ;
          return NULL;
        }
      public:
        PROGRAM_TYPE          program         ;
        PROGRAMINTERFACE_TYPE programInterface;
        INDEX_TYPE            index           ;
        BUFSIZE_TYPE          bufSize         ;
        LENGTH_TYPE           length          ;
        NAME_TYPE             name            ;
        GetProgramResourceName(
            PROGRAM_TYPE          const&program         ,
            PROGRAMINTERFACE_TYPE const&programInterface,
            INDEX_TYPE            const&index           ,
            BUFSIZE_TYPE          const&bufSize         ,
            LENGTH_TYPE           const&length          ,
            NAME_TYPE             const&name            ){
          this->program          = program         ;
          this->programInterface = programInterface;
          this->index            = index           ;
          this->bufSize          = bufSize         ;
          this->length           = length          ;
          this->name             = name            ;
        }
        virtual~GetProgramResourceName(){}
        virtual void operator()(){
          glGetProgramResourceName(
            ge::core::convertTo<GLuint  >(this->program         ),
            ge::core::convertTo<GLenum  >(this->programInterface),
            ge::core::convertTo<GLuint  >(this->index           ),
            ge::core::convertTo<GLsizei >(this->bufSize         ),
            ge::core::convertTo<GLsizei*>(this->length          ),
            ge::core::convertTo<GLchar* >(this->name            )
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class UniformMatrix4x3dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix4x3dv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix4x3dv(){}
        virtual void operator()(){
          glUniformMatrix4x3dv(
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename FIRST_TYPE = GLuint         ,
      typename COUNT_TYPE = GLsizei        ,
      typename V_TYPE     = const GLdouble*>
    class DepthRangeArrayv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "first")return(void*)&this->first;
          if(name == "count")return(void*)&this->count;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        FIRST_TYPE first;
        COUNT_TYPE count;
        V_TYPE     v    ;
        DepthRangeArrayv(
            FIRST_TYPE const&first,
            COUNT_TYPE const&count,
            V_TYPE     const&v    ){
          this->first = first;
          this->count = count;
          this->v     = v    ;
        }
        virtual~DepthRangeArrayv(){}
        virtual void operator()(){
          glDepthRangeArrayv(
            ge::core::convertTo<GLuint         >(this->first),
            ge::core::convertTo<GLsizei        >(this->count),
            ge::core::convertTo<const GLdouble*>(this->v    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLuint,
      typename Y_TYPE     = GLuint>
    class VertexAttribI2ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        VertexAttribI2ui(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
        }
        virtual~VertexAttribI2ui(){}
        virtual void operator()(){
          glVertexAttribI2ui(
            ge::core::convertTo<GLuint>(this->index),
            ge::core::convertTo<GLuint>(this->x    ),
            ge::core::convertTo<GLuint>(this->y    )
          );
        }
    };

    template<
      typename RET_TYPE              = GLint        ,
      typename PROGRAM_TYPE          = GLuint       ,
      typename PROGRAMINTERFACE_TYPE = GLenum       ,
      typename NAME_TYPE             = const GLchar*>
    class GetProgramResourceLocation:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"             )return(void*)&this->ret             ;
          if(name == "program"         )return(void*)&this->program         ;
          if(name == "programInterface")return(void*)&this->programInterface;
          if(name == "name"            )return(void*)&this->name            ;
          return NULL;
        }
      public:
        RET_TYPE              ret             ;
        PROGRAM_TYPE          program         ;
        PROGRAMINTERFACE_TYPE programInterface;
        NAME_TYPE             name            ;
        GetProgramResourceLocation(
            RET_TYPE              const&ret             ,
            PROGRAM_TYPE          const&program         ,
            PROGRAMINTERFACE_TYPE const&programInterface,
            NAME_TYPE             const&name            ){
          this->ret              = ret             ;
          this->program          = program         ;
          this->programInterface = programInterface;
          this->name             = name            ;
        }
        virtual~GetProgramResourceLocation(){}
        virtual void operator()(){
          ge::core::convertFrom<GLint>(this->ret,glGetProgramResourceLocation(
              ge::core::convertTo<GLuint       >(this->program         ),
              ge::core::convertTo<GLenum       >(this->programInterface),
              ge::core::convertTo<const GLchar*>(this->name            ))
          );
        }
    };

    template<
      typename N_TYPE        = GLsizei      ,
      typename TEXTURES_TYPE = const GLuint*>
    class DeleteTextures:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"       )return(void*)&this->n       ;
          if(name == "textures")return(void*)&this->textures;
          return NULL;
        }
      public:
        N_TYPE        n       ;
        TEXTURES_TYPE textures;
        DeleteTextures(
            N_TYPE        const&n       ,
            TEXTURES_TYPE const&textures){
          this->n        = n       ;
          this->textures = textures;
        }
        virtual~DeleteTextures(){}
        virtual void operator()(){
          glDeleteTextures(
            ge::core::convertTo<GLsizei      >(this->n       ),
            ge::core::convertTo<const GLuint*>(this->textures)
          );
        }
    };

    template<
      typename PROGRAM_TYPE     = GLuint,
      typename BUFFERINDEX_TYPE = GLuint,
      typename PNAME_TYPE       = GLenum,
      typename PARAMS_TYPE      = GLint*>
    class GetActiveAtomicCounterBufferiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"    )return(void*)&this->program    ;
          if(name == "bufferIndex")return(void*)&this->bufferIndex;
          if(name == "pname"      )return(void*)&this->pname      ;
          if(name == "params"     )return(void*)&this->params     ;
          return NULL;
        }
      public:
        PROGRAM_TYPE     program    ;
        BUFFERINDEX_TYPE bufferIndex;
        PNAME_TYPE       pname      ;
        PARAMS_TYPE      params     ;
        GetActiveAtomicCounterBufferiv(
            PROGRAM_TYPE     const&program    ,
            BUFFERINDEX_TYPE const&bufferIndex,
            PNAME_TYPE       const&pname      ,
            PARAMS_TYPE      const&params     ){
          this->program     = program    ;
          this->bufferIndex = bufferIndex;
          this->pname       = pname      ;
          this->params      = params     ;
        }
        virtual~GetActiveAtomicCounterBufferiv(){}
        virtual void operator()(){
          glGetActiveAtomicCounterBufferiv(
            ge::core::convertTo<GLuint>(this->program    ),
            ge::core::convertTo<GLuint>(this->bufferIndex),
            ge::core::convertTo<GLenum>(this->pname      ),
            ge::core::convertTo<GLint*>(this->params     )
          );
        }
    };

    template<
      typename FACE_TYPE   = GLenum,
      typename SFAIL_TYPE  = GLenum,
      typename DPFAIL_TYPE = GLenum,
      typename DPPASS_TYPE = GLenum>
    class StencilOpSeparate:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "face"  )return(void*)&this->face  ;
          if(name == "sfail" )return(void*)&this->sfail ;
          if(name == "dpfail")return(void*)&this->dpfail;
          if(name == "dppass")return(void*)&this->dppass;
          return NULL;
        }
      public:
        FACE_TYPE   face  ;
        SFAIL_TYPE  sfail ;
        DPFAIL_TYPE dpfail;
        DPPASS_TYPE dppass;
        StencilOpSeparate(
            FACE_TYPE   const&face  ,
            SFAIL_TYPE  const&sfail ,
            DPFAIL_TYPE const&dpfail,
            DPPASS_TYPE const&dppass){
          this->face   = face  ;
          this->sfail  = sfail ;
          this->dpfail = dpfail;
          this->dppass = dppass;
        }
        virtual~StencilOpSeparate(){}
        virtual void operator()(){
          glStencilOpSeparate(
            ge::core::convertTo<GLenum>(this->face  ),
            ge::core::convertTo<GLenum>(this->sfail ),
            ge::core::convertTo<GLenum>(this->dpfail),
            ge::core::convertTo<GLenum>(this->dppass)
          );
        }
    };

    template<
      typename N_TYPE   = GLsizei      ,
      typename IDS_TYPE = const GLuint*>
    class DeleteQueries:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"  )return(void*)&this->n  ;
          if(name == "ids")return(void*)&this->ids;
          return NULL;
        }
      public:
        N_TYPE   n  ;
        IDS_TYPE ids;
        DeleteQueries(
            N_TYPE   const&n  ,
            IDS_TYPE const&ids){
          this->n   = n  ;
          this->ids = ids;
        }
        virtual~DeleteQueries(){}
        virtual void operator()(){
          glDeleteQueries(
            ge::core::convertTo<GLsizei      >(this->n  ),
            ge::core::convertTo<const GLuint*>(this->ids)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat,
      typename Y_TYPE     = GLfloat,
      typename Z_TYPE     = GLfloat,
      typename W_TYPE     = GLfloat>
    class VertexAttrib4f:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          if(name == "w"    )return(void*)&this->w    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        W_TYPE     w    ;
        VertexAttrib4f(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ,
            W_TYPE     const&w    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
          this->w     = w    ;
        }
        virtual~VertexAttrib4f(){}
        virtual void operator()(){
          glVertexAttrib4f(
            ge::core::convertTo<GLuint >(this->index),
            ge::core::convertTo<GLfloat>(this->x    ),
            ge::core::convertTo<GLfloat>(this->y    ),
            ge::core::convertTo<GLfloat>(this->z    ),
            ge::core::convertTo<GLfloat>(this->w    )
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename PNAME_TYPE       = GLenum,
      typename PARAM_TYPE       = GLint >
    class NamedFramebufferParameteri:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "pname"      )return(void*)&this->pname      ;
          if(name == "param"      )return(void*)&this->param      ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE framebuffer;
        PNAME_TYPE       pname      ;
        PARAM_TYPE       param      ;
        NamedFramebufferParameteri(
            FRAMEBUFFER_TYPE const&framebuffer,
            PNAME_TYPE       const&pname      ,
            PARAM_TYPE       const&param      ){
          this->framebuffer = framebuffer;
          this->pname       = pname      ;
          this->param       = param      ;
        }
        virtual~NamedFramebufferParameteri(){}
        virtual void operator()(){
          glNamedFramebufferParameteri(
            ge::core::convertTo<GLuint>(this->framebuffer),
            ge::core::convertTo<GLenum>(this->pname      ),
            ge::core::convertTo<GLint >(this->param      )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    class ViewportIndexedfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        ViewportIndexedfv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~ViewportIndexedfv(){}
        virtual void operator()(){
          glViewportIndexedfv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLfloat*>(this->v    )
          );
        }
    };

    template<
      typename TARGET_TYPE  = GLenum       ,
      typename FIRST_TYPE   = GLuint       ,
      typename COUNT_TYPE   = GLsizei      ,
      typename BUFFERS_TYPE = const GLuint*>
    class BindBuffersBase:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target" )return(void*)&this->target ;
          if(name == "first"  )return(void*)&this->first  ;
          if(name == "count"  )return(void*)&this->count  ;
          if(name == "buffers")return(void*)&this->buffers;
          return NULL;
        }
      public:
        TARGET_TYPE  target ;
        FIRST_TYPE   first  ;
        COUNT_TYPE   count  ;
        BUFFERS_TYPE buffers;
        BindBuffersBase(
            TARGET_TYPE  const&target ,
            FIRST_TYPE   const&first  ,
            COUNT_TYPE   const&count  ,
            BUFFERS_TYPE const&buffers){
          this->target  = target ;
          this->first   = first  ;
          this->count   = count  ;
          this->buffers = buffers;
        }
        virtual~BindBuffersBase(){}
        virtual void operator()(){
          glBindBuffersBase(
            ge::core::convertTo<GLenum       >(this->target ),
            ge::core::convertTo<GLuint       >(this->first  ),
            ge::core::convertTo<GLsizei      >(this->count  ),
            ge::core::convertTo<const GLuint*>(this->buffers)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    class VertexAttribL4dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribL4dv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribL4dv(){}
        virtual void operator()(){
          glVertexAttribL4dv(
            ge::core::convertTo<GLuint         >(this->index),
            ge::core::convertTo<const GLdouble*>(this->v    )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetTexParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetTexParameteriv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetTexParameteriv(){}
        virtual void operator()(){
          glGetTexParameteriv(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    template<
      typename N_TYPE      = GLsizei,
      typename ARRAYS_TYPE = GLuint*>
    class CreateVertexArrays:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"     )return(void*)&this->n     ;
          if(name == "arrays")return(void*)&this->arrays;
          return NULL;
        }
      public:
        N_TYPE      n     ;
        ARRAYS_TYPE arrays;
        CreateVertexArrays(
            N_TYPE      const&n     ,
            ARRAYS_TYPE const&arrays){
          this->n      = n     ;
          this->arrays = arrays;
        }
        virtual~CreateVertexArrays(){}
        virtual void operator()(){
          glCreateVertexArrays(
            ge::core::convertTo<GLsizei>(this->n     ),
            ge::core::convertTo<GLuint*>(this->arrays)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint         ,
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    class ProgramUniform1dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform1dv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform1dv(){}
        virtual void operator()(){
          glProgramUniform1dv(
            ge::core::convertTo<GLuint         >(this->program ),
            ge::core::convertTo<GLint          >(this->location),
            ge::core::convertTo<GLsizei        >(this->count   ),
            ge::core::convertTo<const GLdouble*>(this->value   )
          );
        }
    };

    template<
      typename ID_TYPE   = GLuint,
      typename MODE_TYPE = GLenum>
    class BeginConditionalRender:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "id"  )return(void*)&this->id  ;
          if(name == "mode")return(void*)&this->mode;
          return NULL;
        }
      public:
        ID_TYPE   id  ;
        MODE_TYPE mode;
        BeginConditionalRender(
            ID_TYPE   const&id  ,
            MODE_TYPE const&mode){
          this->id   = id  ;
          this->mode = mode;
        }
        virtual~BeginConditionalRender(){}
        virtual void operator()(){
          glBeginConditionalRender(
            ge::core::convertTo<GLuint>(this->id  ),
            ge::core::convertTo<GLenum>(this->mode)
          );
        }
    };

    template<
      typename MODE_TYPE       = GLenum     ,
      typename COUNT_TYPE      = GLsizei    ,
      typename TYPE_TYPE       = GLenum     ,
      typename INDICES_TYPE    = const void*,
      typename BASEVERTEX_TYPE = GLint      >
    class DrawElementsBaseVertex:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"      )return(void*)&this->mode      ;
          if(name == "count"     )return(void*)&this->count     ;
          if(name == "type"      )return(void*)&this->type      ;
          if(name == "indices"   )return(void*)&this->indices   ;
          if(name == "basevertex")return(void*)&this->basevertex;
          return NULL;
        }
      public:
        MODE_TYPE       mode      ;
        COUNT_TYPE      count     ;
        TYPE_TYPE       type      ;
        INDICES_TYPE    indices   ;
        BASEVERTEX_TYPE basevertex;
        DrawElementsBaseVertex(
            MODE_TYPE       const&mode      ,
            COUNT_TYPE      const&count     ,
            TYPE_TYPE       const&type      ,
            INDICES_TYPE    const&indices   ,
            BASEVERTEX_TYPE const&basevertex){
          this->mode       = mode      ;
          this->count      = count     ;
          this->type       = type      ;
          this->indices    = indices   ;
          this->basevertex = basevertex;
        }
        virtual~DrawElementsBaseVertex(){}
        virtual void operator()(){
          glDrawElementsBaseVertex(
            ge::core::convertTo<GLenum     >(this->mode      ),
            ge::core::convertTo<GLsizei    >(this->count     ),
            ge::core::convertTo<GLenum     >(this->type      ),
            ge::core::convertTo<const void*>(this->indices   ),
            ge::core::convertTo<GLint      >(this->basevertex)
          );
        }
    };

    template<
      typename VALUE_TYPE  = GLfloat  ,
      typename INVERT_TYPE = GLboolean>
    class SampleCoverage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "value" )return(void*)&this->value ;
          if(name == "invert")return(void*)&this->invert;
          return NULL;
        }
      public:
        VALUE_TYPE  value ;
        INVERT_TYPE invert;
        SampleCoverage(
            VALUE_TYPE  const&value ,
            INVERT_TYPE const&invert){
          this->value  = value ;
          this->invert = invert;
        }
        virtual~SampleCoverage(){}
        virtual void operator()(){
          glSampleCoverage(
            ge::core::convertTo<GLfloat  >(this->value ),
            ge::core::convertTo<GLboolean>(this->invert)
          );
        }
    };

    template<
      typename SAMPLER_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAM_TYPE   = GLint >
    class SamplerParameteri:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sampler")return(void*)&this->sampler;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "param"  )return(void*)&this->param  ;
          return NULL;
        }
      public:
        SAMPLER_TYPE sampler;
        PNAME_TYPE   pname  ;
        PARAM_TYPE   param  ;
        SamplerParameteri(
            SAMPLER_TYPE const&sampler,
            PNAME_TYPE   const&pname  ,
            PARAM_TYPE   const&param  ){
          this->sampler = sampler;
          this->pname   = pname  ;
          this->param   = param  ;
        }
        virtual~SamplerParameteri(){}
        virtual void operator()(){
          glSamplerParameteri(
            ge::core::convertTo<GLuint>(this->sampler),
            ge::core::convertTo<GLenum>(this->pname  ),
            ge::core::convertTo<GLint >(this->param  )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename OFFSET_TYPE         = GLintptr   ,
      typename SIZE_TYPE           = GLsizeiptr ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename DATA_TYPE           = const void*>
    class ClearBufferSubData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "offset"        )return(void*)&this->offset        ;
          if(name == "size"          )return(void*)&this->size          ;
          if(name == "format"        )return(void*)&this->format        ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "data"          )return(void*)&this->data          ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        INTERNALFORMAT_TYPE internalformat;
        OFFSET_TYPE         offset        ;
        SIZE_TYPE           size          ;
        FORMAT_TYPE         format        ;
        TYPE_TYPE           type          ;
        DATA_TYPE           data          ;
        ClearBufferSubData(
            TARGET_TYPE         const&target        ,
            INTERNALFORMAT_TYPE const&internalformat,
            OFFSET_TYPE         const&offset        ,
            SIZE_TYPE           const&size          ,
            FORMAT_TYPE         const&format        ,
            TYPE_TYPE           const&type          ,
            DATA_TYPE           const&data          ){
          this->target         = target        ;
          this->internalformat = internalformat;
          this->offset         = offset        ;
          this->size           = size          ;
          this->format         = format        ;
          this->type           = type          ;
          this->data           = data          ;
        }
        virtual~ClearBufferSubData(){}
        virtual void operator()(){
          glClearBufferSubData(
            ge::core::convertTo<GLenum     >(this->target        ),
            ge::core::convertTo<GLenum     >(this->internalformat),
            ge::core::convertTo<GLintptr   >(this->offset        ),
            ge::core::convertTo<GLsizeiptr >(this->size          ),
            ge::core::convertTo<GLenum     >(this->format        ),
            ge::core::convertTo<GLenum     >(this->type          ),
            ge::core::convertTo<const void*>(this->data          )
          );
        }
    };

    template<
      typename SAMPLER_TYPE = GLuint ,
      typename PNAME_TYPE   = GLenum ,
      typename PARAM_TYPE   = GLfloat>
    class SamplerParameterf:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sampler")return(void*)&this->sampler;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "param"  )return(void*)&this->param  ;
          return NULL;
        }
      public:
        SAMPLER_TYPE sampler;
        PNAME_TYPE   pname  ;
        PARAM_TYPE   param  ;
        SamplerParameterf(
            SAMPLER_TYPE const&sampler,
            PNAME_TYPE   const&pname  ,
            PARAM_TYPE   const&param  ){
          this->sampler = sampler;
          this->pname   = pname  ;
          this->param   = param  ;
        }
        virtual~SamplerParameterf(){}
        virtual void operator()(){
          glSamplerParameterf(
            ge::core::convertTo<GLuint >(this->sampler),
            ge::core::convertTo<GLenum >(this->pname  ),
            ge::core::convertTo<GLfloat>(this->param  )
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE = GLuint       ,
      typename BUFFER_TYPE      = GLenum       ,
      typename DRAWBUFFER_TYPE  = GLint        ,
      typename VALUE_TYPE       = const GLuint*>
    class ClearNamedFramebufferuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "buffer"     )return(void*)&this->buffer     ;
          if(name == "drawbuffer" )return(void*)&this->drawbuffer ;
          if(name == "value"      )return(void*)&this->value      ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE framebuffer;
        BUFFER_TYPE      buffer     ;
        DRAWBUFFER_TYPE  drawbuffer ;
        VALUE_TYPE       value      ;
        ClearNamedFramebufferuiv(
            FRAMEBUFFER_TYPE const&framebuffer,
            BUFFER_TYPE      const&buffer     ,
            DRAWBUFFER_TYPE  const&drawbuffer ,
            VALUE_TYPE       const&value      ){
          this->framebuffer = framebuffer;
          this->buffer      = buffer     ;
          this->drawbuffer  = drawbuffer ;
          this->value       = value      ;
        }
        virtual~ClearNamedFramebufferuiv(){}
        virtual void operator()(){
          glClearNamedFramebufferuiv(
            ge::core::convertTo<GLuint       >(this->framebuffer),
            ge::core::convertTo<GLenum       >(this->buffer     ),
            ge::core::convertTo<GLint        >(this->drawbuffer ),
            ge::core::convertTo<const GLuint*>(this->value      )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat>
    class Uniform1f:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        Uniform1f(
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ){
          this->location = location;
          this->v0       = v0      ;
        }
        virtual~Uniform1f(){}
        virtual void operator()(){
          glUniform1f(
            ge::core::convertTo<GLint  >(this->location),
            ge::core::convertTo<GLfloat>(this->v0      )
          );
        }
    };

    template<
      typename INDEX_TYPE  = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLfloat*>
    class GetVertexAttribfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index" )return(void*)&this->index ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        INDEX_TYPE  index ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetVertexAttribfv(
            INDEX_TYPE  const&index ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->index  = index ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetVertexAttribfv(){}
        virtual void operator()(){
          glGetVertexAttribfv(
            ge::core::convertTo<GLuint  >(this->index ),
            ge::core::convertTo<GLenum  >(this->pname ),
            ge::core::convertTo<GLfloat*>(this->params)
          );
        }
    };

    template<
      typename NUM_GROUPS_X_TYPE = GLuint,
      typename NUM_GROUPS_Y_TYPE = GLuint,
      typename NUM_GROUPS_Z_TYPE = GLuint>
    class DispatchCompute:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "num_groups_x")return(void*)&this->num_groups_x;
          if(name == "num_groups_y")return(void*)&this->num_groups_y;
          if(name == "num_groups_z")return(void*)&this->num_groups_z;
          return NULL;
        }
      public:
        NUM_GROUPS_X_TYPE num_groups_x;
        NUM_GROUPS_Y_TYPE num_groups_y;
        NUM_GROUPS_Z_TYPE num_groups_z;
        DispatchCompute(
            NUM_GROUPS_X_TYPE const&num_groups_x,
            NUM_GROUPS_Y_TYPE const&num_groups_y,
            NUM_GROUPS_Z_TYPE const&num_groups_z){
          this->num_groups_x = num_groups_x;
          this->num_groups_y = num_groups_y;
          this->num_groups_z = num_groups_z;
        }
        virtual~DispatchCompute(){}
        virtual void operator()(){
          glDispatchCompute(
            ge::core::convertTo<GLuint>(this->num_groups_x),
            ge::core::convertTo<GLuint>(this->num_groups_y),
            ge::core::convertTo<GLuint>(this->num_groups_z)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename LEVEL_TYPE  = GLint ,
      typename IMG_TYPE    = void* >
    class GetCompressedTexImage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "level" )return(void*)&this->level ;
          if(name == "img"   )return(void*)&this->img   ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        LEVEL_TYPE  level ;
        IMG_TYPE    img   ;
        GetCompressedTexImage(
            TARGET_TYPE const&target,
            LEVEL_TYPE  const&level ,
            IMG_TYPE    const&img   ){
          this->target = target;
          this->level  = level ;
          this->img    = img   ;
        }
        virtual~GetCompressedTexImage(){}
        virtual void operator()(){
          glGetCompressedTexImage(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLint >(this->level ),
            ge::core::convertTo<void* >(this->img   )
          );
        }
    };

    template<
      typename TARGET_TYPE  = GLenum ,
      typename LOD_TYPE     = GLint  ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    class GetnCompressedTexImage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target" )return(void*)&this->target ;
          if(name == "lod"    )return(void*)&this->lod    ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "pixels" )return(void*)&this->pixels ;
          return NULL;
        }
      public:
        TARGET_TYPE  target ;
        LOD_TYPE     lod    ;
        BUFSIZE_TYPE bufSize;
        PIXELS_TYPE  pixels ;
        GetnCompressedTexImage(
            TARGET_TYPE  const&target ,
            LOD_TYPE     const&lod    ,
            BUFSIZE_TYPE const&bufSize,
            PIXELS_TYPE  const&pixels ){
          this->target  = target ;
          this->lod     = lod    ;
          this->bufSize = bufSize;
          this->pixels  = pixels ;
        }
        virtual~GetnCompressedTexImage(){}
        virtual void operator()(){
          glGetnCompressedTexImage(
            ge::core::convertTo<GLenum >(this->target ),
            ge::core::convertTo<GLint  >(this->lod    ),
            ge::core::convertTo<GLsizei>(this->bufSize),
            ge::core::convertTo<void*  >(this->pixels )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint,
      typename V0_TYPE       = GLint>
    class Uniform1i:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        Uniform1i(
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ){
          this->location = location;
          this->v0       = v0      ;
        }
        virtual~Uniform1i(){}
        virtual void operator()(){
          glUniform1i(
            ge::core::convertTo<GLint>(this->location),
            ge::core::convertTo<GLint>(this->v0      )
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint  ,
      typename INDEX_TYPE   = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename SIZE_TYPE    = GLint*  ,
      typename TYPE_TYPE    = GLenum* ,
      typename NAME_TYPE    = GLchar* >
    class GetActiveAttrib:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          if(name == "index"  )return(void*)&this->index  ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "length" )return(void*)&this->length ;
          if(name == "size"   )return(void*)&this->size   ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "name"   )return(void*)&this->name   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        INDEX_TYPE   index  ;
        BUFSIZE_TYPE bufSize;
        LENGTH_TYPE  length ;
        SIZE_TYPE    size   ;
        TYPE_TYPE    type   ;
        NAME_TYPE    name   ;
        GetActiveAttrib(
            PROGRAM_TYPE const&program,
            INDEX_TYPE   const&index  ,
            BUFSIZE_TYPE const&bufSize,
            LENGTH_TYPE  const&length ,
            SIZE_TYPE    const&size   ,
            TYPE_TYPE    const&type   ,
            NAME_TYPE    const&name   ){
          this->program = program;
          this->index   = index  ;
          this->bufSize = bufSize;
          this->length  = length ;
          this->size    = size   ;
          this->type    = type   ;
          this->name    = name   ;
        }
        virtual~GetActiveAttrib(){}
        virtual void operator()(){
          glGetActiveAttrib(
            ge::core::convertTo<GLuint  >(this->program),
            ge::core::convertTo<GLuint  >(this->index  ),
            ge::core::convertTo<GLsizei >(this->bufSize),
            ge::core::convertTo<GLsizei*>(this->length ),
            ge::core::convertTo<GLint*  >(this->size   ),
            ge::core::convertTo<GLenum* >(this->type   ),
            ge::core::convertTo<GLchar* >(this->name   )
          );
        }
    };

    template<
      typename TARGET_TYPE  = GLenum     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    class TexSubImage2D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target" )return(void*)&this->target ;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "yoffset")return(void*)&this->yoffset;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          if(name == "format" )return(void*)&this->format ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "pixels" )return(void*)&this->pixels ;
          return NULL;
        }
      public:
        TARGET_TYPE  target ;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        YOFFSET_TYPE yoffset;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        FORMAT_TYPE  format ;
        TYPE_TYPE    type   ;
        PIXELS_TYPE  pixels ;
        TexSubImage2D(
            TARGET_TYPE  const&target ,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            YOFFSET_TYPE const&yoffset,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ,
            FORMAT_TYPE  const&format ,
            TYPE_TYPE    const&type   ,
            PIXELS_TYPE  const&pixels ){
          this->target  = target ;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->yoffset = yoffset;
          this->width   = width  ;
          this->height  = height ;
          this->format  = format ;
          this->type    = type   ;
          this->pixels  = pixels ;
        }
        virtual~TexSubImage2D(){}
        virtual void operator()(){
          glTexSubImage2D(
            ge::core::convertTo<GLenum     >(this->target ),
            ge::core::convertTo<GLint      >(this->level  ),
            ge::core::convertTo<GLint      >(this->xoffset),
            ge::core::convertTo<GLint      >(this->yoffset),
            ge::core::convertTo<GLsizei    >(this->width  ),
            ge::core::convertTo<GLsizei    >(this->height ),
            ge::core::convertTo<GLenum     >(this->format ),
            ge::core::convertTo<GLenum     >(this->type   ),
            ge::core::convertTo<const void*>(this->pixels )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename PARAMS_TYPE   = GLint*>
    class GetUniformiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "params"  )return(void*)&this->params  ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        PARAMS_TYPE   params  ;
        GetUniformiv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            PARAMS_TYPE   const&params  ){
          this->program  = program ;
          this->location = location;
          this->params   = params  ;
        }
        virtual~GetUniformiv(){}
        virtual void operator()(){
          glGetUniformiv(
            ge::core::convertTo<GLuint>(this->program ),
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLint*>(this->params  )
          );
        }
    };

    template<
      typename BUFFER_TYPE     = GLenum        ,
      typename DRAWBUFFER_TYPE = GLint         ,
      typename VALUE_TYPE      = const GLfloat*>
    class ClearBufferfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer"    )return(void*)&this->buffer    ;
          if(name == "drawbuffer")return(void*)&this->drawbuffer;
          if(name == "value"     )return(void*)&this->value     ;
          return NULL;
        }
      public:
        BUFFER_TYPE     buffer    ;
        DRAWBUFFER_TYPE drawbuffer;
        VALUE_TYPE      value     ;
        ClearBufferfv(
            BUFFER_TYPE     const&buffer    ,
            DRAWBUFFER_TYPE const&drawbuffer,
            VALUE_TYPE      const&value     ){
          this->buffer     = buffer    ;
          this->drawbuffer = drawbuffer;
          this->value      = value     ;
        }
        virtual~ClearBufferfv(){}
        virtual void operator()(){
          glClearBufferfv(
            ge::core::convertTo<GLenum        >(this->buffer    ),
            ge::core::convertTo<GLint         >(this->drawbuffer),
            ge::core::convertTo<const GLfloat*>(this->value     )
          );
        }
    };

    template<
      typename OPCODE_TYPE = GLenum>
    class LogicOp:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "opcode")return(void*)&this->opcode;
          return NULL;
        }
      public:
        OPCODE_TYPE opcode;
        LogicOp(
            OPCODE_TYPE const&opcode){
          this->opcode = opcode;
        }
        virtual~LogicOp(){}
        virtual void operator()(){
          glLogicOp(
            ge::core::convertTo<GLenum>(this->opcode)
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class ProgramUniformMatrix3x4fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix3x4fv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix3x4fv(){}
        virtual void operator()(){
          glProgramUniformMatrix3x4fv(
            ge::core::convertTo<GLuint        >(this->program  ),
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename PNAME_TYPE   = GLenum ,
      typename PARAMS_TYPE  = GLuint*>
    class GetTextureParameterIuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        GetTextureParameterIuiv(
            TEXTURE_TYPE const&texture,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->texture = texture;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~GetTextureParameterIuiv(){}
        virtual void operator()(){
          glGetTextureParameterIuiv(
            ge::core::convertTo<GLuint >(this->texture),
            ge::core::convertTo<GLenum >(this->pname  ),
            ge::core::convertTo<GLuint*>(this->params )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint       ,
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    class ProgramUniform4uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform4uiv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform4uiv(){}
        virtual void operator()(){
          glProgramUniform4uiv(
            ge::core::convertTo<GLuint       >(this->program ),
            ge::core::convertTo<GLint        >(this->location),
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->value   )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint,
      typename V2_TYPE       = GLuint,
      typename V3_TYPE       = GLuint>
    class Uniform4ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          if(name == "v3"      )return(void*)&this->v3      ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        V3_TYPE       v3      ;
        Uniform4ui(
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ,
            V3_TYPE       const&v3      ){
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
          this->v3       = v3      ;
        }
        virtual~Uniform4ui(){}
        virtual void operator()(){
          glUniform4ui(
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLuint>(this->v0      ),
            ge::core::convertTo<GLuint>(this->v1      ),
            ge::core::convertTo<GLuint>(this->v2      ),
            ge::core::convertTo<GLuint>(this->v3      )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei>
    class CopyTextureSubImage2D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "yoffset")return(void*)&this->yoffset;
          if(name == "x"      )return(void*)&this->x      ;
          if(name == "y"      )return(void*)&this->y      ;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        YOFFSET_TYPE yoffset;
        X_TYPE       x      ;
        Y_TYPE       y      ;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        CopyTextureSubImage2D(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            YOFFSET_TYPE const&yoffset,
            X_TYPE       const&x      ,
            Y_TYPE       const&y      ,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ){
          this->texture = texture;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->yoffset = yoffset;
          this->x       = x      ;
          this->y       = y      ;
          this->width   = width  ;
          this->height  = height ;
        }
        virtual~CopyTextureSubImage2D(){}
        virtual void operator()(){
          glCopyTextureSubImage2D(
            ge::core::convertTo<GLuint >(this->texture),
            ge::core::convertTo<GLint  >(this->level  ),
            ge::core::convertTo<GLint  >(this->xoffset),
            ge::core::convertTo<GLint  >(this->yoffset),
            ge::core::convertTo<GLint  >(this->x      ),
            ge::core::convertTo<GLint  >(this->y      ),
            ge::core::convertTo<GLsizei>(this->width  ),
            ge::core::convertTo<GLsizei>(this->height )
          );
        }
    };

    template<
      typename TARGET_TYPE      = GLenum,
      typename FRAMEBUFFER_TYPE = GLuint>
    class BindFramebuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"     )return(void*)&this->target     ;
          if(name == "framebuffer")return(void*)&this->framebuffer;
          return NULL;
        }
      public:
        TARGET_TYPE      target     ;
        FRAMEBUFFER_TYPE framebuffer;
        BindFramebuffer(
            TARGET_TYPE      const&target     ,
            FRAMEBUFFER_TYPE const&framebuffer){
          this->target      = target     ;
          this->framebuffer = framebuffer;
        }
        virtual~BindFramebuffer(){}
        virtual void operator()(){
          glBindFramebuffer(
            ge::core::convertTo<GLenum>(this->target     ),
            ge::core::convertTo<GLuint>(this->framebuffer)
          );
        }
    };

    template<
      typename MODE_TYPE = GLenum>
    class CullFace:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode")return(void*)&this->mode;
          return NULL;
        }
      public:
        MODE_TYPE mode;
        CullFace(
            MODE_TYPE const&mode){
          this->mode = mode;
        }
        virtual~CullFace(){}
        virtual void operator()(){
          glCullFace(
            ge::core::convertTo<GLenum>(this->mode)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLint ,
      typename V1_TYPE       = GLint ,
      typename V2_TYPE       = GLint ,
      typename V3_TYPE       = GLint >
    class ProgramUniform4i:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          if(name == "v3"      )return(void*)&this->v3      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        V3_TYPE       v3      ;
        ProgramUniform4i(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ,
            V3_TYPE       const&v3      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
          this->v3       = v3      ;
        }
        virtual~ProgramUniform4i(){}
        virtual void operator()(){
          glProgramUniform4i(
            ge::core::convertTo<GLuint>(this->program ),
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLint >(this->v0      ),
            ge::core::convertTo<GLint >(this->v1      ),
            ge::core::convertTo<GLint >(this->v2      ),
            ge::core::convertTo<GLint >(this->v3      )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat,
      typename V2_TYPE       = GLfloat,
      typename V3_TYPE       = GLfloat>
    class ProgramUniform4f:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          if(name == "v3"      )return(void*)&this->v3      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        V3_TYPE       v3      ;
        ProgramUniform4f(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ,
            V3_TYPE       const&v3      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
          this->v3       = v3      ;
        }
        virtual~ProgramUniform4f(){}
        virtual void operator()(){
          glProgramUniform4f(
            ge::core::convertTo<GLuint >(this->program ),
            ge::core::convertTo<GLint  >(this->location),
            ge::core::convertTo<GLfloat>(this->v0      ),
            ge::core::convertTo<GLfloat>(this->v1      ),
            ge::core::convertTo<GLfloat>(this->v2      ),
            ge::core::convertTo<GLfloat>(this->v3      )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat,
      typename Y_TYPE     = GLfloat,
      typename W_TYPE     = GLfloat,
      typename H_TYPE     = GLfloat>
    class ViewportIndexedf:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "w"    )return(void*)&this->w    ;
          if(name == "h"    )return(void*)&this->h    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        W_TYPE     w    ;
        H_TYPE     h    ;
        ViewportIndexedf(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            W_TYPE     const&w    ,
            H_TYPE     const&h    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->w     = w    ;
          this->h     = h    ;
        }
        virtual~ViewportIndexedf(){}
        virtual void operator()(){
          glViewportIndexedf(
            ge::core::convertTo<GLuint >(this->index),
            ge::core::convertTo<GLfloat>(this->x    ),
            ge::core::convertTo<GLfloat>(this->y    ),
            ge::core::convertTo<GLfloat>(this->w    ),
            ge::core::convertTo<GLfloat>(this->h    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename V0_TYPE       = GLdouble,
      typename V1_TYPE       = GLdouble,
      typename V2_TYPE       = GLdouble,
      typename V3_TYPE       = GLdouble>
    class ProgramUniform4d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          if(name == "v3"      )return(void*)&this->v3      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        V3_TYPE       v3      ;
        ProgramUniform4d(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ,
            V3_TYPE       const&v3      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
          this->v3       = v3      ;
        }
        virtual~ProgramUniform4d(){}
        virtual void operator()(){
          glProgramUniform4d(
            ge::core::convertTo<GLuint  >(this->program ),
            ge::core::convertTo<GLint   >(this->location),
            ge::core::convertTo<GLdouble>(this->v0      ),
            ge::core::convertTo<GLdouble>(this->v1      ),
            ge::core::convertTo<GLdouble>(this->v2      ),
            ge::core::convertTo<GLdouble>(this->v3      )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint      ,
      typename PNAME_TYPE   = GLenum      ,
      typename PARAMS_TYPE  = const GLint*>
    class TextureParameterIiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        TextureParameterIiv(
            TEXTURE_TYPE const&texture,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->texture = texture;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~TextureParameterIiv(){}
        virtual void operator()(){
          glTextureParameterIiv(
            ge::core::convertTo<GLuint      >(this->texture),
            ge::core::convertTo<GLenum      >(this->pname  ),
            ge::core::convertTo<const GLint*>(this->params )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    class VertexAttribI2uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribI2uiv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribI2uiv(){}
        virtual void operator()(){
          glVertexAttribI2uiv(
            ge::core::convertTo<GLuint       >(this->index),
            ge::core::convertTo<const GLuint*>(this->v    )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    class TextureSubImage2D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "yoffset")return(void*)&this->yoffset;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          if(name == "format" )return(void*)&this->format ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "pixels" )return(void*)&this->pixels ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        YOFFSET_TYPE yoffset;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        FORMAT_TYPE  format ;
        TYPE_TYPE    type   ;
        PIXELS_TYPE  pixels ;
        TextureSubImage2D(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            YOFFSET_TYPE const&yoffset,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ,
            FORMAT_TYPE  const&format ,
            TYPE_TYPE    const&type   ,
            PIXELS_TYPE  const&pixels ){
          this->texture = texture;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->yoffset = yoffset;
          this->width   = width  ;
          this->height  = height ;
          this->format  = format ;
          this->type    = type   ;
          this->pixels  = pixels ;
        }
        virtual~TextureSubImage2D(){}
        virtual void operator()(){
          glTextureSubImage2D(
            ge::core::convertTo<GLuint     >(this->texture),
            ge::core::convertTo<GLint      >(this->level  ),
            ge::core::convertTo<GLint      >(this->xoffset),
            ge::core::convertTo<GLint      >(this->yoffset),
            ge::core::convertTo<GLsizei    >(this->width  ),
            ge::core::convertTo<GLsizei    >(this->height ),
            ge::core::convertTo<GLenum     >(this->format ),
            ge::core::convertTo<GLenum     >(this->type   ),
            ge::core::convertTo<const void*>(this->pixels )
          );
        }
    };

    template<
      typename INDEX_TYPE  = GLuint ,
      typename LEFT_TYPE   = GLint  ,
      typename BOTTOM_TYPE = GLint  ,
      typename WIDTH_TYPE  = GLsizei,
      typename HEIGHT_TYPE = GLsizei>
    class ScissorIndexed:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index" )return(void*)&this->index ;
          if(name == "left"  )return(void*)&this->left  ;
          if(name == "bottom")return(void*)&this->bottom;
          if(name == "width" )return(void*)&this->width ;
          if(name == "height")return(void*)&this->height;
          return NULL;
        }
      public:
        INDEX_TYPE  index ;
        LEFT_TYPE   left  ;
        BOTTOM_TYPE bottom;
        WIDTH_TYPE  width ;
        HEIGHT_TYPE height;
        ScissorIndexed(
            INDEX_TYPE  const&index ,
            LEFT_TYPE   const&left  ,
            BOTTOM_TYPE const&bottom,
            WIDTH_TYPE  const&width ,
            HEIGHT_TYPE const&height){
          this->index  = index ;
          this->left   = left  ;
          this->bottom = bottom;
          this->width  = width ;
          this->height = height;
        }
        virtual~ScissorIndexed(){}
        virtual void operator()(){
          glScissorIndexed(
            ge::core::convertTo<GLuint >(this->index ),
            ge::core::convertTo<GLint  >(this->left  ),
            ge::core::convertTo<GLint  >(this->bottom),
            ge::core::convertTo<GLsizei>(this->width ),
            ge::core::convertTo<GLsizei>(this->height)
          );
        }
    };

    template<
      typename MODE_TYPE   = GLenum,
      typename ID_TYPE     = GLuint,
      typename STREAM_TYPE = GLuint>
    class DrawTransformFeedbackStream:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"  )return(void*)&this->mode  ;
          if(name == "id"    )return(void*)&this->id    ;
          if(name == "stream")return(void*)&this->stream;
          return NULL;
        }
      public:
        MODE_TYPE   mode  ;
        ID_TYPE     id    ;
        STREAM_TYPE stream;
        DrawTransformFeedbackStream(
            MODE_TYPE   const&mode  ,
            ID_TYPE     const&id    ,
            STREAM_TYPE const&stream){
          this->mode   = mode  ;
          this->id     = id    ;
          this->stream = stream;
        }
        virtual~DrawTransformFeedbackStream(){}
        virtual void operator()(){
          glDrawTransformFeedbackStream(
            ge::core::convertTo<GLenum>(this->mode  ),
            ge::core::convertTo<GLuint>(this->id    ),
            ge::core::convertTo<GLuint>(this->stream)
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint,
      typename SHADER_TYPE  = GLuint>
    class AttachShader:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          if(name == "shader" )return(void*)&this->shader ;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        SHADER_TYPE  shader ;
        AttachShader(
            PROGRAM_TYPE const&program,
            SHADER_TYPE  const&shader ){
          this->program = program;
          this->shader  = shader ;
        }
        virtual~AttachShader(){}
        virtual void operator()(){
          glAttachShader(
            ge::core::convertTo<GLuint>(this->program),
            ge::core::convertTo<GLuint>(this->shader )
          );
        }
    };

    template<
      typename TEXTURE_TYPE        = GLuint,
      typename INTERNALFORMAT_TYPE = GLenum,
      typename BUFFER_TYPE         = GLuint>
    class TextureBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture"       )return(void*)&this->texture       ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "buffer"        )return(void*)&this->buffer        ;
          return NULL;
        }
      public:
        TEXTURE_TYPE        texture       ;
        INTERNALFORMAT_TYPE internalformat;
        BUFFER_TYPE         buffer        ;
        TextureBuffer(
            TEXTURE_TYPE        const&texture       ,
            INTERNALFORMAT_TYPE const&internalformat,
            BUFFER_TYPE         const&buffer        ){
          this->texture        = texture       ;
          this->internalformat = internalformat;
          this->buffer         = buffer        ;
        }
        virtual~TextureBuffer(){}
        virtual void operator()(){
          glTextureBuffer(
            ge::core::convertTo<GLuint>(this->texture       ),
            ge::core::convertTo<GLenum>(this->internalformat),
            ge::core::convertTo<GLuint>(this->buffer        )
          );
        }
    };

    template<
      typename ID_TYPE     = GLuint,
      typename TARGET_TYPE = GLenum>
    class QueryCounter:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "id"    )return(void*)&this->id    ;
          if(name == "target")return(void*)&this->target;
          return NULL;
        }
      public:
        ID_TYPE     id    ;
        TARGET_TYPE target;
        QueryCounter(
            ID_TYPE     const&id    ,
            TARGET_TYPE const&target){
          this->id     = id    ;
          this->target = target;
        }
        virtual~QueryCounter(){}
        virtual void operator()(){
          glQueryCounter(
            ge::core::convertTo<GLuint>(this->id    ),
            ge::core::convertTo<GLenum>(this->target)
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint>
    class DeleteProgram:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        DeleteProgram(
            PROGRAM_TYPE const&program){
          this->program = program;
        }
        virtual~DeleteProgram(){}
        virtual void operator()(){
          glDeleteProgram(
            ge::core::convertTo<GLuint>(this->program)
          );
        }
    };

    template<
      typename MODE_TYPE = GLenum>
    class ProvokingVertex:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode")return(void*)&this->mode;
          return NULL;
        }
      public:
        MODE_TYPE mode;
        ProvokingVertex(
            MODE_TYPE const&mode){
          this->mode = mode;
        }
        virtual~ProvokingVertex(){}
        virtual void operator()(){
          glProvokingVertex(
            ge::core::convertTo<GLenum>(this->mode)
          );
        }
    };

    template<
      typename COUNT_TYPE        = GLsizei      ,
      typename SHADERS_TYPE      = const GLuint*,
      typename BINARYFORMAT_TYPE = GLenum       ,
      typename BINARY_TYPE       = const void*  ,
      typename LENGTH_TYPE       = GLsizei      >
    class ShaderBinary:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "count"       )return(void*)&this->count       ;
          if(name == "shaders"     )return(void*)&this->shaders     ;
          if(name == "binaryformat")return(void*)&this->binaryformat;
          if(name == "binary"      )return(void*)&this->binary      ;
          if(name == "length"      )return(void*)&this->length      ;
          return NULL;
        }
      public:
        COUNT_TYPE        count       ;
        SHADERS_TYPE      shaders     ;
        BINARYFORMAT_TYPE binaryformat;
        BINARY_TYPE       binary      ;
        LENGTH_TYPE       length      ;
        ShaderBinary(
            COUNT_TYPE        const&count       ,
            SHADERS_TYPE      const&shaders     ,
            BINARYFORMAT_TYPE const&binaryformat,
            BINARY_TYPE       const&binary      ,
            LENGTH_TYPE       const&length      ){
          this->count        = count       ;
          this->shaders      = shaders     ;
          this->binaryformat = binaryformat;
          this->binary       = binary      ;
          this->length       = length      ;
        }
        virtual~ShaderBinary(){}
        virtual void operator()(){
          glShaderBinary(
            ge::core::convertTo<GLsizei      >(this->count       ),
            ge::core::convertTo<const GLuint*>(this->shaders     ),
            ge::core::convertTo<GLenum       >(this->binaryformat),
            ge::core::convertTo<const void*  >(this->binary      ),
            ge::core::convertTo<GLsizei      >(this->length      )
          );
        }
    };

    template<
      typename RET_TYPE    = GLboolean,
      typename BUFFER_TYPE = GLuint   >
    class UnmapNamedBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"   )return(void*)&this->ret   ;
          if(name == "buffer")return(void*)&this->buffer;
          return NULL;
        }
      public:
        RET_TYPE    ret   ;
        BUFFER_TYPE buffer;
        UnmapNamedBuffer(
            RET_TYPE    const&ret   ,
            BUFFER_TYPE const&buffer){
          this->ret    = ret   ;
          this->buffer = buffer;
        }
        virtual~UnmapNamedBuffer(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glUnmapNamedBuffer(
              ge::core::convertTo<GLuint   >(this->buffer))
          );
        }
    };

    template<
      typename MODE_TYPE    = GLenum     ,
      typename COUNT_TYPE   = GLsizei    ,
      typename TYPE_TYPE    = GLenum     ,
      typename INDICES_TYPE = const void*>
    class DrawElements:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"   )return(void*)&this->mode   ;
          if(name == "count"  )return(void*)&this->count  ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "indices")return(void*)&this->indices;
          return NULL;
        }
      public:
        MODE_TYPE    mode   ;
        COUNT_TYPE   count  ;
        TYPE_TYPE    type   ;
        INDICES_TYPE indices;
        DrawElements(
            MODE_TYPE    const&mode   ,
            COUNT_TYPE   const&count  ,
            TYPE_TYPE    const&type   ,
            INDICES_TYPE const&indices){
          this->mode    = mode   ;
          this->count   = count  ;
          this->type    = type   ;
          this->indices = indices;
        }
        virtual~DrawElements(){}
        virtual void operator()(){
          glDrawElements(
            ge::core::convertTo<GLenum     >(this->mode   ),
            ge::core::convertTo<GLsizei    >(this->count  ),
            ge::core::convertTo<GLenum     >(this->type   ),
            ge::core::convertTo<const void*>(this->indices)
          );
        }
    };

    template<
      typename RENDERBUFFER_TYPE   = GLuint ,
      typename SAMPLES_TYPE        = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    class NamedRenderbufferStorageMultisample:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "renderbuffer"  )return(void*)&this->renderbuffer  ;
          if(name == "samples"       )return(void*)&this->samples       ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          return NULL;
        }
      public:
        RENDERBUFFER_TYPE   renderbuffer  ;
        SAMPLES_TYPE        samples       ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        NamedRenderbufferStorageMultisample(
            RENDERBUFFER_TYPE   const&renderbuffer  ,
            SAMPLES_TYPE        const&samples       ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ){
          this->renderbuffer   = renderbuffer  ;
          this->samples        = samples       ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->height         = height        ;
        }
        virtual~NamedRenderbufferStorageMultisample(){}
        virtual void operator()(){
          glNamedRenderbufferStorageMultisample(
            ge::core::convertTo<GLuint >(this->renderbuffer  ),
            ge::core::convertTo<GLsizei>(this->samples       ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLsizei>(this->width         ),
            ge::core::convertTo<GLsizei>(this->height        )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    class VertexAttribI4sv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribI4sv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribI4sv(){}
        virtual void operator()(){
          glVertexAttribI4sv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLshort*>(this->v    )
          );
        }
    };

    template<
      typename BUFFER_TYPE         = GLuint     ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename DATA_TYPE           = const void*>
    class ClearNamedBufferData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer"        )return(void*)&this->buffer        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "format"        )return(void*)&this->format        ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "data"          )return(void*)&this->data          ;
          return NULL;
        }
      public:
        BUFFER_TYPE         buffer        ;
        INTERNALFORMAT_TYPE internalformat;
        FORMAT_TYPE         format        ;
        TYPE_TYPE           type          ;
        DATA_TYPE           data          ;
        ClearNamedBufferData(
            BUFFER_TYPE         const&buffer        ,
            INTERNALFORMAT_TYPE const&internalformat,
            FORMAT_TYPE         const&format        ,
            TYPE_TYPE           const&type          ,
            DATA_TYPE           const&data          ){
          this->buffer         = buffer        ;
          this->internalformat = internalformat;
          this->format         = format        ;
          this->type           = type          ;
          this->data           = data          ;
        }
        virtual~ClearNamedBufferData(){}
        virtual void operator()(){
          glClearNamedBufferData(
            ge::core::convertTo<GLuint     >(this->buffer        ),
            ge::core::convertTo<GLenum     >(this->internalformat),
            ge::core::convertTo<GLenum     >(this->format        ),
            ge::core::convertTo<GLenum     >(this->type          ),
            ge::core::convertTo<const void*>(this->data          )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    class Uniform1iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform1iv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform1iv(){}
        virtual void operator()(){
          glUniform1iv(
            ge::core::convertTo<GLint       >(this->location),
            ge::core::convertTo<GLsizei     >(this->count   ),
            ge::core::convertTo<const GLint*>(this->value   )
          );
        }
    };

    template<
      typename RET_TYPE     = GLuint             ,
      typename TYPE_TYPE    = GLenum             ,
      typename COUNT_TYPE   = GLsizei            ,
      typename STRINGS_TYPE = const GLchar*const*>
    class CreateShaderProgramv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"    )return(void*)&this->ret    ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "count"  )return(void*)&this->count  ;
          if(name == "strings")return(void*)&this->strings;
          return NULL;
        }
      public:
        RET_TYPE     ret    ;
        TYPE_TYPE    type   ;
        COUNT_TYPE   count  ;
        STRINGS_TYPE strings;
        CreateShaderProgramv(
            RET_TYPE     const&ret    ,
            TYPE_TYPE    const&type   ,
            COUNT_TYPE   const&count  ,
            STRINGS_TYPE const&strings){
          this->ret     = ret    ;
          this->type    = type   ;
          this->count   = count  ;
          this->strings = strings;
        }
        virtual~CreateShaderProgramv(){}
        virtual void operator()(){
          ge::core::convertFrom<GLuint>(this->ret,glCreateShaderProgramv(
              ge::core::convertTo<GLenum             >(this->type   ),
              ge::core::convertTo<GLsizei            >(this->count  ),
              ge::core::convertTo<const GLchar*const*>(this->strings))
          );
        }
    };

    template<
      typename ID_TYPE     = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetQueryObjectiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "id"    )return(void*)&this->id    ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        ID_TYPE     id    ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetQueryObjectiv(
            ID_TYPE     const&id    ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->id     = id    ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetQueryObjectiv(){}
        virtual void operator()(){
          glGetQueryObjectiv(
            ge::core::convertTo<GLuint>(this->id    ),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    template<
      typename SRC_TYPE = GLenum>
    class ReadBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "src")return(void*)&this->src;
          return NULL;
        }
      public:
        SRC_TYPE src;
        ReadBuffer(
            SRC_TYPE const&src){
          this->src = src;
        }
        virtual~ReadBuffer(){}
        virtual void operator()(){
          glReadBuffer(
            ge::core::convertTo<GLenum>(this->src)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum       ,
      typename PNAME_TYPE  = GLenum       ,
      typename PARAMS_TYPE = const GLuint*>
    class TexParameterIuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        TexParameterIuiv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~TexParameterIuiv(){}
        virtual void operator()(){
          glTexParameterIuiv(
            ge::core::convertTo<GLenum       >(this->target),
            ge::core::convertTo<GLenum       >(this->pname ),
            ge::core::convertTo<const GLuint*>(this->params)
          );
        }
    };

    template<
      typename MODE_TYPE          = GLenum ,
      typename FIRST_TYPE         = GLint  ,
      typename COUNT_TYPE         = GLsizei,
      typename INSTANCECOUNT_TYPE = GLsizei>
    class DrawArraysInstanced:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"         )return(void*)&this->mode         ;
          if(name == "first"        )return(void*)&this->first        ;
          if(name == "count"        )return(void*)&this->count        ;
          if(name == "instancecount")return(void*)&this->instancecount;
          return NULL;
        }
      public:
        MODE_TYPE          mode         ;
        FIRST_TYPE         first        ;
        COUNT_TYPE         count        ;
        INSTANCECOUNT_TYPE instancecount;
        DrawArraysInstanced(
            MODE_TYPE          const&mode         ,
            FIRST_TYPE         const&first        ,
            COUNT_TYPE         const&count        ,
            INSTANCECOUNT_TYPE const&instancecount){
          this->mode          = mode         ;
          this->first         = first        ;
          this->count         = count        ;
          this->instancecount = instancecount;
        }
        virtual~DrawArraysInstanced(){}
        virtual void operator()(){
          glDrawArraysInstanced(
            ge::core::convertTo<GLenum >(this->mode         ),
            ge::core::convertTo<GLint  >(this->first        ),
            ge::core::convertTo<GLsizei>(this->count        ),
            ge::core::convertTo<GLsizei>(this->instancecount)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum>
    class GenerateMipmap:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        GenerateMipmap(
            TARGET_TYPE const&target){
          this->target = target;
        }
        virtual~GenerateMipmap(){}
        virtual void operator()(){
          glGenerateMipmap(
            ge::core::convertTo<GLenum>(this->target)
          );
        }
    };

    template<
      typename TEXTURE_TYPE   = GLuint     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename YOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename HEIGHT_TYPE    = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    class CompressedTextureSubImage2D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture"  )return(void*)&this->texture  ;
          if(name == "level"    )return(void*)&this->level    ;
          if(name == "xoffset"  )return(void*)&this->xoffset  ;
          if(name == "yoffset"  )return(void*)&this->yoffset  ;
          if(name == "width"    )return(void*)&this->width    ;
          if(name == "height"   )return(void*)&this->height   ;
          if(name == "format"   )return(void*)&this->format   ;
          if(name == "imageSize")return(void*)&this->imageSize;
          if(name == "data"     )return(void*)&this->data     ;
          return NULL;
        }
      public:
        TEXTURE_TYPE   texture  ;
        LEVEL_TYPE     level    ;
        XOFFSET_TYPE   xoffset  ;
        YOFFSET_TYPE   yoffset  ;
        WIDTH_TYPE     width    ;
        HEIGHT_TYPE    height   ;
        FORMAT_TYPE    format   ;
        IMAGESIZE_TYPE imageSize;
        DATA_TYPE      data     ;
        CompressedTextureSubImage2D(
            TEXTURE_TYPE   const&texture  ,
            LEVEL_TYPE     const&level    ,
            XOFFSET_TYPE   const&xoffset  ,
            YOFFSET_TYPE   const&yoffset  ,
            WIDTH_TYPE     const&width    ,
            HEIGHT_TYPE    const&height   ,
            FORMAT_TYPE    const&format   ,
            IMAGESIZE_TYPE const&imageSize,
            DATA_TYPE      const&data     ){
          this->texture   = texture  ;
          this->level     = level    ;
          this->xoffset   = xoffset  ;
          this->yoffset   = yoffset  ;
          this->width     = width    ;
          this->height    = height   ;
          this->format    = format   ;
          this->imageSize = imageSize;
          this->data      = data     ;
        }
        virtual~CompressedTextureSubImage2D(){}
        virtual void operator()(){
          glCompressedTextureSubImage2D(
            ge::core::convertTo<GLuint     >(this->texture  ),
            ge::core::convertTo<GLint      >(this->level    ),
            ge::core::convertTo<GLint      >(this->xoffset  ),
            ge::core::convertTo<GLint      >(this->yoffset  ),
            ge::core::convertTo<GLsizei    >(this->width    ),
            ge::core::convertTo<GLsizei    >(this->height   ),
            ge::core::convertTo<GLenum     >(this->format   ),
            ge::core::convertTo<GLsizei    >(this->imageSize),
            ge::core::convertTo<const void*>(this->data     )
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class ProgramUniformMatrix2fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix2fv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix2fv(){}
        virtual void operator()(){
          glProgramUniformMatrix2fv(
            ge::core::convertTo<GLuint        >(this->program  ),
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename SAMPLER_TYPE = GLuint      ,
      typename PNAME_TYPE   = GLenum      ,
      typename PARAM_TYPE   = const GLint*>
    class SamplerParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sampler")return(void*)&this->sampler;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "param"  )return(void*)&this->param  ;
          return NULL;
        }
      public:
        SAMPLER_TYPE sampler;
        PNAME_TYPE   pname  ;
        PARAM_TYPE   param  ;
        SamplerParameteriv(
            SAMPLER_TYPE const&sampler,
            PNAME_TYPE   const&pname  ,
            PARAM_TYPE   const&param  ){
          this->sampler = sampler;
          this->pname   = pname  ;
          this->param   = param  ;
        }
        virtual~SamplerParameteriv(){}
        virtual void operator()(){
          glSamplerParameteriv(
            ge::core::convertTo<GLuint      >(this->sampler),
            ge::core::convertTo<GLenum      >(this->pname  ),
            ge::core::convertTo<const GLint*>(this->param  )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat,
      typename Y_TYPE     = GLfloat,
      typename Z_TYPE     = GLfloat>
    class VertexAttrib3f:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        VertexAttrib3f(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
        }
        virtual~VertexAttrib3f(){}
        virtual void operator()(){
          glVertexAttrib3f(
            ge::core::convertTo<GLuint >(this->index),
            ge::core::convertTo<GLfloat>(this->x    ),
            ge::core::convertTo<GLfloat>(this->y    ),
            ge::core::convertTo<GLfloat>(this->z    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    class VertexAttrib4uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4uiv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4uiv(){}
        virtual void operator()(){
          glVertexAttrib4uiv(
            ge::core::convertTo<GLuint       >(this->index),
            ge::core::convertTo<const GLuint*>(this->v    )
          );
        }
    };

    template<
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint >
    class PointParameteri:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname")return(void*)&this->pname;
          if(name == "param")return(void*)&this->param;
          return NULL;
        }
      public:
        PNAME_TYPE pname;
        PARAM_TYPE param;
        PointParameteri(
            PNAME_TYPE const&pname,
            PARAM_TYPE const&param){
          this->pname = pname;
          this->param = param;
        }
        virtual~PointParameteri(){}
        virtual void operator()(){
          glPointParameteri(
            ge::core::convertTo<GLenum>(this->pname),
            ge::core::convertTo<GLint >(this->param)
          );
        }
    };

    template<
      typename RED_TYPE   = GLfloat,
      typename GREEN_TYPE = GLfloat,
      typename BLUE_TYPE  = GLfloat,
      typename ALPHA_TYPE = GLfloat>
    class BlendColor:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "red"  )return(void*)&this->red  ;
          if(name == "green")return(void*)&this->green;
          if(name == "blue" )return(void*)&this->blue ;
          if(name == "alpha")return(void*)&this->alpha;
          return NULL;
        }
      public:
        RED_TYPE   red  ;
        GREEN_TYPE green;
        BLUE_TYPE  blue ;
        ALPHA_TYPE alpha;
        BlendColor(
            RED_TYPE   const&red  ,
            GREEN_TYPE const&green,
            BLUE_TYPE  const&blue ,
            ALPHA_TYPE const&alpha){
          this->red   = red  ;
          this->green = green;
          this->blue  = blue ;
          this->alpha = alpha;
        }
        virtual~BlendColor(){}
        virtual void operator()(){
          glBlendColor(
            ge::core::convertTo<GLfloat>(this->red  ),
            ge::core::convertTo<GLfloat>(this->green),
            ge::core::convertTo<GLfloat>(this->blue ),
            ge::core::convertTo<GLfloat>(this->alpha)
          );
        }
    };

    template<
      typename SAMPLER_TYPE = GLuint       ,
      typename PNAME_TYPE   = GLenum       ,
      typename PARAM_TYPE   = const GLuint*>
    class SamplerParameterIuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sampler")return(void*)&this->sampler;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "param"  )return(void*)&this->param  ;
          return NULL;
        }
      public:
        SAMPLER_TYPE sampler;
        PNAME_TYPE   pname  ;
        PARAM_TYPE   param  ;
        SamplerParameterIuiv(
            SAMPLER_TYPE const&sampler,
            PNAME_TYPE   const&pname  ,
            PARAM_TYPE   const&param  ){
          this->sampler = sampler;
          this->pname   = pname  ;
          this->param   = param  ;
        }
        virtual~SamplerParameterIuiv(){}
        virtual void operator()(){
          glSamplerParameterIuiv(
            ge::core::convertTo<GLuint       >(this->sampler),
            ge::core::convertTo<GLenum       >(this->pname  ),
            ge::core::convertTo<const GLuint*>(this->param  )
          );
        }
    };

    template<
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr,
      typename COMMIT_TYPE = GLboolean >
    class NamedBufferPageCommitmentEXT:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "offset")return(void*)&this->offset;
          if(name == "size"  )return(void*)&this->size  ;
          if(name == "commit")return(void*)&this->commit;
          return NULL;
        }
      public:
        BUFFER_TYPE buffer;
        OFFSET_TYPE offset;
        SIZE_TYPE   size  ;
        COMMIT_TYPE commit;
        NamedBufferPageCommitmentEXT(
            BUFFER_TYPE const&buffer,
            OFFSET_TYPE const&offset,
            SIZE_TYPE   const&size  ,
            COMMIT_TYPE const&commit){
          this->buffer = buffer;
          this->offset = offset;
          this->size   = size  ;
          this->commit = commit;
        }
        virtual~NamedBufferPageCommitmentEXT(){}
        virtual void operator()(){
          glNamedBufferPageCommitmentEXT(
            ge::core::convertTo<GLuint    >(this->buffer),
            ge::core::convertTo<GLintptr  >(this->offset),
            ge::core::convertTo<GLsizeiptr>(this->size  ),
            ge::core::convertTo<GLboolean >(this->commit)
          );
        }
    };

    template<
      typename RET_TYPE         = GLenum,
      typename FRAMEBUFFER_TYPE = GLuint,
      typename TARGET_TYPE      = GLenum>
    class CheckNamedFramebufferStatus:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"        )return(void*)&this->ret        ;
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "target"     )return(void*)&this->target     ;
          return NULL;
        }
      public:
        RET_TYPE         ret        ;
        FRAMEBUFFER_TYPE framebuffer;
        TARGET_TYPE      target     ;
        CheckNamedFramebufferStatus(
            RET_TYPE         const&ret        ,
            FRAMEBUFFER_TYPE const&framebuffer,
            TARGET_TYPE      const&target     ){
          this->ret         = ret        ;
          this->framebuffer = framebuffer;
          this->target      = target     ;
        }
        virtual~CheckNamedFramebufferStatus(){}
        virtual void operator()(){
          ge::core::convertFrom<GLenum>(this->ret,glCheckNamedFramebufferStatus(
              ge::core::convertTo<GLuint>(this->framebuffer),
              ge::core::convertTo<GLenum>(this->target     ))
          );
        }
    };

    template<
      typename RET_TYPE    = GLboolean,
      typename TARGET_TYPE = GLenum   >
    class UnmapBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"   )return(void*)&this->ret   ;
          if(name == "target")return(void*)&this->target;
          return NULL;
        }
      public:
        RET_TYPE    ret   ;
        TARGET_TYPE target;
        UnmapBuffer(
            RET_TYPE    const&ret   ,
            TARGET_TYPE const&target){
          this->ret    = ret   ;
          this->target = target;
        }
        virtual~UnmapBuffer(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glUnmapBuffer(
              ge::core::convertTo<GLenum   >(this->target))
          );
        }
    };

    template<
      typename PNAME_TYPE = GLenum ,
      typename PARAM_TYPE = GLfloat>
    class PointParameterf:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname")return(void*)&this->pname;
          if(name == "param")return(void*)&this->param;
          return NULL;
        }
      public:
        PNAME_TYPE pname;
        PARAM_TYPE param;
        PointParameterf(
            PNAME_TYPE const&pname,
            PARAM_TYPE const&param){
          this->pname = pname;
          this->param = param;
        }
        virtual~PointParameterf(){}
        virtual void operator()(){
          glPointParameterf(
            ge::core::convertTo<GLenum >(this->pname),
            ge::core::convertTo<GLfloat>(this->param)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint      ,
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    class ProgramUniform1iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform1iv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform1iv(){}
        virtual void operator()(){
          glProgramUniform1iv(
            ge::core::convertTo<GLuint      >(this->program ),
            ge::core::convertTo<GLint       >(this->location),
            ge::core::convertTo<GLsizei     >(this->count   ),
            ge::core::convertTo<const GLint*>(this->value   )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    class VertexAttrib4sv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4sv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4sv(){}
        virtual void operator()(){
          glVertexAttrib4sv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLshort*>(this->v    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLshort,
      typename Y_TYPE     = GLshort,
      typename Z_TYPE     = GLshort>
    class VertexAttrib3s:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        VertexAttrib3s(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
        }
        virtual~VertexAttrib3s(){}
        virtual void operator()(){
          glVertexAttrib3s(
            ge::core::convertTo<GLuint >(this->index),
            ge::core::convertTo<GLshort>(this->x    ),
            ge::core::convertTo<GLshort>(this->y    ),
            ge::core::convertTo<GLshort>(this->z    )
          );
        }
    };

    template<
      typename TARGET_TYPE       = GLenum,
      typename RENDERBUFFER_TYPE = GLuint>
    class BindRenderbuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"      )return(void*)&this->target      ;
          if(name == "renderbuffer")return(void*)&this->renderbuffer;
          return NULL;
        }
      public:
        TARGET_TYPE       target      ;
        RENDERBUFFER_TYPE renderbuffer;
        BindRenderbuffer(
            TARGET_TYPE       const&target      ,
            RENDERBUFFER_TYPE const&renderbuffer){
          this->target       = target      ;
          this->renderbuffer = renderbuffer;
        }
        virtual~BindRenderbuffer(){}
        virtual void operator()(){
          glBindRenderbuffer(
            ge::core::convertTo<GLenum>(this->target      ),
            ge::core::convertTo<GLuint>(this->renderbuffer)
          );
        }
    };

    template<
      typename INDEX_TYPE      = GLuint       ,
      typename TYPE_TYPE       = GLenum       ,
      typename NORMALIZED_TYPE = GLboolean    ,
      typename VALUE_TYPE      = const GLuint*>
    class VertexAttribP4uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"     )return(void*)&this->index     ;
          if(name == "type"      )return(void*)&this->type      ;
          if(name == "normalized")return(void*)&this->normalized;
          if(name == "value"     )return(void*)&this->value     ;
          return NULL;
        }
      public:
        INDEX_TYPE      index     ;
        TYPE_TYPE       type      ;
        NORMALIZED_TYPE normalized;
        VALUE_TYPE      value     ;
        VertexAttribP4uiv(
            INDEX_TYPE      const&index     ,
            TYPE_TYPE       const&type      ,
            NORMALIZED_TYPE const&normalized,
            VALUE_TYPE      const&value     ){
          this->index      = index     ;
          this->type       = type      ;
          this->normalized = normalized;
          this->value      = value     ;
        }
        virtual~VertexAttribP4uiv(){}
        virtual void operator()(){
          glVertexAttribP4uiv(
            ge::core::convertTo<GLuint       >(this->index     ),
            ge::core::convertTo<GLenum       >(this->type      ),
            ge::core::convertTo<GLboolean    >(this->normalized),
            ge::core::convertTo<const GLuint*>(this->value     )
          );
        }
    };

    template<
      typename PROGRAM_TYPE    = GLuint,
      typename SHADERTYPE_TYPE = GLenum,
      typename PNAME_TYPE      = GLenum,
      typename VALUES_TYPE     = GLint*>
    class GetProgramStageiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"   )return(void*)&this->program   ;
          if(name == "shadertype")return(void*)&this->shadertype;
          if(name == "pname"     )return(void*)&this->pname     ;
          if(name == "values"    )return(void*)&this->values    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE    program   ;
        SHADERTYPE_TYPE shadertype;
        PNAME_TYPE      pname     ;
        VALUES_TYPE     values    ;
        GetProgramStageiv(
            PROGRAM_TYPE    const&program   ,
            SHADERTYPE_TYPE const&shadertype,
            PNAME_TYPE      const&pname     ,
            VALUES_TYPE     const&values    ){
          this->program    = program   ;
          this->shadertype = shadertype;
          this->pname      = pname     ;
          this->values     = values    ;
        }
        virtual~GetProgramStageiv(){}
        virtual void operator()(){
          glGetProgramStageiv(
            ge::core::convertTo<GLuint>(this->program   ),
            ge::core::convertTo<GLenum>(this->shadertype),
            ge::core::convertTo<GLenum>(this->pname     ),
            ge::core::convertTo<GLint*>(this->values    )
          );
        }
    };

    template<
      typename RET_TYPE     = GLboolean,
      typename PROGRAM_TYPE = GLuint   >
    class IsProgram:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"    )return(void*)&this->ret    ;
          if(name == "program")return(void*)&this->program;
          return NULL;
        }
      public:
        RET_TYPE     ret    ;
        PROGRAM_TYPE program;
        IsProgram(
            RET_TYPE     const&ret    ,
            PROGRAM_TYPE const&program){
          this->ret     = ret    ;
          this->program = program;
        }
        virtual~IsProgram(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsProgram(
              ge::core::convertTo<GLuint   >(this->program))
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLbyte*>
    class VertexAttrib4bv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4bv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4bv(){}
        virtual void operator()(){
          glVertexAttrib4bv(
            ge::core::convertTo<GLuint       >(this->index),
            ge::core::convertTo<const GLbyte*>(this->v    )
          );
        }
    };

    template<
      typename TEXTURE_TYPE        = GLuint ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei,
      typename DEPTH_TYPE          = GLsizei>
    class TextureStorage3D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture"       )return(void*)&this->texture       ;
          if(name == "levels"        )return(void*)&this->levels        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          if(name == "depth"         )return(void*)&this->depth         ;
          return NULL;
        }
      public:
        TEXTURE_TYPE        texture       ;
        LEVELS_TYPE         levels        ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        DEPTH_TYPE          depth         ;
        TextureStorage3D(
            TEXTURE_TYPE        const&texture       ,
            LEVELS_TYPE         const&levels        ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ,
            DEPTH_TYPE          const&depth         ){
          this->texture        = texture       ;
          this->levels         = levels        ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->height         = height        ;
          this->depth          = depth         ;
        }
        virtual~TextureStorage3D(){}
        virtual void operator()(){
          glTextureStorage3D(
            ge::core::convertTo<GLuint >(this->texture       ),
            ge::core::convertTo<GLsizei>(this->levels        ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLsizei>(this->width         ),
            ge::core::convertTo<GLsizei>(this->height        ),
            ge::core::convertTo<GLsizei>(this->depth         )
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class UniformMatrix3x2dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix3x2dv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix3x2dv(){}
        virtual void operator()(){
          glUniformMatrix3x2dv(
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    class VertexAttrib4fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4fv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4fv(){}
        virtual void operator()(){
          glVertexAttrib4fv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLfloat*>(this->v    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class ProgramUniformMatrix2x3dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix2x3dv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix2x3dv(){}
        virtual void operator()(){
          glProgramUniformMatrix2x3dv(
            ge::core::convertTo<GLuint         >(this->program  ),
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename RET_TYPE = GLboolean,
      typename ID_TYPE  = GLuint   >
    class IsTransformFeedback:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret")return(void*)&this->ret;
          if(name == "id" )return(void*)&this->id ;
          return NULL;
        }
      public:
        RET_TYPE ret;
        ID_TYPE  id ;
        IsTransformFeedback(
            RET_TYPE const&ret,
            ID_TYPE  const&id ){
          this->ret = ret;
          this->id  = id ;
        }
        virtual~IsTransformFeedback(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsTransformFeedback(
              ge::core::convertTo<GLuint   >(this->id ))
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint,
      typename V0_TYPE       = GLint,
      typename V1_TYPE       = GLint,
      typename V2_TYPE       = GLint,
      typename V3_TYPE       = GLint>
    class Uniform4i:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          if(name == "v3"      )return(void*)&this->v3      ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        V3_TYPE       v3      ;
        Uniform4i(
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ,
            V3_TYPE       const&v3      ){
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
          this->v3       = v3      ;
        }
        virtual~Uniform4i(){}
        virtual void operator()(){
          glUniform4i(
            ge::core::convertTo<GLint>(this->location),
            ge::core::convertTo<GLint>(this->v0      ),
            ge::core::convertTo<GLint>(this->v1      ),
            ge::core::convertTo<GLint>(this->v2      ),
            ge::core::convertTo<GLint>(this->v3      )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLenum>
    class ActiveTexture:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        ActiveTexture(
            TEXTURE_TYPE const&texture){
          this->texture = texture;
        }
        virtual~ActiveTexture(){}
        virtual void operator()(){
          glActiveTexture(
            ge::core::convertTo<GLenum>(this->texture)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint>
    class EnableVertexAttribArray:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        EnableVertexAttribArray(
            INDEX_TYPE const&index){
          this->index = index;
        }
        virtual~EnableVertexAttribArray(){}
        virtual void operator()(){
          glEnableVertexAttribArray(
            ge::core::convertTo<GLuint>(this->index)
          );
        }
    };

    template<
      typename RET_TYPE      = GLboolean,
      typename PIPELINE_TYPE = GLuint   >
    class IsProgramPipeline:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"     )return(void*)&this->ret     ;
          if(name == "pipeline")return(void*)&this->pipeline;
          return NULL;
        }
      public:
        RET_TYPE      ret     ;
        PIPELINE_TYPE pipeline;
        IsProgramPipeline(
            RET_TYPE      const&ret     ,
            PIPELINE_TYPE const&pipeline){
          this->ret      = ret     ;
          this->pipeline = pipeline;
        }
        virtual~IsProgramPipeline(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsProgramPipeline(
              ge::core::convertTo<GLuint   >(this->pipeline))
          );
        }
    };

    template<
      typename X_TYPE      = GLint  ,
      typename Y_TYPE      = GLint  ,
      typename WIDTH_TYPE  = GLsizei,
      typename HEIGHT_TYPE = GLsizei,
      typename FORMAT_TYPE = GLenum ,
      typename TYPE_TYPE   = GLenum ,
      typename PIXELS_TYPE = void*  >
    class ReadPixels:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "x"     )return(void*)&this->x     ;
          if(name == "y"     )return(void*)&this->y     ;
          if(name == "width" )return(void*)&this->width ;
          if(name == "height")return(void*)&this->height;
          if(name == "format")return(void*)&this->format;
          if(name == "type"  )return(void*)&this->type  ;
          if(name == "pixels")return(void*)&this->pixels;
          return NULL;
        }
      public:
        X_TYPE      x     ;
        Y_TYPE      y     ;
        WIDTH_TYPE  width ;
        HEIGHT_TYPE height;
        FORMAT_TYPE format;
        TYPE_TYPE   type  ;
        PIXELS_TYPE pixels;
        ReadPixels(
            X_TYPE      const&x     ,
            Y_TYPE      const&y     ,
            WIDTH_TYPE  const&width ,
            HEIGHT_TYPE const&height,
            FORMAT_TYPE const&format,
            TYPE_TYPE   const&type  ,
            PIXELS_TYPE const&pixels){
          this->x      = x     ;
          this->y      = y     ;
          this->width  = width ;
          this->height = height;
          this->format = format;
          this->type   = type  ;
          this->pixels = pixels;
        }
        virtual~ReadPixels(){}
        virtual void operator()(){
          glReadPixels(
            ge::core::convertTo<GLint  >(this->x     ),
            ge::core::convertTo<GLint  >(this->y     ),
            ge::core::convertTo<GLsizei>(this->width ),
            ge::core::convertTo<GLsizei>(this->height),
            ge::core::convertTo<GLenum >(this->format),
            ge::core::convertTo<GLenum >(this->type  ),
            ge::core::convertTo<void*  >(this->pixels)
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint   ,
      typename X_TYPE        = GLdouble,
      typename Y_TYPE        = GLdouble,
      typename Z_TYPE        = GLdouble,
      typename W_TYPE        = GLdouble>
    class Uniform4d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "x"       )return(void*)&this->x       ;
          if(name == "y"       )return(void*)&this->y       ;
          if(name == "z"       )return(void*)&this->z       ;
          if(name == "w"       )return(void*)&this->w       ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        X_TYPE        x       ;
        Y_TYPE        y       ;
        Z_TYPE        z       ;
        W_TYPE        w       ;
        Uniform4d(
            LOCATION_TYPE const&location,
            X_TYPE        const&x       ,
            Y_TYPE        const&y       ,
            Z_TYPE        const&z       ,
            W_TYPE        const&w       ){
          this->location = location;
          this->x        = x       ;
          this->y        = y       ;
          this->z        = z       ;
          this->w        = w       ;
        }
        virtual~Uniform4d(){}
        virtual void operator()(){
          glUniform4d(
            ge::core::convertTo<GLint   >(this->location),
            ge::core::convertTo<GLdouble>(this->x       ),
            ge::core::convertTo<GLdouble>(this->y       ),
            ge::core::convertTo<GLdouble>(this->z       ),
            ge::core::convertTo<GLdouble>(this->w       )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat,
      typename V2_TYPE       = GLfloat,
      typename V3_TYPE       = GLfloat>
    class Uniform4f:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          if(name == "v3"      )return(void*)&this->v3      ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        V3_TYPE       v3      ;
        Uniform4f(
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ,
            V3_TYPE       const&v3      ){
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
          this->v3       = v3      ;
        }
        virtual~Uniform4f(){}
        virtual void operator()(){
          glUniform4f(
            ge::core::convertTo<GLint  >(this->location),
            ge::core::convertTo<GLfloat>(this->v0      ),
            ge::core::convertTo<GLfloat>(this->v1      ),
            ge::core::convertTo<GLfloat>(this->v2      ),
            ge::core::convertTo<GLfloat>(this->v3      )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum ,
      typename SAMPLES_TYPE        = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    class RenderbufferStorageMultisample:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "samples"       )return(void*)&this->samples       ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        SAMPLES_TYPE        samples       ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        RenderbufferStorageMultisample(
            TARGET_TYPE         const&target        ,
            SAMPLES_TYPE        const&samples       ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ){
          this->target         = target        ;
          this->samples        = samples       ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->height         = height        ;
        }
        virtual~RenderbufferStorageMultisample(){}
        virtual void operator()(){
          glRenderbufferStorageMultisample(
            ge::core::convertTo<GLenum >(this->target        ),
            ge::core::convertTo<GLsizei>(this->samples       ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLsizei>(this->width         ),
            ge::core::convertTo<GLsizei>(this->height        )
          );
        }
    };

    template<
      typename N_TYPE         = GLsizei,
      typename PIPELINES_TYPE = GLuint*>
    class CreateProgramPipelines:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"        )return(void*)&this->n        ;
          if(name == "pipelines")return(void*)&this->pipelines;
          return NULL;
        }
      public:
        N_TYPE         n        ;
        PIPELINES_TYPE pipelines;
        CreateProgramPipelines(
            N_TYPE         const&n        ,
            PIPELINES_TYPE const&pipelines){
          this->n         = n        ;
          this->pipelines = pipelines;
        }
        virtual~CreateProgramPipelines(){}
        virtual void operator()(){
          glCreateProgramPipelines(
            ge::core::convertTo<GLsizei>(this->n        ),
            ge::core::convertTo<GLuint*>(this->pipelines)
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class UniformMatrix3fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix3fv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix3fv(){}
        virtual void operator()(){
          glUniformMatrix3fv(
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename INDEX_TYPE   = GLuint     ,
      typename SIZE_TYPE    = GLint      ,
      typename TYPE_TYPE    = GLenum     ,
      typename STRIDE_TYPE  = GLsizei    ,
      typename POINTER_TYPE = const void*>
    class VertexAttribLPointer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"  )return(void*)&this->index  ;
          if(name == "size"   )return(void*)&this->size   ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "stride" )return(void*)&this->stride ;
          if(name == "pointer")return(void*)&this->pointer;
          return NULL;
        }
      public:
        INDEX_TYPE   index  ;
        SIZE_TYPE    size   ;
        TYPE_TYPE    type   ;
        STRIDE_TYPE  stride ;
        POINTER_TYPE pointer;
        VertexAttribLPointer(
            INDEX_TYPE   const&index  ,
            SIZE_TYPE    const&size   ,
            TYPE_TYPE    const&type   ,
            STRIDE_TYPE  const&stride ,
            POINTER_TYPE const&pointer){
          this->index   = index  ;
          this->size    = size   ;
          this->type    = type   ;
          this->stride  = stride ;
          this->pointer = pointer;
        }
        virtual~VertexAttribLPointer(){}
        virtual void operator()(){
          glVertexAttribLPointer(
            ge::core::convertTo<GLuint     >(this->index  ),
            ge::core::convertTo<GLint      >(this->size   ),
            ge::core::convertTo<GLenum     >(this->type   ),
            ge::core::convertTo<GLsizei    >(this->stride ),
            ge::core::convertTo<const void*>(this->pointer)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename BUFSIZE_TYPE  = GLsizei ,
      typename PARAMS_TYPE   = GLfloat*>
    class GetnUniformfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "bufSize" )return(void*)&this->bufSize ;
          if(name == "params"  )return(void*)&this->params  ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        BUFSIZE_TYPE  bufSize ;
        PARAMS_TYPE   params  ;
        GetnUniformfv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            BUFSIZE_TYPE  const&bufSize ,
            PARAMS_TYPE   const&params  ){
          this->program  = program ;
          this->location = location;
          this->bufSize  = bufSize ;
          this->params   = params  ;
        }
        virtual~GetnUniformfv(){}
        virtual void operator()(){
          glGetnUniformfv(
            ge::core::convertTo<GLuint  >(this->program ),
            ge::core::convertTo<GLint   >(this->location),
            ge::core::convertTo<GLsizei >(this->bufSize ),
            ge::core::convertTo<GLfloat*>(this->params  )
          );
        }
    };

    template<
      typename MODE_TYPE          = GLenum     ,
      typename COUNT_TYPE         = GLsizei    ,
      typename TYPE_TYPE          = GLenum     ,
      typename INDICES_TYPE       = const void*,
      typename INSTANCECOUNT_TYPE = GLsizei    ,
      typename BASEVERTEX_TYPE    = GLint      >
    class DrawElementsInstancedBaseVertex:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"         )return(void*)&this->mode         ;
          if(name == "count"        )return(void*)&this->count        ;
          if(name == "type"         )return(void*)&this->type         ;
          if(name == "indices"      )return(void*)&this->indices      ;
          if(name == "instancecount")return(void*)&this->instancecount;
          if(name == "basevertex"   )return(void*)&this->basevertex   ;
          return NULL;
        }
      public:
        MODE_TYPE          mode         ;
        COUNT_TYPE         count        ;
        TYPE_TYPE          type         ;
        INDICES_TYPE       indices      ;
        INSTANCECOUNT_TYPE instancecount;
        BASEVERTEX_TYPE    basevertex   ;
        DrawElementsInstancedBaseVertex(
            MODE_TYPE          const&mode         ,
            COUNT_TYPE         const&count        ,
            TYPE_TYPE          const&type         ,
            INDICES_TYPE       const&indices      ,
            INSTANCECOUNT_TYPE const&instancecount,
            BASEVERTEX_TYPE    const&basevertex   ){
          this->mode          = mode         ;
          this->count         = count        ;
          this->type          = type         ;
          this->indices       = indices      ;
          this->instancecount = instancecount;
          this->basevertex    = basevertex   ;
        }
        virtual~DrawElementsInstancedBaseVertex(){}
        virtual void operator()(){
          glDrawElementsInstancedBaseVertex(
            ge::core::convertTo<GLenum     >(this->mode         ),
            ge::core::convertTo<GLsizei    >(this->count        ),
            ge::core::convertTo<GLenum     >(this->type         ),
            ge::core::convertTo<const void*>(this->indices      ),
            ge::core::convertTo<GLsizei    >(this->instancecount),
            ge::core::convertTo<GLint      >(this->basevertex   )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    class VertexAttribL2dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribL2dv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribL2dv(){}
        virtual void operator()(){
          glVertexAttribL2dv(
            ge::core::convertTo<GLuint         >(this->index),
            ge::core::convertTo<const GLdouble*>(this->v    )
          );
        }
    };

    template<
      typename MODE_TYPE          = GLenum ,
      typename ID_TYPE            = GLuint ,
      typename STREAM_TYPE        = GLuint ,
      typename INSTANCECOUNT_TYPE = GLsizei>
    class DrawTransformFeedbackStreamInstanced:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"         )return(void*)&this->mode         ;
          if(name == "id"           )return(void*)&this->id           ;
          if(name == "stream"       )return(void*)&this->stream       ;
          if(name == "instancecount")return(void*)&this->instancecount;
          return NULL;
        }
      public:
        MODE_TYPE          mode         ;
        ID_TYPE            id           ;
        STREAM_TYPE        stream       ;
        INSTANCECOUNT_TYPE instancecount;
        DrawTransformFeedbackStreamInstanced(
            MODE_TYPE          const&mode         ,
            ID_TYPE            const&id           ,
            STREAM_TYPE        const&stream       ,
            INSTANCECOUNT_TYPE const&instancecount){
          this->mode          = mode         ;
          this->id            = id           ;
          this->stream        = stream       ;
          this->instancecount = instancecount;
        }
        virtual~DrawTransformFeedbackStreamInstanced(){}
        virtual void operator()(){
          glDrawTransformFeedbackStreamInstanced(
            ge::core::convertTo<GLenum >(this->mode         ),
            ge::core::convertTo<GLuint >(this->id           ),
            ge::core::convertTo<GLuint >(this->stream       ),
            ge::core::convertTo<GLsizei>(this->instancecount)
          );
        }
    };

    template<
      typename PROGRAM_TYPE    = GLuint  ,
      typename SHADERTYPE_TYPE = GLenum  ,
      typename INDEX_TYPE      = GLuint  ,
      typename BUFSIZE_TYPE    = GLsizei ,
      typename LENGTH_TYPE     = GLsizei*,
      typename NAME_TYPE       = GLchar* >
    class GetActiveSubroutineName:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"   )return(void*)&this->program   ;
          if(name == "shadertype")return(void*)&this->shadertype;
          if(name == "index"     )return(void*)&this->index     ;
          if(name == "bufsize"   )return(void*)&this->bufsize   ;
          if(name == "length"    )return(void*)&this->length    ;
          if(name == "name"      )return(void*)&this->name      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE    program   ;
        SHADERTYPE_TYPE shadertype;
        INDEX_TYPE      index     ;
        BUFSIZE_TYPE    bufsize   ;
        LENGTH_TYPE     length    ;
        NAME_TYPE       name      ;
        GetActiveSubroutineName(
            PROGRAM_TYPE    const&program   ,
            SHADERTYPE_TYPE const&shadertype,
            INDEX_TYPE      const&index     ,
            BUFSIZE_TYPE    const&bufsize   ,
            LENGTH_TYPE     const&length    ,
            NAME_TYPE       const&name      ){
          this->program    = program   ;
          this->shadertype = shadertype;
          this->index      = index     ;
          this->bufsize    = bufsize   ;
          this->length     = length    ;
          this->name       = name      ;
        }
        virtual~GetActiveSubroutineName(){}
        virtual void operator()(){
          glGetActiveSubroutineName(
            ge::core::convertTo<GLuint  >(this->program   ),
            ge::core::convertTo<GLenum  >(this->shadertype),
            ge::core::convertTo<GLuint  >(this->index     ),
            ge::core::convertTo<GLsizei >(this->bufsize   ),
            ge::core::convertTo<GLsizei*>(this->length    ),
            ge::core::convertTo<GLchar* >(this->name      )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble>
    class VertexAttribL2d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        VertexAttribL2d(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
        }
        virtual~VertexAttribL2d(){}
        virtual void operator()(){
          glVertexAttribL2d(
            ge::core::convertTo<GLuint  >(this->index),
            ge::core::convertTo<GLdouble>(this->x    ),
            ge::core::convertTo<GLdouble>(this->y    )
          );
        }
    };

    template<
      typename FUNC_TYPE = GLenum,
      typename REF_TYPE  = GLint ,
      typename MASK_TYPE = GLuint>
    class StencilFunc:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "func")return(void*)&this->func;
          if(name == "ref" )return(void*)&this->ref ;
          if(name == "mask")return(void*)&this->mask;
          return NULL;
        }
      public:
        FUNC_TYPE func;
        REF_TYPE  ref ;
        MASK_TYPE mask;
        StencilFunc(
            FUNC_TYPE const&func,
            REF_TYPE  const&ref ,
            MASK_TYPE const&mask){
          this->func = func;
          this->ref  = ref ;
          this->mask = mask;
        }
        virtual~StencilFunc(){}
        virtual void operator()(){
          glStencilFunc(
            ge::core::convertTo<GLenum>(this->func),
            ge::core::convertTo<GLint >(this->ref ),
            ge::core::convertTo<GLuint>(this->mask)
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE    = GLuint       ,
      typename NUMATTACHMENTS_TYPE = GLsizei      ,
      typename ATTACHMENTS_TYPE    = const GLenum*>
    class InvalidateNamedFramebufferData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer"   )return(void*)&this->framebuffer   ;
          if(name == "numAttachments")return(void*)&this->numAttachments;
          if(name == "attachments"   )return(void*)&this->attachments   ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE    framebuffer   ;
        NUMATTACHMENTS_TYPE numAttachments;
        ATTACHMENTS_TYPE    attachments   ;
        InvalidateNamedFramebufferData(
            FRAMEBUFFER_TYPE    const&framebuffer   ,
            NUMATTACHMENTS_TYPE const&numAttachments,
            ATTACHMENTS_TYPE    const&attachments   ){
          this->framebuffer    = framebuffer   ;
          this->numAttachments = numAttachments;
          this->attachments    = attachments   ;
        }
        virtual~InvalidateNamedFramebufferData(){}
        virtual void operator()(){
          glInvalidateNamedFramebufferData(
            ge::core::convertTo<GLuint       >(this->framebuffer   ),
            ge::core::convertTo<GLsizei      >(this->numAttachments),
            ge::core::convertTo<const GLenum*>(this->attachments   )
          );
        }
    };

    class PopDebugGroup:
        public ge::core::Command{
      public:
        PopDebugGroup(
            ){
        }
        virtual~PopDebugGroup(){}
        virtual void operator()(){
          glPopDebugGroup(

          );
        }
    };

    template<
      typename PROGRAM_TYPE             = GLuint,
      typename UNIFORMBLOCKINDEX_TYPE   = GLuint,
      typename UNIFORMBLOCKBINDING_TYPE = GLuint>
    class UniformBlockBinding:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"            )return(void*)&this->program            ;
          if(name == "uniformBlockIndex"  )return(void*)&this->uniformBlockIndex  ;
          if(name == "uniformBlockBinding")return(void*)&this->uniformBlockBinding;
          return NULL;
        }
      public:
        PROGRAM_TYPE             program            ;
        UNIFORMBLOCKINDEX_TYPE   uniformBlockIndex  ;
        UNIFORMBLOCKBINDING_TYPE uniformBlockBinding;
        UniformBlockBinding(
            PROGRAM_TYPE             const&program            ,
            UNIFORMBLOCKINDEX_TYPE   const&uniformBlockIndex  ,
            UNIFORMBLOCKBINDING_TYPE const&uniformBlockBinding){
          this->program             = program            ;
          this->uniformBlockIndex   = uniformBlockIndex  ;
          this->uniformBlockBinding = uniformBlockBinding;
        }
        virtual~UniformBlockBinding(){}
        virtual void operator()(){
          glUniformBlockBinding(
            ge::core::convertTo<GLuint>(this->program            ),
            ge::core::convertTo<GLuint>(this->uniformBlockIndex  ),
            ge::core::convertTo<GLuint>(this->uniformBlockBinding)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLint ,
      typename V1_TYPE       = GLint ,
      typename V2_TYPE       = GLint >
    class ProgramUniform3i:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        ProgramUniform3i(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
        }
        virtual~ProgramUniform3i(){}
        virtual void operator()(){
          glProgramUniform3i(
            ge::core::convertTo<GLuint>(this->program ),
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLint >(this->v0      ),
            ge::core::convertTo<GLint >(this->v1      ),
            ge::core::convertTo<GLint >(this->v2      )
          );
        }
    };

    template<
      typename PIPELINE_TYPE = GLuint    ,
      typename STAGES_TYPE   = GLbitfield,
      typename PROGRAM_TYPE  = GLuint    >
    class UseProgramStages:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pipeline")return(void*)&this->pipeline;
          if(name == "stages"  )return(void*)&this->stages  ;
          if(name == "program" )return(void*)&this->program ;
          return NULL;
        }
      public:
        PIPELINE_TYPE pipeline;
        STAGES_TYPE   stages  ;
        PROGRAM_TYPE  program ;
        UseProgramStages(
            PIPELINE_TYPE const&pipeline,
            STAGES_TYPE   const&stages  ,
            PROGRAM_TYPE  const&program ){
          this->pipeline = pipeline;
          this->stages   = stages  ;
          this->program  = program ;
        }
        virtual~UseProgramStages(){}
        virtual void operator()(){
          glUseProgramStages(
            ge::core::convertTo<GLuint    >(this->pipeline),
            ge::core::convertTo<GLbitfield>(this->stages  ),
            ge::core::convertTo<GLuint    >(this->program )
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class ProgramUniformMatrix3x2fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix3x2fv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix3x2fv(){}
        virtual void operator()(){
          glProgramUniformMatrix3x2fv(
            ge::core::convertTo<GLuint        >(this->program  ),
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename V0_TYPE       = GLdouble,
      typename V1_TYPE       = GLdouble,
      typename V2_TYPE       = GLdouble>
    class ProgramUniform3d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        ProgramUniform3d(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
        }
        virtual~ProgramUniform3d(){}
        virtual void operator()(){
          glProgramUniform3d(
            ge::core::convertTo<GLuint  >(this->program ),
            ge::core::convertTo<GLint   >(this->location),
            ge::core::convertTo<GLdouble>(this->v0      ),
            ge::core::convertTo<GLdouble>(this->v1      ),
            ge::core::convertTo<GLdouble>(this->v2      )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    class VertexAttribI4iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribI4iv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribI4iv(){}
        virtual void operator()(){
          glVertexAttribI4iv(
            ge::core::convertTo<GLuint      >(this->index),
            ge::core::convertTo<const GLint*>(this->v    )
          );
        }
    };

    template<
      typename PIPELINE_TYPE = GLuint,
      typename PNAME_TYPE    = GLenum,
      typename PARAMS_TYPE   = GLint*>
    class GetProgramPipelineiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pipeline")return(void*)&this->pipeline;
          if(name == "pname"   )return(void*)&this->pname   ;
          if(name == "params"  )return(void*)&this->params  ;
          return NULL;
        }
      public:
        PIPELINE_TYPE pipeline;
        PNAME_TYPE    pname   ;
        PARAMS_TYPE   params  ;
        GetProgramPipelineiv(
            PIPELINE_TYPE const&pipeline,
            PNAME_TYPE    const&pname   ,
            PARAMS_TYPE   const&params  ){
          this->pipeline = pipeline;
          this->pname    = pname   ;
          this->params   = params  ;
        }
        virtual~GetProgramPipelineiv(){}
        virtual void operator()(){
          glGetProgramPipelineiv(
            ge::core::convertTo<GLuint>(this->pipeline),
            ge::core::convertTo<GLenum>(this->pname   ),
            ge::core::convertTo<GLint*>(this->params  )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble,
      typename Z_TYPE     = GLdouble,
      typename W_TYPE     = GLdouble>
    class VertexAttribL4d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          if(name == "w"    )return(void*)&this->w    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        W_TYPE     w    ;
        VertexAttribL4d(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ,
            W_TYPE     const&w    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
          this->w     = w    ;
        }
        virtual~VertexAttribL4d(){}
        virtual void operator()(){
          glVertexAttribL4d(
            ge::core::convertTo<GLuint  >(this->index),
            ge::core::convertTo<GLdouble>(this->x    ),
            ge::core::convertTo<GLdouble>(this->y    ),
            ge::core::convertTo<GLdouble>(this->z    ),
            ge::core::convertTo<GLdouble>(this->w    )
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename BUF_TYPE         = GLenum>
    class NamedFramebufferDrawBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "buf"        )return(void*)&this->buf        ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE framebuffer;
        BUF_TYPE         buf        ;
        NamedFramebufferDrawBuffer(
            FRAMEBUFFER_TYPE const&framebuffer,
            BUF_TYPE         const&buf        ){
          this->framebuffer = framebuffer;
          this->buf         = buf        ;
        }
        virtual~NamedFramebufferDrawBuffer(){}
        virtual void operator()(){
          glNamedFramebufferDrawBuffer(
            ge::core::convertTo<GLuint>(this->framebuffer),
            ge::core::convertTo<GLenum>(this->buf        )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetQueryIndexediv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetQueryIndexediv(
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->index  = index ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetQueryIndexediv(){}
        virtual void operator()(){
          glGetQueryIndexediv(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLuint>(this->index ),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    template<
      typename SHADER_TYPE  = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename INFOLOG_TYPE = GLchar* >
    class GetShaderInfoLog:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "shader" )return(void*)&this->shader ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "length" )return(void*)&this->length ;
          if(name == "infoLog")return(void*)&this->infoLog;
          return NULL;
        }
      public:
        SHADER_TYPE  shader ;
        BUFSIZE_TYPE bufSize;
        LENGTH_TYPE  length ;
        INFOLOG_TYPE infoLog;
        GetShaderInfoLog(
            SHADER_TYPE  const&shader ,
            BUFSIZE_TYPE const&bufSize,
            LENGTH_TYPE  const&length ,
            INFOLOG_TYPE const&infoLog){
          this->shader  = shader ;
          this->bufSize = bufSize;
          this->length  = length ;
          this->infoLog = infoLog;
        }
        virtual~GetShaderInfoLog(){}
        virtual void operator()(){
          glGetShaderInfoLog(
            ge::core::convertTo<GLuint  >(this->shader ),
            ge::core::convertTo<GLsizei >(this->bufSize),
            ge::core::convertTo<GLsizei*>(this->length ),
            ge::core::convertTo<GLchar* >(this->infoLog)
          );
        }
    };

    template<
      typename IDENTIFIER_TYPE = GLenum       ,
      typename NAME_TYPE       = GLuint       ,
      typename LENGTH_TYPE     = GLsizei      ,
      typename LABEL_TYPE      = const GLchar*>
    class ObjectLabel:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "identifier")return(void*)&this->identifier;
          if(name == "name"      )return(void*)&this->name      ;
          if(name == "length"    )return(void*)&this->length    ;
          if(name == "label"     )return(void*)&this->label     ;
          return NULL;
        }
      public:
        IDENTIFIER_TYPE identifier;
        NAME_TYPE       name      ;
        LENGTH_TYPE     length    ;
        LABEL_TYPE      label     ;
        ObjectLabel(
            IDENTIFIER_TYPE const&identifier,
            NAME_TYPE       const&name      ,
            LENGTH_TYPE     const&length    ,
            LABEL_TYPE      const&label     ){
          this->identifier = identifier;
          this->name       = name      ;
          this->length     = length    ;
          this->label      = label     ;
        }
        virtual~ObjectLabel(){}
        virtual void operator()(){
          glObjectLabel(
            ge::core::convertTo<GLenum       >(this->identifier),
            ge::core::convertTo<GLuint       >(this->name      ),
            ge::core::convertTo<GLsizei      >(this->length    ),
            ge::core::convertTo<const GLchar*>(this->label     )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLint ,
      typename Y_TYPE     = GLint ,
      typename Z_TYPE     = GLint ,
      typename W_TYPE     = GLint >
    class VertexAttribI4i:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          if(name == "w"    )return(void*)&this->w    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        W_TYPE     w    ;
        VertexAttribI4i(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ,
            W_TYPE     const&w    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
          this->w     = w    ;
        }
        virtual~VertexAttribI4i(){}
        virtual void operator()(){
          glVertexAttribI4i(
            ge::core::convertTo<GLuint>(this->index),
            ge::core::convertTo<GLint >(this->x    ),
            ge::core::convertTo<GLint >(this->y    ),
            ge::core::convertTo<GLint >(this->z    ),
            ge::core::convertTo<GLint >(this->w    )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr,
      typename DATA_TYPE   = void*     >
    class GetBufferSubData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "offset")return(void*)&this->offset;
          if(name == "size"  )return(void*)&this->size  ;
          if(name == "data"  )return(void*)&this->data  ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        OFFSET_TYPE offset;
        SIZE_TYPE   size  ;
        DATA_TYPE   data  ;
        GetBufferSubData(
            TARGET_TYPE const&target,
            OFFSET_TYPE const&offset,
            SIZE_TYPE   const&size  ,
            DATA_TYPE   const&data  ){
          this->target = target;
          this->offset = offset;
          this->size   = size  ;
          this->data   = data  ;
        }
        virtual~GetBufferSubData(){}
        virtual void operator()(){
          glGetBufferSubData(
            ge::core::convertTo<GLenum    >(this->target),
            ge::core::convertTo<GLintptr  >(this->offset),
            ge::core::convertTo<GLsizeiptr>(this->size  ),
            ge::core::convertTo<void*     >(this->data  )
          );
        }
    };

    template<
      typename INDEX_TYPE  = GLuint   ,
      typename PNAME_TYPE  = GLenum   ,
      typename PARAMS_TYPE = GLdouble*>
    class GetVertexAttribLdv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index" )return(void*)&this->index ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        INDEX_TYPE  index ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetVertexAttribLdv(
            INDEX_TYPE  const&index ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->index  = index ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetVertexAttribLdv(){}
        virtual void operator()(){
          glGetVertexAttribLdv(
            ge::core::convertTo<GLuint   >(this->index ),
            ge::core::convertTo<GLenum   >(this->pname ),
            ge::core::convertTo<GLdouble*>(this->params)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename BUFSIZE_TYPE  = GLsizei,
      typename PARAMS_TYPE   = GLuint*>
    class GetnUniformuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "bufSize" )return(void*)&this->bufSize ;
          if(name == "params"  )return(void*)&this->params  ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        BUFSIZE_TYPE  bufSize ;
        PARAMS_TYPE   params  ;
        GetnUniformuiv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            BUFSIZE_TYPE  const&bufSize ,
            PARAMS_TYPE   const&params  ){
          this->program  = program ;
          this->location = location;
          this->bufSize  = bufSize ;
          this->params   = params  ;
        }
        virtual~GetnUniformuiv(){}
        virtual void operator()(){
          glGetnUniformuiv(
            ge::core::convertTo<GLuint >(this->program ),
            ge::core::convertTo<GLint  >(this->location),
            ge::core::convertTo<GLsizei>(this->bufSize ),
            ge::core::convertTo<GLuint*>(this->params  )
          );
        }
    };

    template<
      typename MODERGB_TYPE   = GLenum,
      typename MODEALPHA_TYPE = GLenum>
    class BlendEquationSeparate:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "modeRGB"  )return(void*)&this->modeRGB  ;
          if(name == "modeAlpha")return(void*)&this->modeAlpha;
          return NULL;
        }
      public:
        MODERGB_TYPE   modeRGB  ;
        MODEALPHA_TYPE modeAlpha;
        BlendEquationSeparate(
            MODERGB_TYPE   const&modeRGB  ,
            MODEALPHA_TYPE const&modeAlpha){
          this->modeRGB   = modeRGB  ;
          this->modeAlpha = modeAlpha;
        }
        virtual~BlendEquationSeparate(){}
        virtual void operator()(){
          glBlendEquationSeparate(
            ge::core::convertTo<GLenum>(this->modeRGB  ),
            ge::core::convertTo<GLenum>(this->modeAlpha)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLuint>
    class VertexAttribI1ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        VertexAttribI1ui(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ){
          this->index = index;
          this->x     = x    ;
        }
        virtual~VertexAttribI1ui(){}
        virtual void operator()(){
          glVertexAttribI1ui(
            ge::core::convertTo<GLuint>(this->index),
            ge::core::convertTo<GLuint>(this->x    )
          );
        }
    };

    template<
      typename N_TYPE       = GLsizei,
      typename BUFFERS_TYPE = GLuint*>
    class GenBuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"      )return(void*)&this->n      ;
          if(name == "buffers")return(void*)&this->buffers;
          return NULL;
        }
      public:
        N_TYPE       n      ;
        BUFFERS_TYPE buffers;
        GenBuffers(
            N_TYPE       const&n      ,
            BUFFERS_TYPE const&buffers){
          this->n       = n      ;
          this->buffers = buffers;
        }
        virtual~GenBuffers(){}
        virtual void operator()(){
          glGenBuffers(
            ge::core::convertTo<GLsizei>(this->n      ),
            ge::core::convertTo<GLuint*>(this->buffers)
          );
        }
    };

    template<
      typename RET_TYPE        = GLuint       ,
      typename PROGRAM_TYPE    = GLuint       ,
      typename SHADERTYPE_TYPE = GLenum       ,
      typename NAME_TYPE       = const GLchar*>
    class GetSubroutineIndex:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"       )return(void*)&this->ret       ;
          if(name == "program"   )return(void*)&this->program   ;
          if(name == "shadertype")return(void*)&this->shadertype;
          if(name == "name"      )return(void*)&this->name      ;
          return NULL;
        }
      public:
        RET_TYPE        ret       ;
        PROGRAM_TYPE    program   ;
        SHADERTYPE_TYPE shadertype;
        NAME_TYPE       name      ;
        GetSubroutineIndex(
            RET_TYPE        const&ret       ,
            PROGRAM_TYPE    const&program   ,
            SHADERTYPE_TYPE const&shadertype,
            NAME_TYPE       const&name      ){
          this->ret        = ret       ;
          this->program    = program   ;
          this->shadertype = shadertype;
          this->name       = name      ;
        }
        virtual~GetSubroutineIndex(){}
        virtual void operator()(){
          ge::core::convertFrom<GLuint>(this->ret,glGetSubroutineIndex(
              ge::core::convertTo<GLuint       >(this->program   ),
              ge::core::convertTo<GLenum       >(this->shadertype),
              ge::core::convertTo<const GLchar*>(this->name      ))
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    class VertexAttrib2sv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib2sv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib2sv(){}
        virtual void operator()(){
          glVertexAttrib2sv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLshort*>(this->v    )
          );
        }
    };

    template<
      typename SFACTOR_TYPE = GLenum,
      typename DFACTOR_TYPE = GLenum>
    class BlendFunc:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sfactor")return(void*)&this->sfactor;
          if(name == "dfactor")return(void*)&this->dfactor;
          return NULL;
        }
      public:
        SFACTOR_TYPE sfactor;
        DFACTOR_TYPE dfactor;
        BlendFunc(
            SFACTOR_TYPE const&sfactor,
            DFACTOR_TYPE const&dfactor){
          this->sfactor = sfactor;
          this->dfactor = dfactor;
        }
        virtual~BlendFunc(){}
        virtual void operator()(){
          glBlendFunc(
            ge::core::convertTo<GLenum>(this->sfactor),
            ge::core::convertTo<GLenum>(this->dfactor)
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE = GLuint      ,
      typename BUFFER_TYPE      = GLenum      ,
      typename DRAWBUFFER_TYPE  = GLint       ,
      typename VALUE_TYPE       = const GLint*>
    class ClearNamedFramebufferiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "buffer"     )return(void*)&this->buffer     ;
          if(name == "drawbuffer" )return(void*)&this->drawbuffer ;
          if(name == "value"      )return(void*)&this->value      ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE framebuffer;
        BUFFER_TYPE      buffer     ;
        DRAWBUFFER_TYPE  drawbuffer ;
        VALUE_TYPE       value      ;
        ClearNamedFramebufferiv(
            FRAMEBUFFER_TYPE const&framebuffer,
            BUFFER_TYPE      const&buffer     ,
            DRAWBUFFER_TYPE  const&drawbuffer ,
            VALUE_TYPE       const&value      ){
          this->framebuffer = framebuffer;
          this->buffer      = buffer     ;
          this->drawbuffer  = drawbuffer ;
          this->value       = value      ;
        }
        virtual~ClearNamedFramebufferiv(){}
        virtual void operator()(){
          glClearNamedFramebufferiv(
            ge::core::convertTo<GLuint      >(this->framebuffer),
            ge::core::convertTo<GLenum      >(this->buffer     ),
            ge::core::convertTo<GLint       >(this->drawbuffer ),
            ge::core::convertTo<const GLint*>(this->value      )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLint      ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename HEIGHT_TYPE         = GLsizei    ,
      typename DEPTH_TYPE          = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename PIXELS_TYPE         = const void*>
    class TexImage3D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "level"         )return(void*)&this->level         ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          if(name == "depth"         )return(void*)&this->depth         ;
          if(name == "border"        )return(void*)&this->border        ;
          if(name == "format"        )return(void*)&this->format        ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "pixels"        )return(void*)&this->pixels        ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        LEVEL_TYPE          level         ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        DEPTH_TYPE          depth         ;
        BORDER_TYPE         border        ;
        FORMAT_TYPE         format        ;
        TYPE_TYPE           type          ;
        PIXELS_TYPE         pixels        ;
        TexImage3D(
            TARGET_TYPE         const&target        ,
            LEVEL_TYPE          const&level         ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ,
            DEPTH_TYPE          const&depth         ,
            BORDER_TYPE         const&border        ,
            FORMAT_TYPE         const&format        ,
            TYPE_TYPE           const&type          ,
            PIXELS_TYPE         const&pixels        ){
          this->target         = target        ;
          this->level          = level         ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->height         = height        ;
          this->depth          = depth         ;
          this->border         = border        ;
          this->format         = format        ;
          this->type           = type          ;
          this->pixels         = pixels        ;
        }
        virtual~TexImage3D(){}
        virtual void operator()(){
          glTexImage3D(
            ge::core::convertTo<GLenum     >(this->target        ),
            ge::core::convertTo<GLint      >(this->level         ),
            ge::core::convertTo<GLint      >(this->internalformat),
            ge::core::convertTo<GLsizei    >(this->width         ),
            ge::core::convertTo<GLsizei    >(this->height        ),
            ge::core::convertTo<GLsizei    >(this->depth         ),
            ge::core::convertTo<GLint      >(this->border        ),
            ge::core::convertTo<GLenum     >(this->format        ),
            ge::core::convertTo<GLenum     >(this->type          ),
            ge::core::convertTo<const void*>(this->pixels        )
          );
        }
    };

    template<
      typename RET_TYPE         = GLboolean,
      typename FRAMEBUFFER_TYPE = GLuint   >
    class IsFramebuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"        )return(void*)&this->ret        ;
          if(name == "framebuffer")return(void*)&this->framebuffer;
          return NULL;
        }
      public:
        RET_TYPE         ret        ;
        FRAMEBUFFER_TYPE framebuffer;
        IsFramebuffer(
            RET_TYPE         const&ret        ,
            FRAMEBUFFER_TYPE const&framebuffer){
          this->ret         = ret        ;
          this->framebuffer = framebuffer;
        }
        virtual~IsFramebuffer(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsFramebuffer(
              ge::core::convertTo<GLuint   >(this->framebuffer))
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint>
    class PrimitiveRestartIndex:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        PrimitiveRestartIndex(
            INDEX_TYPE const&index){
          this->index = index;
        }
        virtual~PrimitiveRestartIndex(){}
        virtual void operator()(){
          glPrimitiveRestartIndex(
            ge::core::convertTo<GLuint>(this->index)
          );
        }
    };

    template<
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr>
    class FlushMappedNamedBufferRange:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "offset")return(void*)&this->offset;
          if(name == "length")return(void*)&this->length;
          return NULL;
        }
      public:
        BUFFER_TYPE buffer;
        OFFSET_TYPE offset;
        LENGTH_TYPE length;
        FlushMappedNamedBufferRange(
            BUFFER_TYPE const&buffer,
            OFFSET_TYPE const&offset,
            LENGTH_TYPE const&length){
          this->buffer = buffer;
          this->offset = offset;
          this->length = length;
        }
        virtual~FlushMappedNamedBufferRange(){}
        virtual void operator()(){
          glFlushMappedNamedBufferRange(
            ge::core::convertTo<GLuint    >(this->buffer),
            ge::core::convertTo<GLintptr  >(this->offset),
            ge::core::convertTo<GLsizeiptr>(this->length)
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei,
      typename DEPTH_TYPE   = GLsizei>
    class InvalidateTexSubImage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "yoffset")return(void*)&this->yoffset;
          if(name == "zoffset")return(void*)&this->zoffset;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          if(name == "depth"  )return(void*)&this->depth  ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        YOFFSET_TYPE yoffset;
        ZOFFSET_TYPE zoffset;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        DEPTH_TYPE   depth  ;
        InvalidateTexSubImage(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            YOFFSET_TYPE const&yoffset,
            ZOFFSET_TYPE const&zoffset,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ,
            DEPTH_TYPE   const&depth  ){
          this->texture = texture;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->yoffset = yoffset;
          this->zoffset = zoffset;
          this->width   = width  ;
          this->height  = height ;
          this->depth   = depth  ;
        }
        virtual~InvalidateTexSubImage(){}
        virtual void operator()(){
          glInvalidateTexSubImage(
            ge::core::convertTo<GLuint >(this->texture),
            ge::core::convertTo<GLint  >(this->level  ),
            ge::core::convertTo<GLint  >(this->xoffset),
            ge::core::convertTo<GLint  >(this->yoffset),
            ge::core::convertTo<GLint  >(this->zoffset),
            ge::core::convertTo<GLsizei>(this->width  ),
            ge::core::convertTo<GLsizei>(this->height ),
            ge::core::convertTo<GLsizei>(this->depth  )
          );
        }
    };

    template<
      typename PNAME_TYPE = GLenum  ,
      typename DATA_TYPE  = GLint64*>
    class GetInteger64v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname")return(void*)&this->pname;
          if(name == "data" )return(void*)&this->data ;
          return NULL;
        }
      public:
        PNAME_TYPE pname;
        DATA_TYPE  data ;
        GetInteger64v(
            PNAME_TYPE const&pname,
            DATA_TYPE  const&data ){
          this->pname = pname;
          this->data  = data ;
        }
        virtual~GetInteger64v(){}
        virtual void operator()(){
          glGetInteger64v(
            ge::core::convertTo<GLenum  >(this->pname),
            ge::core::convertTo<GLint64*>(this->data )
          );
        }
    };

    template<
      typename PIPELINE_TYPE = GLuint>
    class BindProgramPipeline:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pipeline")return(void*)&this->pipeline;
          return NULL;
        }
      public:
        PIPELINE_TYPE pipeline;
        BindProgramPipeline(
            PIPELINE_TYPE const&pipeline){
          this->pipeline = pipeline;
        }
        virtual~BindProgramPipeline(){}
        virtual void operator()(){
          glBindProgramPipeline(
            ge::core::convertTo<GLuint>(this->pipeline)
          );
        }
    };

    template<
      typename X_TYPE      = GLint  ,
      typename Y_TYPE      = GLint  ,
      typename WIDTH_TYPE  = GLsizei,
      typename HEIGHT_TYPE = GLsizei>
    class Scissor:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "x"     )return(void*)&this->x     ;
          if(name == "y"     )return(void*)&this->y     ;
          if(name == "width" )return(void*)&this->width ;
          if(name == "height")return(void*)&this->height;
          return NULL;
        }
      public:
        X_TYPE      x     ;
        Y_TYPE      y     ;
        WIDTH_TYPE  width ;
        HEIGHT_TYPE height;
        Scissor(
            X_TYPE      const&x     ,
            Y_TYPE      const&y     ,
            WIDTH_TYPE  const&width ,
            HEIGHT_TYPE const&height){
          this->x      = x     ;
          this->y      = y     ;
          this->width  = width ;
          this->height = height;
        }
        virtual~Scissor(){}
        virtual void operator()(){
          glScissor(
            ge::core::convertTo<GLint  >(this->x     ),
            ge::core::convertTo<GLint  >(this->y     ),
            ge::core::convertTo<GLsizei>(this->width ),
            ge::core::convertTo<GLsizei>(this->height)
          );
        }
    };

    template<
      typename PNAME_TYPE = GLenum    ,
      typename DATA_TYPE  = GLboolean*>
    class GetBooleanv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname")return(void*)&this->pname;
          if(name == "data" )return(void*)&this->data ;
          return NULL;
        }
      public:
        PNAME_TYPE pname;
        DATA_TYPE  data ;
        GetBooleanv(
            PNAME_TYPE const&pname,
            DATA_TYPE  const&data ){
          this->pname = pname;
          this->data  = data ;
        }
        virtual~GetBooleanv(){}
        virtual void operator()(){
          glGetBooleanv(
            ge::core::convertTo<GLenum    >(this->pname),
            ge::core::convertTo<GLboolean*>(this->data )
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE        = GLuint,
      typename ATTACHMENT_TYPE         = GLenum,
      typename RENDERBUFFERTARGET_TYPE = GLenum,
      typename RENDERBUFFER_TYPE       = GLuint>
    class NamedFramebufferRenderbuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer"       )return(void*)&this->framebuffer       ;
          if(name == "attachment"        )return(void*)&this->attachment        ;
          if(name == "renderbuffertarget")return(void*)&this->renderbuffertarget;
          if(name == "renderbuffer"      )return(void*)&this->renderbuffer      ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE        framebuffer       ;
        ATTACHMENT_TYPE         attachment        ;
        RENDERBUFFERTARGET_TYPE renderbuffertarget;
        RENDERBUFFER_TYPE       renderbuffer      ;
        NamedFramebufferRenderbuffer(
            FRAMEBUFFER_TYPE        const&framebuffer       ,
            ATTACHMENT_TYPE         const&attachment        ,
            RENDERBUFFERTARGET_TYPE const&renderbuffertarget,
            RENDERBUFFER_TYPE       const&renderbuffer      ){
          this->framebuffer        = framebuffer       ;
          this->attachment         = attachment        ;
          this->renderbuffertarget = renderbuffertarget;
          this->renderbuffer       = renderbuffer      ;
        }
        virtual~NamedFramebufferRenderbuffer(){}
        virtual void operator()(){
          glNamedFramebufferRenderbuffer(
            ge::core::convertTo<GLuint>(this->framebuffer       ),
            ge::core::convertTo<GLenum>(this->attachment        ),
            ge::core::convertTo<GLenum>(this->renderbuffertarget),
            ge::core::convertTo<GLuint>(this->renderbuffer      )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    class Uniform3uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform3uiv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform3uiv(){}
        virtual void operator()(){
          glUniform3uiv(
            ge::core::convertTo<GLint        >(this->location),
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->value   )
          );
        }
    };

    template<
      typename RED_TYPE   = GLfloat,
      typename GREEN_TYPE = GLfloat,
      typename BLUE_TYPE  = GLfloat,
      typename ALPHA_TYPE = GLfloat>
    class ClearColor:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "red"  )return(void*)&this->red  ;
          if(name == "green")return(void*)&this->green;
          if(name == "blue" )return(void*)&this->blue ;
          if(name == "alpha")return(void*)&this->alpha;
          return NULL;
        }
      public:
        RED_TYPE   red  ;
        GREEN_TYPE green;
        BLUE_TYPE  blue ;
        ALPHA_TYPE alpha;
        ClearColor(
            RED_TYPE   const&red  ,
            GREEN_TYPE const&green,
            BLUE_TYPE  const&blue ,
            ALPHA_TYPE const&alpha){
          this->red   = red  ;
          this->green = green;
          this->blue  = blue ;
          this->alpha = alpha;
        }
        virtual~ClearColor(){}
        virtual void operator()(){
          glClearColor(
            ge::core::convertTo<GLfloat>(this->red  ),
            ge::core::convertTo<GLfloat>(this->green),
            ge::core::convertTo<GLfloat>(this->blue ),
            ge::core::convertTo<GLfloat>(this->alpha)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    class VertexAttrib4Niv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4Niv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4Niv(){}
        virtual void operator()(){
          glVertexAttrib4Niv(
            ge::core::convertTo<GLuint      >(this->index),
            ge::core::convertTo<const GLint*>(this->v    )
          );
        }
    };

    template<
      typename BUFFER_TYPE     = GLenum      ,
      typename DRAWBUFFER_TYPE = GLint       ,
      typename VALUE_TYPE      = const GLint*>
    class ClearBufferiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer"    )return(void*)&this->buffer    ;
          if(name == "drawbuffer")return(void*)&this->drawbuffer;
          if(name == "value"     )return(void*)&this->value     ;
          return NULL;
        }
      public:
        BUFFER_TYPE     buffer    ;
        DRAWBUFFER_TYPE drawbuffer;
        VALUE_TYPE      value     ;
        ClearBufferiv(
            BUFFER_TYPE     const&buffer    ,
            DRAWBUFFER_TYPE const&drawbuffer,
            VALUE_TYPE      const&value     ){
          this->buffer     = buffer    ;
          this->drawbuffer = drawbuffer;
          this->value      = value     ;
        }
        virtual~ClearBufferiv(){}
        virtual void operator()(){
          glClearBufferiv(
            ge::core::convertTo<GLenum      >(this->buffer    ),
            ge::core::convertTo<GLint       >(this->drawbuffer),
            ge::core::convertTo<const GLint*>(this->value     )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLint64*>
    class GetBufferParameteri64v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetBufferParameteri64v(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetBufferParameteri64v(){}
        virtual void operator()(){
          glGetBufferParameteri64v(
            ge::core::convertTo<GLenum  >(this->target),
            ge::core::convertTo<GLenum  >(this->pname ),
            ge::core::convertTo<GLint64*>(this->params)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint         ,
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    class ProgramUniform4dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform4dv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform4dv(){}
        virtual void operator()(){
          glProgramUniform4dv(
            ge::core::convertTo<GLuint         >(this->program ),
            ge::core::convertTo<GLint          >(this->location),
            ge::core::convertTo<GLsizei        >(this->count   ),
            ge::core::convertTo<const GLdouble*>(this->value   )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint,
      typename LEVEL_TYPE   = GLint ,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    class GetTextureLevelParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        GetTextureLevelParameteriv(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->texture = texture;
          this->level   = level  ;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~GetTextureLevelParameteriv(){}
        virtual void operator()(){
          glGetTextureLevelParameteriv(
            ge::core::convertTo<GLuint>(this->texture),
            ge::core::convertTo<GLint >(this->level  ),
            ge::core::convertTo<GLenum>(this->pname  ),
            ge::core::convertTo<GLint*>(this->params )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename BUFSIZE_TYPE  = GLsizei,
      typename PARAMS_TYPE   = GLint* >
    class GetnUniformiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "bufSize" )return(void*)&this->bufSize ;
          if(name == "params"  )return(void*)&this->params  ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        BUFSIZE_TYPE  bufSize ;
        PARAMS_TYPE   params  ;
        GetnUniformiv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            BUFSIZE_TYPE  const&bufSize ,
            PARAMS_TYPE   const&params  ){
          this->program  = program ;
          this->location = location;
          this->bufSize  = bufSize ;
          this->params   = params  ;
        }
        virtual~GetnUniformiv(){}
        virtual void operator()(){
          glGetnUniformiv(
            ge::core::convertTo<GLuint >(this->program ),
            ge::core::convertTo<GLint  >(this->location),
            ge::core::convertTo<GLsizei>(this->bufSize ),
            ge::core::convertTo<GLint* >(this->params  )
          );
        }
    };

    template<
      typename RET_TYPE   = const GLubyte*,
      typename NAME_TYPE  = GLenum        ,
      typename INDEX_TYPE = GLuint        >
    class GetStringi:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"  )return(void*)&this->ret  ;
          if(name == "name" )return(void*)&this->name ;
          if(name == "index")return(void*)&this->index;
          return NULL;
        }
      public:
        RET_TYPE   ret  ;
        NAME_TYPE  name ;
        INDEX_TYPE index;
        GetStringi(
            RET_TYPE   const&ret  ,
            NAME_TYPE  const&name ,
            INDEX_TYPE const&index){
          this->ret   = ret  ;
          this->name  = name ;
          this->index = index;
        }
        virtual~GetStringi(){}
        virtual void operator()(){
          ge::core::convertFrom<const GLubyte*>(this->ret,glGetStringi(
              ge::core::convertTo<GLenum        >(this->name ),
              ge::core::convertTo<GLuint        >(this->index))
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint,
      typename V2_TYPE       = GLuint>
    class Uniform3ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        Uniform3ui(
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ){
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
        }
        virtual~Uniform3ui(){}
        virtual void operator()(){
          glUniform3ui(
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLuint>(this->v0      ),
            ge::core::convertTo<GLuint>(this->v1      ),
            ge::core::convertTo<GLuint>(this->v2      )
          );
        }
    };

    template<
      typename VAOBJ_TYPE = GLuint,
      typename INDEX_TYPE = GLuint,
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint*>
    class GetVertexArrayIndexediv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj")return(void*)&this->vaobj;
          if(name == "index")return(void*)&this->index;
          if(name == "pname")return(void*)&this->pname;
          if(name == "param")return(void*)&this->param;
          return NULL;
        }
      public:
        VAOBJ_TYPE vaobj;
        INDEX_TYPE index;
        PNAME_TYPE pname;
        PARAM_TYPE param;
        GetVertexArrayIndexediv(
            VAOBJ_TYPE const&vaobj,
            INDEX_TYPE const&index,
            PNAME_TYPE const&pname,
            PARAM_TYPE const&param){
          this->vaobj = vaobj;
          this->index = index;
          this->pname = pname;
          this->param = param;
        }
        virtual~GetVertexArrayIndexediv(){}
        virtual void operator()(){
          glGetVertexArrayIndexediv(
            ge::core::convertTo<GLuint>(this->vaobj),
            ge::core::convertTo<GLuint>(this->index),
            ge::core::convertTo<GLenum>(this->pname),
            ge::core::convertTo<GLint*>(this->param)
          );
        }
    };

    template<
      typename PNAME_TYPE  = GLenum        ,
      typename PARAMS_TYPE = const GLfloat*>
    class PointParameterfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        PointParameterfv(
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->pname  = pname ;
          this->params = params;
        }
        virtual~PointParameterfv(){}
        virtual void operator()(){
          glPointParameterfv(
            ge::core::convertTo<GLenum        >(this->pname ),
            ge::core::convertTo<const GLfloat*>(this->params)
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    class Uniform2fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform2fv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform2fv(){}
        virtual void operator()(){
          glUniform2fv(
            ge::core::convertTo<GLint         >(this->location),
            ge::core::convertTo<GLsizei       >(this->count   ),
            ge::core::convertTo<const GLfloat*>(this->value   )
          );
        }
    };

    template<
      typename PROGRAM_TYPE    = GLuint  ,
      typename SHADERTYPE_TYPE = GLenum  ,
      typename INDEX_TYPE      = GLuint  ,
      typename BUFSIZE_TYPE    = GLsizei ,
      typename LENGTH_TYPE     = GLsizei*,
      typename NAME_TYPE       = GLchar* >
    class GetActiveSubroutineUniformName:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"   )return(void*)&this->program   ;
          if(name == "shadertype")return(void*)&this->shadertype;
          if(name == "index"     )return(void*)&this->index     ;
          if(name == "bufsize"   )return(void*)&this->bufsize   ;
          if(name == "length"    )return(void*)&this->length    ;
          if(name == "name"      )return(void*)&this->name      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE    program   ;
        SHADERTYPE_TYPE shadertype;
        INDEX_TYPE      index     ;
        BUFSIZE_TYPE    bufsize   ;
        LENGTH_TYPE     length    ;
        NAME_TYPE       name      ;
        GetActiveSubroutineUniformName(
            PROGRAM_TYPE    const&program   ,
            SHADERTYPE_TYPE const&shadertype,
            INDEX_TYPE      const&index     ,
            BUFSIZE_TYPE    const&bufsize   ,
            LENGTH_TYPE     const&length    ,
            NAME_TYPE       const&name      ){
          this->program    = program   ;
          this->shadertype = shadertype;
          this->index      = index     ;
          this->bufsize    = bufsize   ;
          this->length     = length    ;
          this->name       = name      ;
        }
        virtual~GetActiveSubroutineUniformName(){}
        virtual void operator()(){
          glGetActiveSubroutineUniformName(
            ge::core::convertTo<GLuint  >(this->program   ),
            ge::core::convertTo<GLenum  >(this->shadertype),
            ge::core::convertTo<GLuint  >(this->index     ),
            ge::core::convertTo<GLsizei >(this->bufsize   ),
            ge::core::convertTo<GLsizei*>(this->length    ),
            ge::core::convertTo<GLchar* >(this->name      )
          );
        }
    };

    template<
      typename RET_TYPE              = GLuint       ,
      typename PROGRAM_TYPE          = GLuint       ,
      typename PROGRAMINTERFACE_TYPE = GLenum       ,
      typename NAME_TYPE             = const GLchar*>
    class GetProgramResourceIndex:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"             )return(void*)&this->ret             ;
          if(name == "program"         )return(void*)&this->program         ;
          if(name == "programInterface")return(void*)&this->programInterface;
          if(name == "name"            )return(void*)&this->name            ;
          return NULL;
        }
      public:
        RET_TYPE              ret             ;
        PROGRAM_TYPE          program         ;
        PROGRAMINTERFACE_TYPE programInterface;
        NAME_TYPE             name            ;
        GetProgramResourceIndex(
            RET_TYPE              const&ret             ,
            PROGRAM_TYPE          const&program         ,
            PROGRAMINTERFACE_TYPE const&programInterface,
            NAME_TYPE             const&name            ){
          this->ret              = ret             ;
          this->program          = program         ;
          this->programInterface = programInterface;
          this->name             = name            ;
        }
        virtual~GetProgramResourceIndex(){}
        virtual void operator()(){
          ge::core::convertFrom<GLuint>(this->ret,glGetProgramResourceIndex(
              ge::core::convertTo<GLuint       >(this->program         ),
              ge::core::convertTo<GLenum       >(this->programInterface),
              ge::core::convertTo<const GLchar*>(this->name            ))
          );
        }
    };

    template<
      typename MODE_TYPE     = GLenum     ,
      typename TYPE_TYPE     = GLenum     ,
      typename INDIRECT_TYPE = const void*>
    class DrawElementsIndirect:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"    )return(void*)&this->mode    ;
          if(name == "type"    )return(void*)&this->type    ;
          if(name == "indirect")return(void*)&this->indirect;
          return NULL;
        }
      public:
        MODE_TYPE     mode    ;
        TYPE_TYPE     type    ;
        INDIRECT_TYPE indirect;
        DrawElementsIndirect(
            MODE_TYPE     const&mode    ,
            TYPE_TYPE     const&type    ,
            INDIRECT_TYPE const&indirect){
          this->mode     = mode    ;
          this->type     = type    ;
          this->indirect = indirect;
        }
        virtual~DrawElementsIndirect(){}
        virtual void operator()(){
          glDrawElementsIndirect(
            ge::core::convertTo<GLenum     >(this->mode    ),
            ge::core::convertTo<GLenum     >(this->type    ),
            ge::core::convertTo<const void*>(this->indirect)
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint  ,
      typename LEVEL_TYPE   = GLint   ,
      typename PNAME_TYPE   = GLenum  ,
      typename PARAMS_TYPE  = GLfloat*>
    class GetTextureLevelParameterfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        GetTextureLevelParameterfv(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->texture = texture;
          this->level   = level  ;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~GetTextureLevelParameterfv(){}
        virtual void operator()(){
          glGetTextureLevelParameterfv(
            ge::core::convertTo<GLuint  >(this->texture),
            ge::core::convertTo<GLint   >(this->level  ),
            ge::core::convertTo<GLenum  >(this->pname  ),
            ge::core::convertTo<GLfloat*>(this->params )
          );
        }
    };

    template<
      typename BUFFER_TYPE = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = void**>
    class GetNamedBufferPointerv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        BUFFER_TYPE buffer;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetNamedBufferPointerv(
            BUFFER_TYPE const&buffer,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->buffer = buffer;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetNamedBufferPointerv(){}
        virtual void operator()(){
          glGetNamedBufferPointerv(
            ge::core::convertTo<GLuint>(this->buffer),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<void**>(this->params)
          );
        }
    };

    template<
      typename INDIRECT_TYPE = GLintptr>
    class DispatchComputeIndirect:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "indirect")return(void*)&this->indirect;
          return NULL;
        }
      public:
        INDIRECT_TYPE indirect;
        DispatchComputeIndirect(
            INDIRECT_TYPE const&indirect){
          this->indirect = indirect;
        }
        virtual~DispatchComputeIndirect(){}
        virtual void operator()(){
          glDispatchComputeIndirect(
            ge::core::convertTo<GLintptr>(this->indirect)
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE    = GLuint       ,
      typename NUMATTACHMENTS_TYPE = GLsizei      ,
      typename ATTACHMENTS_TYPE    = const GLenum*,
      typename X_TYPE              = GLint        ,
      typename Y_TYPE              = GLint        ,
      typename WIDTH_TYPE          = GLsizei      ,
      typename HEIGHT_TYPE         = GLsizei      >
    class InvalidateNamedFramebufferSubData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer"   )return(void*)&this->framebuffer   ;
          if(name == "numAttachments")return(void*)&this->numAttachments;
          if(name == "attachments"   )return(void*)&this->attachments   ;
          if(name == "x"             )return(void*)&this->x             ;
          if(name == "y"             )return(void*)&this->y             ;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE    framebuffer   ;
        NUMATTACHMENTS_TYPE numAttachments;
        ATTACHMENTS_TYPE    attachments   ;
        X_TYPE              x             ;
        Y_TYPE              y             ;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        InvalidateNamedFramebufferSubData(
            FRAMEBUFFER_TYPE    const&framebuffer   ,
            NUMATTACHMENTS_TYPE const&numAttachments,
            ATTACHMENTS_TYPE    const&attachments   ,
            X_TYPE              const&x             ,
            Y_TYPE              const&y             ,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ){
          this->framebuffer    = framebuffer   ;
          this->numAttachments = numAttachments;
          this->attachments    = attachments   ;
          this->x              = x             ;
          this->y              = y             ;
          this->width          = width         ;
          this->height         = height        ;
        }
        virtual~InvalidateNamedFramebufferSubData(){}
        virtual void operator()(){
          glInvalidateNamedFramebufferSubData(
            ge::core::convertTo<GLuint       >(this->framebuffer   ),
            ge::core::convertTo<GLsizei      >(this->numAttachments),
            ge::core::convertTo<const GLenum*>(this->attachments   ),
            ge::core::convertTo<GLint        >(this->x             ),
            ge::core::convertTo<GLint        >(this->y             ),
            ge::core::convertTo<GLsizei      >(this->width         ),
            ge::core::convertTo<GLsizei      >(this->height        )
          );
        }
    };

    template<
      typename SAMPLER_TYPE = GLuint ,
      typename PNAME_TYPE   = GLenum ,
      typename PARAMS_TYPE  = GLuint*>
    class GetSamplerParameterIuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sampler")return(void*)&this->sampler;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        SAMPLER_TYPE sampler;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        GetSamplerParameterIuiv(
            SAMPLER_TYPE const&sampler,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->sampler = sampler;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~GetSamplerParameterIuiv(){}
        virtual void operator()(){
          glGetSamplerParameterIuiv(
            ge::core::convertTo<GLuint >(this->sampler),
            ge::core::convertTo<GLenum >(this->pname  ),
            ge::core::convertTo<GLuint*>(this->params )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum    ,
      typename INDEX_TYPE  = GLuint    ,
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr>
    class BindBufferRange:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "offset")return(void*)&this->offset;
          if(name == "size"  )return(void*)&this->size  ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        BUFFER_TYPE buffer;
        OFFSET_TYPE offset;
        SIZE_TYPE   size  ;
        BindBufferRange(
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ,
            BUFFER_TYPE const&buffer,
            OFFSET_TYPE const&offset,
            SIZE_TYPE   const&size  ){
          this->target = target;
          this->index  = index ;
          this->buffer = buffer;
          this->offset = offset;
          this->size   = size  ;
        }
        virtual~BindBufferRange(){}
        virtual void operator()(){
          glBindBufferRange(
            ge::core::convertTo<GLenum    >(this->target),
            ge::core::convertTo<GLuint    >(this->index ),
            ge::core::convertTo<GLuint    >(this->buffer),
            ge::core::convertTo<GLintptr  >(this->offset),
            ge::core::convertTo<GLsizeiptr>(this->size  )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    class TextureSubImage1D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "format" )return(void*)&this->format ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "pixels" )return(void*)&this->pixels ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        WIDTH_TYPE   width  ;
        FORMAT_TYPE  format ;
        TYPE_TYPE    type   ;
        PIXELS_TYPE  pixels ;
        TextureSubImage1D(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            WIDTH_TYPE   const&width  ,
            FORMAT_TYPE  const&format ,
            TYPE_TYPE    const&type   ,
            PIXELS_TYPE  const&pixels ){
          this->texture = texture;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->width   = width  ;
          this->format  = format ;
          this->type    = type   ;
          this->pixels  = pixels ;
        }
        virtual~TextureSubImage1D(){}
        virtual void operator()(){
          glTextureSubImage1D(
            ge::core::convertTo<GLuint     >(this->texture),
            ge::core::convertTo<GLint      >(this->level  ),
            ge::core::convertTo<GLint      >(this->xoffset),
            ge::core::convertTo<GLsizei    >(this->width  ),
            ge::core::convertTo<GLenum     >(this->format ),
            ge::core::convertTo<GLenum     >(this->type   ),
            ge::core::convertTo<const void*>(this->pixels )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    class VertexAttribL3dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribL3dv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribL3dv(){}
        virtual void operator()(){
          glVertexAttribL3dv(
            ge::core::convertTo<GLuint         >(this->index),
            ge::core::convertTo<const GLdouble*>(this->v    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint   ,
      typename LOCATION_TYPE = GLint    ,
      typename PARAMS_TYPE   = GLdouble*>
    class GetUniformdv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "params"  )return(void*)&this->params  ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        PARAMS_TYPE   params  ;
        GetUniformdv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            PARAMS_TYPE   const&params  ){
          this->program  = program ;
          this->location = location;
          this->params   = params  ;
        }
        virtual~GetUniformdv(){}
        virtual void operator()(){
          glGetUniformdv(
            ge::core::convertTo<GLuint   >(this->program ),
            ge::core::convertTo<GLint    >(this->location),
            ge::core::convertTo<GLdouble*>(this->params  )
          );
        }
    };

    template<
      typename ID_TYPE     = GLuint  ,
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename OFFSET_TYPE = GLintptr>
    class GetQueryBufferObjectui64v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "id"    )return(void*)&this->id    ;
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "offset")return(void*)&this->offset;
          return NULL;
        }
      public:
        ID_TYPE     id    ;
        BUFFER_TYPE buffer;
        PNAME_TYPE  pname ;
        OFFSET_TYPE offset;
        GetQueryBufferObjectui64v(
            ID_TYPE     const&id    ,
            BUFFER_TYPE const&buffer,
            PNAME_TYPE  const&pname ,
            OFFSET_TYPE const&offset){
          this->id     = id    ;
          this->buffer = buffer;
          this->pname  = pname ;
          this->offset = offset;
        }
        virtual~GetQueryBufferObjectui64v(){}
        virtual void operator()(){
          glGetQueryBufferObjectui64v(
            ge::core::convertTo<GLuint  >(this->id    ),
            ge::core::convertTo<GLuint  >(this->buffer),
            ge::core::convertTo<GLenum  >(this->pname ),
            ge::core::convertTo<GLintptr>(this->offset)
          );
        }
    };

    template<
      typename D_TYPE = GLfloat>
    class ClearDepthf:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "d")return(void*)&this->d;
          return NULL;
        }
      public:
        D_TYPE d;
        ClearDepthf(
            D_TYPE const&d){
          this->d = d;
        }
        virtual~ClearDepthf(){}
        virtual void operator()(){
          glClearDepthf(
            ge::core::convertTo<GLfloat>(this->d)
          );
        }
    };

    template<
      typename INDEX_TYPE  = GLuint ,
      typename PNAME_TYPE  = GLenum ,
      typename PARAMS_TYPE = GLuint*>
    class GetVertexAttribIuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index" )return(void*)&this->index ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        INDEX_TYPE  index ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetVertexAttribIuiv(
            INDEX_TYPE  const&index ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->index  = index ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetVertexAttribIuiv(){}
        virtual void operator()(){
          glGetVertexAttribIuiv(
            ge::core::convertTo<GLuint >(this->index ),
            ge::core::convertTo<GLenum >(this->pname ),
            ge::core::convertTo<GLuint*>(this->params)
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class UniformMatrix2x3fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix2x3fv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix2x3fv(){}
        virtual void operator()(){
          glUniformMatrix2x3fv(
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename N_TYPE   = GLsizei,
      typename IDS_TYPE = GLuint*>
    class GenTransformFeedbacks:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"  )return(void*)&this->n  ;
          if(name == "ids")return(void*)&this->ids;
          return NULL;
        }
      public:
        N_TYPE   n  ;
        IDS_TYPE ids;
        GenTransformFeedbacks(
            N_TYPE   const&n  ,
            IDS_TYPE const&ids){
          this->n   = n  ;
          this->ids = ids;
        }
        virtual~GenTransformFeedbacks(){}
        virtual void operator()(){
          glGenTransformFeedbacks(
            ge::core::convertTo<GLsizei>(this->n  ),
            ge::core::convertTo<GLuint*>(this->ids)
          );
        }
    };

    template<
      typename N_TYPE             = GLsizei,
      typename RENDERBUFFERS_TYPE = GLuint*>
    class CreateRenderbuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"            )return(void*)&this->n            ;
          if(name == "renderbuffers")return(void*)&this->renderbuffers;
          return NULL;
        }
      public:
        N_TYPE             n            ;
        RENDERBUFFERS_TYPE renderbuffers;
        CreateRenderbuffers(
            N_TYPE             const&n            ,
            RENDERBUFFERS_TYPE const&renderbuffers){
          this->n             = n            ;
          this->renderbuffers = renderbuffers;
        }
        virtual~CreateRenderbuffers(){}
        virtual void operator()(){
          glCreateRenderbuffers(
            ge::core::convertTo<GLsizei>(this->n            ),
            ge::core::convertTo<GLuint*>(this->renderbuffers)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLushort*>
    class VertexAttrib4Nusv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4Nusv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4Nusv(){}
        virtual void operator()(){
          glVertexAttrib4Nusv(
            ge::core::convertTo<GLuint         >(this->index),
            ge::core::convertTo<const GLushort*>(this->v    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class ProgramUniformMatrix4x3dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix4x3dv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix4x3dv(){}
        virtual void operator()(){
          glProgramUniformMatrix4x3dv(
            ge::core::convertTo<GLuint         >(this->program  ),
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename RED_TYPE   = GLboolean,
      typename GREEN_TYPE = GLboolean,
      typename BLUE_TYPE  = GLboolean,
      typename ALPHA_TYPE = GLboolean>
    class ColorMask:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "red"  )return(void*)&this->red  ;
          if(name == "green")return(void*)&this->green;
          if(name == "blue" )return(void*)&this->blue ;
          if(name == "alpha")return(void*)&this->alpha;
          return NULL;
        }
      public:
        RED_TYPE   red  ;
        GREEN_TYPE green;
        BLUE_TYPE  blue ;
        ALPHA_TYPE alpha;
        ColorMask(
            RED_TYPE   const&red  ,
            GREEN_TYPE const&green,
            BLUE_TYPE  const&blue ,
            ALPHA_TYPE const&alpha){
          this->red   = red  ;
          this->green = green;
          this->blue  = blue ;
          this->alpha = alpha;
        }
        virtual~ColorMask(){}
        virtual void operator()(){
          glColorMask(
            ge::core::convertTo<GLboolean>(this->red  ),
            ge::core::convertTo<GLboolean>(this->green),
            ge::core::convertTo<GLboolean>(this->blue ),
            ge::core::convertTo<GLboolean>(this->alpha)
          );
        }
    };

    template<
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei,
      typename FORMAT_TYPE  = GLenum ,
      typename TYPE_TYPE    = GLenum ,
      typename BUFSIZE_TYPE = GLsizei,
      typename DATA_TYPE    = void*  >
    class ReadnPixels:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "x"      )return(void*)&this->x      ;
          if(name == "y"      )return(void*)&this->y      ;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          if(name == "format" )return(void*)&this->format ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "data"   )return(void*)&this->data   ;
          return NULL;
        }
      public:
        X_TYPE       x      ;
        Y_TYPE       y      ;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        FORMAT_TYPE  format ;
        TYPE_TYPE    type   ;
        BUFSIZE_TYPE bufSize;
        DATA_TYPE    data   ;
        ReadnPixels(
            X_TYPE       const&x      ,
            Y_TYPE       const&y      ,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ,
            FORMAT_TYPE  const&format ,
            TYPE_TYPE    const&type   ,
            BUFSIZE_TYPE const&bufSize,
            DATA_TYPE    const&data   ){
          this->x       = x      ;
          this->y       = y      ;
          this->width   = width  ;
          this->height  = height ;
          this->format  = format ;
          this->type    = type   ;
          this->bufSize = bufSize;
          this->data    = data   ;
        }
        virtual~ReadnPixels(){}
        virtual void operator()(){
          glReadnPixels(
            ge::core::convertTo<GLint  >(this->x      ),
            ge::core::convertTo<GLint  >(this->y      ),
            ge::core::convertTo<GLsizei>(this->width  ),
            ge::core::convertTo<GLsizei>(this->height ),
            ge::core::convertTo<GLenum >(this->format ),
            ge::core::convertTo<GLenum >(this->type   ),
            ge::core::convertTo<GLsizei>(this->bufSize),
            ge::core::convertTo<void*  >(this->data   )
          );
        }
    };

    template<
      typename RET_TYPE   = GLboolean,
      typename ARRAY_TYPE = GLuint   >
    class IsVertexArray:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"  )return(void*)&this->ret  ;
          if(name == "array")return(void*)&this->array;
          return NULL;
        }
      public:
        RET_TYPE   ret  ;
        ARRAY_TYPE array;
        IsVertexArray(
            RET_TYPE   const&ret  ,
            ARRAY_TYPE const&array){
          this->ret   = ret  ;
          this->array = array;
        }
        virtual~IsVertexArray(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsVertexArray(
              ge::core::convertTo<GLuint   >(this->array))
          );
        }
    };

    template<
      typename PROGRAM_TYPE      = GLuint     ,
      typename BINARYFORMAT_TYPE = GLenum     ,
      typename BINARY_TYPE       = const void*,
      typename LENGTH_TYPE       = GLsizei    >
    class ProgramBinary:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"     )return(void*)&this->program     ;
          if(name == "binaryFormat")return(void*)&this->binaryFormat;
          if(name == "binary"      )return(void*)&this->binary      ;
          if(name == "length"      )return(void*)&this->length      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE      program     ;
        BINARYFORMAT_TYPE binaryFormat;
        BINARY_TYPE       binary      ;
        LENGTH_TYPE       length      ;
        ProgramBinary(
            PROGRAM_TYPE      const&program     ,
            BINARYFORMAT_TYPE const&binaryFormat,
            BINARY_TYPE       const&binary      ,
            LENGTH_TYPE       const&length      ){
          this->program      = program     ;
          this->binaryFormat = binaryFormat;
          this->binary       = binary      ;
          this->length       = length      ;
        }
        virtual~ProgramBinary(){}
        virtual void operator()(){
          glProgramBinary(
            ge::core::convertTo<GLuint     >(this->program     ),
            ge::core::convertTo<GLenum     >(this->binaryFormat),
            ge::core::convertTo<const void*>(this->binary      ),
            ge::core::convertTo<GLsizei    >(this->length      )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLbyte*>
    class VertexAttribI4bv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribI4bv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribI4bv(){}
        virtual void operator()(){
          glVertexAttribI4bv(
            ge::core::convertTo<GLuint       >(this->index),
            ge::core::convertTo<const GLbyte*>(this->v    )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLfloat*>
    class GetTexParameterfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetTexParameterfv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetTexParameterfv(){}
        virtual void operator()(){
          glGetTexParameterfv(
            ge::core::convertTo<GLenum  >(this->target),
            ge::core::convertTo<GLenum  >(this->pname ),
            ge::core::convertTo<GLfloat*>(this->params)
          );
        }
    };

    template<
      typename BUF_TYPE = GLuint,
      typename SRC_TYPE = GLenum,
      typename DST_TYPE = GLenum>
    class BlendFunci:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buf")return(void*)&this->buf;
          if(name == "src")return(void*)&this->src;
          if(name == "dst")return(void*)&this->dst;
          return NULL;
        }
      public:
        BUF_TYPE buf;
        SRC_TYPE src;
        DST_TYPE dst;
        BlendFunci(
            BUF_TYPE const&buf,
            SRC_TYPE const&src,
            DST_TYPE const&dst){
          this->buf = buf;
          this->src = src;
          this->dst = dst;
        }
        virtual~BlendFunci(){}
        virtual void operator()(){
          glBlendFunci(
            ge::core::convertTo<GLuint>(this->buf),
            ge::core::convertTo<GLenum>(this->src),
            ge::core::convertTo<GLenum>(this->dst)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum     ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*,
      typename FLAGS_TYPE  = GLbitfield >
    class BufferStorage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "size"  )return(void*)&this->size  ;
          if(name == "data"  )return(void*)&this->data  ;
          if(name == "flags" )return(void*)&this->flags ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        SIZE_TYPE   size  ;
        DATA_TYPE   data  ;
        FLAGS_TYPE  flags ;
        BufferStorage(
            TARGET_TYPE const&target,
            SIZE_TYPE   const&size  ,
            DATA_TYPE   const&data  ,
            FLAGS_TYPE  const&flags ){
          this->target = target;
          this->size   = size  ;
          this->data   = data  ;
          this->flags  = flags ;
        }
        virtual~BufferStorage(){}
        virtual void operator()(){
          glBufferStorage(
            ge::core::convertTo<GLenum     >(this->target),
            ge::core::convertTo<GLsizeiptr >(this->size  ),
            ge::core::convertTo<const void*>(this->data  ),
            ge::core::convertTo<GLbitfield >(this->flags )
          );
        }
    };

    template<
      typename RET_TYPE     = GLenum    ,
      typename SYNC_TYPE    = GLsync    ,
      typename FLAGS_TYPE   = GLbitfield,
      typename TIMEOUT_TYPE = GLuint64  >
    class ClientWaitSync:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"    )return(void*)&this->ret    ;
          if(name == "sync"   )return(void*)&this->sync   ;
          if(name == "flags"  )return(void*)&this->flags  ;
          if(name == "timeout")return(void*)&this->timeout;
          return NULL;
        }
      public:
        RET_TYPE     ret    ;
        SYNC_TYPE    sync   ;
        FLAGS_TYPE   flags  ;
        TIMEOUT_TYPE timeout;
        ClientWaitSync(
            RET_TYPE     const&ret    ,
            SYNC_TYPE    const&sync   ,
            FLAGS_TYPE   const&flags  ,
            TIMEOUT_TYPE const&timeout){
          this->ret     = ret    ;
          this->sync    = sync   ;
          this->flags   = flags  ;
          this->timeout = timeout;
        }
        virtual~ClientWaitSync(){}
        virtual void operator()(){
          ge::core::convertFrom<GLenum>(this->ret,glClientWaitSync(
              ge::core::convertTo<GLsync    >(this->sync   ),
              ge::core::convertTo<GLbitfield>(this->flags  ),
              ge::core::convertTo<GLuint64  >(this->timeout))
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLuint,
      typename Y_TYPE     = GLuint,
      typename Z_TYPE     = GLuint,
      typename W_TYPE     = GLuint>
    class VertexAttribI4ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          if(name == "z"    )return(void*)&this->z    ;
          if(name == "w"    )return(void*)&this->w    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        Z_TYPE     z    ;
        W_TYPE     w    ;
        VertexAttribI4ui(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ,
            Z_TYPE     const&z    ,
            W_TYPE     const&w    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
          this->z     = z    ;
          this->w     = w    ;
        }
        virtual~VertexAttribI4ui(){}
        virtual void operator()(){
          glVertexAttribI4ui(
            ge::core::convertTo<GLuint>(this->index),
            ge::core::convertTo<GLuint>(this->x    ),
            ge::core::convertTo<GLuint>(this->y    ),
            ge::core::convertTo<GLuint>(this->z    ),
            ge::core::convertTo<GLuint>(this->w    )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum  ,
      typename INDEX_TYPE  = GLuint  ,
      typename DATA_TYPE   = GLfloat*>
    class GetFloati_v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          if(name == "data"  )return(void*)&this->data  ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        DATA_TYPE   data  ;
        GetFloati_v(
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ,
            DATA_TYPE   const&data  ){
          this->target = target;
          this->index  = index ;
          this->data   = data  ;
        }
        virtual~GetFloati_v(){}
        virtual void operator()(){
          glGetFloati_v(
            ge::core::convertTo<GLenum  >(this->target),
            ge::core::convertTo<GLuint  >(this->index ),
            ge::core::convertTo<GLfloat*>(this->data  )
          );
        }
    };

    template<
      typename FUNC_TYPE = GLenum>
    class DepthFunc:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "func")return(void*)&this->func;
          return NULL;
        }
      public:
        FUNC_TYPE func;
        DepthFunc(
            FUNC_TYPE const&func){
          this->func = func;
        }
        virtual~DepthFunc(){}
        virtual void operator()(){
          glDepthFunc(
            ge::core::convertTo<GLenum>(this->func)
          );
        }
    };

    template<
      typename VAOBJ_TYPE = GLuint  ,
      typename INDEX_TYPE = GLuint  ,
      typename PNAME_TYPE = GLenum  ,
      typename PARAM_TYPE = GLint64*>
    class GetVertexArrayIndexed64iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj")return(void*)&this->vaobj;
          if(name == "index")return(void*)&this->index;
          if(name == "pname")return(void*)&this->pname;
          if(name == "param")return(void*)&this->param;
          return NULL;
        }
      public:
        VAOBJ_TYPE vaobj;
        INDEX_TYPE index;
        PNAME_TYPE pname;
        PARAM_TYPE param;
        GetVertexArrayIndexed64iv(
            VAOBJ_TYPE const&vaobj,
            INDEX_TYPE const&index,
            PNAME_TYPE const&pname,
            PARAM_TYPE const&param){
          this->vaobj = vaobj;
          this->index = index;
          this->pname = pname;
          this->param = param;
        }
        virtual~GetVertexArrayIndexed64iv(){}
        virtual void operator()(){
          glGetVertexArrayIndexed64iv(
            ge::core::convertTo<GLuint  >(this->vaobj),
            ge::core::convertTo<GLuint  >(this->index),
            ge::core::convertTo<GLenum  >(this->pname),
            ge::core::convertTo<GLint64*>(this->param)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum      ,
      typename PNAME_TYPE  = GLenum      ,
      typename PARAMS_TYPE = const GLint*>
    class TexParameterIiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        TexParameterIiv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~TexParameterIiv(){}
        virtual void operator()(){
          glTexParameterIiv(
            ge::core::convertTo<GLenum      >(this->target),
            ge::core::convertTo<GLenum      >(this->pname ),
            ge::core::convertTo<const GLint*>(this->params)
          );
        }
    };

    template<
      typename MODE_TYPE = GLenum>
    class BlendEquation:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode")return(void*)&this->mode;
          return NULL;
        }
      public:
        MODE_TYPE mode;
        BlendEquation(
            MODE_TYPE const&mode){
          this->mode = mode;
        }
        virtual~BlendEquation(){}
        virtual void operator()(){
          glBlendEquation(
            ge::core::convertTo<GLenum>(this->mode)
          );
        }
    };

    template<
      typename RET_TYPE     = GLint        ,
      typename PROGRAM_TYPE = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    class GetUniformLocation:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"    )return(void*)&this->ret    ;
          if(name == "program")return(void*)&this->program;
          if(name == "name"   )return(void*)&this->name   ;
          return NULL;
        }
      public:
        RET_TYPE     ret    ;
        PROGRAM_TYPE program;
        NAME_TYPE    name   ;
        GetUniformLocation(
            RET_TYPE     const&ret    ,
            PROGRAM_TYPE const&program,
            NAME_TYPE    const&name   ){
          this->ret     = ret    ;
          this->program = program;
          this->name    = name   ;
        }
        virtual~GetUniformLocation(){}
        virtual void operator()(){
          ge::core::convertFrom<GLint>(this->ret,glGetUniformLocation(
              ge::core::convertTo<GLuint       >(this->program),
              ge::core::convertTo<const GLchar*>(this->name   ))
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class UniformMatrix2x4dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix2x4dv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix2x4dv(){}
        virtual void operator()(){
          glUniformMatrix2x4dv(
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename VAOBJ_TYPE          = GLuint   ,
      typename ATTRIBINDEX_TYPE    = GLuint   ,
      typename SIZE_TYPE           = GLint    ,
      typename TYPE_TYPE           = GLenum   ,
      typename NORMALIZED_TYPE     = GLboolean,
      typename RELATIVEOFFSET_TYPE = GLuint   >
    class VertexArrayAttribFormat:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj"         )return(void*)&this->vaobj         ;
          if(name == "attribindex"   )return(void*)&this->attribindex   ;
          if(name == "size"          )return(void*)&this->size          ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "normalized"    )return(void*)&this->normalized    ;
          if(name == "relativeoffset")return(void*)&this->relativeoffset;
          return NULL;
        }
      public:
        VAOBJ_TYPE          vaobj         ;
        ATTRIBINDEX_TYPE    attribindex   ;
        SIZE_TYPE           size          ;
        TYPE_TYPE           type          ;
        NORMALIZED_TYPE     normalized    ;
        RELATIVEOFFSET_TYPE relativeoffset;
        VertexArrayAttribFormat(
            VAOBJ_TYPE          const&vaobj         ,
            ATTRIBINDEX_TYPE    const&attribindex   ,
            SIZE_TYPE           const&size          ,
            TYPE_TYPE           const&type          ,
            NORMALIZED_TYPE     const&normalized    ,
            RELATIVEOFFSET_TYPE const&relativeoffset){
          this->vaobj          = vaobj         ;
          this->attribindex    = attribindex   ;
          this->size           = size          ;
          this->type           = type          ;
          this->normalized     = normalized    ;
          this->relativeoffset = relativeoffset;
        }
        virtual~VertexArrayAttribFormat(){}
        virtual void operator()(){
          glVertexArrayAttribFormat(
            ge::core::convertTo<GLuint   >(this->vaobj         ),
            ge::core::convertTo<GLuint   >(this->attribindex   ),
            ge::core::convertTo<GLint    >(this->size          ),
            ge::core::convertTo<GLenum   >(this->type          ),
            ge::core::convertTo<GLboolean>(this->normalized    ),
            ge::core::convertTo<GLuint   >(this->relativeoffset)
          );
        }
    };

    template<
      typename TARGET_TYPE    = GLenum     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename YOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename HEIGHT_TYPE    = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    class CompressedTexSubImage2D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"   )return(void*)&this->target   ;
          if(name == "level"    )return(void*)&this->level    ;
          if(name == "xoffset"  )return(void*)&this->xoffset  ;
          if(name == "yoffset"  )return(void*)&this->yoffset  ;
          if(name == "width"    )return(void*)&this->width    ;
          if(name == "height"   )return(void*)&this->height   ;
          if(name == "format"   )return(void*)&this->format   ;
          if(name == "imageSize")return(void*)&this->imageSize;
          if(name == "data"     )return(void*)&this->data     ;
          return NULL;
        }
      public:
        TARGET_TYPE    target   ;
        LEVEL_TYPE     level    ;
        XOFFSET_TYPE   xoffset  ;
        YOFFSET_TYPE   yoffset  ;
        WIDTH_TYPE     width    ;
        HEIGHT_TYPE    height   ;
        FORMAT_TYPE    format   ;
        IMAGESIZE_TYPE imageSize;
        DATA_TYPE      data     ;
        CompressedTexSubImage2D(
            TARGET_TYPE    const&target   ,
            LEVEL_TYPE     const&level    ,
            XOFFSET_TYPE   const&xoffset  ,
            YOFFSET_TYPE   const&yoffset  ,
            WIDTH_TYPE     const&width    ,
            HEIGHT_TYPE    const&height   ,
            FORMAT_TYPE    const&format   ,
            IMAGESIZE_TYPE const&imageSize,
            DATA_TYPE      const&data     ){
          this->target    = target   ;
          this->level     = level    ;
          this->xoffset   = xoffset  ;
          this->yoffset   = yoffset  ;
          this->width     = width    ;
          this->height    = height   ;
          this->format    = format   ;
          this->imageSize = imageSize;
          this->data      = data     ;
        }
        virtual~CompressedTexSubImage2D(){}
        virtual void operator()(){
          glCompressedTexSubImage2D(
            ge::core::convertTo<GLenum     >(this->target   ),
            ge::core::convertTo<GLint      >(this->level    ),
            ge::core::convertTo<GLint      >(this->xoffset  ),
            ge::core::convertTo<GLint      >(this->yoffset  ),
            ge::core::convertTo<GLsizei    >(this->width    ),
            ge::core::convertTo<GLsizei    >(this->height   ),
            ge::core::convertTo<GLenum     >(this->format   ),
            ge::core::convertTo<GLsizei    >(this->imageSize),
            ge::core::convertTo<const void*>(this->data     )
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE = GLuint       ,
      typename N_TYPE           = GLsizei      ,
      typename BUFS_TYPE        = const GLenum*>
    class NamedFramebufferDrawBuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "n"          )return(void*)&this->n          ;
          if(name == "bufs"       )return(void*)&this->bufs       ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE framebuffer;
        N_TYPE           n          ;
        BUFS_TYPE        bufs       ;
        NamedFramebufferDrawBuffers(
            FRAMEBUFFER_TYPE const&framebuffer,
            N_TYPE           const&n          ,
            BUFS_TYPE        const&bufs       ){
          this->framebuffer = framebuffer;
          this->n           = n          ;
          this->bufs        = bufs       ;
        }
        virtual~NamedFramebufferDrawBuffers(){}
        virtual void operator()(){
          glNamedFramebufferDrawBuffers(
            ge::core::convertTo<GLuint       >(this->framebuffer),
            ge::core::convertTo<GLsizei      >(this->n          ),
            ge::core::convertTo<const GLenum*>(this->bufs       )
          );
        }
    };

    class EndTransformFeedback:
        public ge::core::Command{
      public:
        EndTransformFeedback(
            ){
        }
        virtual~EndTransformFeedback(){}
        virtual void operator()(){
          glEndTransformFeedback(

          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLushort*>
    class VertexAttrib4usv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4usv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4usv(){}
        virtual void operator()(){
          glVertexAttrib4usv(
            ge::core::convertTo<GLuint         >(this->index),
            ge::core::convertTo<const GLushort*>(this->v    )
          );
        }
    };

    template<
      typename SHADERTYPE_TYPE = GLenum ,
      typename LOCATION_TYPE   = GLint  ,
      typename PARAMS_TYPE     = GLuint*>
    class GetUniformSubroutineuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "shadertype")return(void*)&this->shadertype;
          if(name == "location"  )return(void*)&this->location  ;
          if(name == "params"    )return(void*)&this->params    ;
          return NULL;
        }
      public:
        SHADERTYPE_TYPE shadertype;
        LOCATION_TYPE   location  ;
        PARAMS_TYPE     params    ;
        GetUniformSubroutineuiv(
            SHADERTYPE_TYPE const&shadertype,
            LOCATION_TYPE   const&location  ,
            PARAMS_TYPE     const&params    ){
          this->shadertype = shadertype;
          this->location   = location  ;
          this->params     = params    ;
        }
        virtual~GetUniformSubroutineuiv(){}
        virtual void operator()(){
          glGetUniformSubroutineuiv(
            ge::core::convertTo<GLenum >(this->shadertype),
            ge::core::convertTo<GLint  >(this->location  ),
            ge::core::convertTo<GLuint*>(this->params    )
          );
        }
    };

    template<
      typename TARGET_TYPE               = GLenum   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    class TexImage2DMultisample:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"              )return(void*)&this->target              ;
          if(name == "samples"             )return(void*)&this->samples             ;
          if(name == "internalformat"      )return(void*)&this->internalformat      ;
          if(name == "width"               )return(void*)&this->width               ;
          if(name == "height"              )return(void*)&this->height              ;
          if(name == "fixedsamplelocations")return(void*)&this->fixedsamplelocations;
          return NULL;
        }
      public:
        TARGET_TYPE               target              ;
        SAMPLES_TYPE              samples             ;
        INTERNALFORMAT_TYPE       internalformat      ;
        WIDTH_TYPE                width               ;
        HEIGHT_TYPE               height              ;
        FIXEDSAMPLELOCATIONS_TYPE fixedsamplelocations;
        TexImage2DMultisample(
            TARGET_TYPE               const&target              ,
            SAMPLES_TYPE              const&samples             ,
            INTERNALFORMAT_TYPE       const&internalformat      ,
            WIDTH_TYPE                const&width               ,
            HEIGHT_TYPE               const&height              ,
            FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
          this->target               = target              ;
          this->samples              = samples             ;
          this->internalformat       = internalformat      ;
          this->width                = width               ;
          this->height               = height              ;
          this->fixedsamplelocations = fixedsamplelocations;
        }
        virtual~TexImage2DMultisample(){}
        virtual void operator()(){
          glTexImage2DMultisample(
            ge::core::convertTo<GLenum   >(this->target              ),
            ge::core::convertTo<GLsizei  >(this->samples             ),
            ge::core::convertTo<GLenum   >(this->internalformat      ),
            ge::core::convertTo<GLsizei  >(this->width               ),
            ge::core::convertTo<GLsizei  >(this->height              ),
            ge::core::convertTo<GLboolean>(this->fixedsamplelocations)
          );
        }
    };

    template<
      typename BINDINGINDEX_TYPE = GLuint  ,
      typename BUFFER_TYPE       = GLuint  ,
      typename OFFSET_TYPE       = GLintptr,
      typename STRIDE_TYPE       = GLsizei >
    class BindVertexBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "bindingindex")return(void*)&this->bindingindex;
          if(name == "buffer"      )return(void*)&this->buffer      ;
          if(name == "offset"      )return(void*)&this->offset      ;
          if(name == "stride"      )return(void*)&this->stride      ;
          return NULL;
        }
      public:
        BINDINGINDEX_TYPE bindingindex;
        BUFFER_TYPE       buffer      ;
        OFFSET_TYPE       offset      ;
        STRIDE_TYPE       stride      ;
        BindVertexBuffer(
            BINDINGINDEX_TYPE const&bindingindex,
            BUFFER_TYPE       const&buffer      ,
            OFFSET_TYPE       const&offset      ,
            STRIDE_TYPE       const&stride      ){
          this->bindingindex = bindingindex;
          this->buffer       = buffer      ;
          this->offset       = offset      ;
          this->stride       = stride      ;
        }
        virtual~BindVertexBuffer(){}
        virtual void operator()(){
          glBindVertexBuffer(
            ge::core::convertTo<GLuint  >(this->bindingindex),
            ge::core::convertTo<GLuint  >(this->buffer      ),
            ge::core::convertTo<GLintptr>(this->offset      ),
            ge::core::convertTo<GLsizei >(this->stride      )
          );
        }
    };

    template<
      typename SOURCE_TYPE   = GLenum       ,
      typename TYPE_TYPE     = GLenum       ,
      typename ID_TYPE       = GLuint       ,
      typename SEVERITY_TYPE = GLenum       ,
      typename LENGTH_TYPE   = GLsizei      ,
      typename BUF_TYPE      = const GLchar*>
    class DebugMessageInsert:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "source"  )return(void*)&this->source  ;
          if(name == "type"    )return(void*)&this->type    ;
          if(name == "id"      )return(void*)&this->id      ;
          if(name == "severity")return(void*)&this->severity;
          if(name == "length"  )return(void*)&this->length  ;
          if(name == "buf"     )return(void*)&this->buf     ;
          return NULL;
        }
      public:
        SOURCE_TYPE   source  ;
        TYPE_TYPE     type    ;
        ID_TYPE       id      ;
        SEVERITY_TYPE severity;
        LENGTH_TYPE   length  ;
        BUF_TYPE      buf     ;
        DebugMessageInsert(
            SOURCE_TYPE   const&source  ,
            TYPE_TYPE     const&type    ,
            ID_TYPE       const&id      ,
            SEVERITY_TYPE const&severity,
            LENGTH_TYPE   const&length  ,
            BUF_TYPE      const&buf     ){
          this->source   = source  ;
          this->type     = type    ;
          this->id       = id      ;
          this->severity = severity;
          this->length   = length  ;
          this->buf      = buf     ;
        }
        virtual~DebugMessageInsert(){}
        virtual void operator()(){
          glDebugMessageInsert(
            ge::core::convertTo<GLenum       >(this->source  ),
            ge::core::convertTo<GLenum       >(this->type    ),
            ge::core::convertTo<GLuint       >(this->id      ),
            ge::core::convertTo<GLenum       >(this->severity),
            ge::core::convertTo<GLsizei      >(this->length  ),
            ge::core::convertTo<const GLchar*>(this->buf     )
          );
        }
    };

    template<
      typename N_TYPE        = GLsizei,
      typename SAMPLERS_TYPE = GLuint*>
    class CreateSamplers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"       )return(void*)&this->n       ;
          if(name == "samplers")return(void*)&this->samplers;
          return NULL;
        }
      public:
        N_TYPE        n       ;
        SAMPLERS_TYPE samplers;
        CreateSamplers(
            N_TYPE        const&n       ,
            SAMPLERS_TYPE const&samplers){
          this->n        = n       ;
          this->samplers = samplers;
        }
        virtual~CreateSamplers(){}
        virtual void operator()(){
          glCreateSamplers(
            ge::core::convertTo<GLsizei>(this->n       ),
            ge::core::convertTo<GLuint*>(this->samplers)
          );
        }
    };

    template<
      typename PROGRAM_TYPE          = GLuint       ,
      typename PROGRAMINTERFACE_TYPE = GLenum       ,
      typename INDEX_TYPE            = GLuint       ,
      typename PROPCOUNT_TYPE        = GLsizei      ,
      typename PROPS_TYPE            = const GLenum*,
      typename BUFSIZE_TYPE          = GLsizei      ,
      typename LENGTH_TYPE           = GLsizei*     ,
      typename PARAMS_TYPE           = GLint*       >
    class GetProgramResourceiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"         )return(void*)&this->program         ;
          if(name == "programInterface")return(void*)&this->programInterface;
          if(name == "index"           )return(void*)&this->index           ;
          if(name == "propCount"       )return(void*)&this->propCount       ;
          if(name == "props"           )return(void*)&this->props           ;
          if(name == "bufSize"         )return(void*)&this->bufSize         ;
          if(name == "length"          )return(void*)&this->length          ;
          if(name == "params"          )return(void*)&this->params          ;
          return NULL;
        }
      public:
        PROGRAM_TYPE          program         ;
        PROGRAMINTERFACE_TYPE programInterface;
        INDEX_TYPE            index           ;
        PROPCOUNT_TYPE        propCount       ;
        PROPS_TYPE            props           ;
        BUFSIZE_TYPE          bufSize         ;
        LENGTH_TYPE           length          ;
        PARAMS_TYPE           params          ;
        GetProgramResourceiv(
            PROGRAM_TYPE          const&program         ,
            PROGRAMINTERFACE_TYPE const&programInterface,
            INDEX_TYPE            const&index           ,
            PROPCOUNT_TYPE        const&propCount       ,
            PROPS_TYPE            const&props           ,
            BUFSIZE_TYPE          const&bufSize         ,
            LENGTH_TYPE           const&length          ,
            PARAMS_TYPE           const&params          ){
          this->program          = program         ;
          this->programInterface = programInterface;
          this->index            = index           ;
          this->propCount        = propCount       ;
          this->props            = props           ;
          this->bufSize          = bufSize         ;
          this->length           = length          ;
          this->params           = params          ;
        }
        virtual~GetProgramResourceiv(){}
        virtual void operator()(){
          glGetProgramResourceiv(
            ge::core::convertTo<GLuint       >(this->program         ),
            ge::core::convertTo<GLenum       >(this->programInterface),
            ge::core::convertTo<GLuint       >(this->index           ),
            ge::core::convertTo<GLsizei      >(this->propCount       ),
            ge::core::convertTo<const GLenum*>(this->props           ),
            ge::core::convertTo<GLsizei      >(this->bufSize         ),
            ge::core::convertTo<GLsizei*     >(this->length          ),
            ge::core::convertTo<GLint*       >(this->params          )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename DATA_TYPE           = const void*>
    class ClearBufferData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "format"        )return(void*)&this->format        ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "data"          )return(void*)&this->data          ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        INTERNALFORMAT_TYPE internalformat;
        FORMAT_TYPE         format        ;
        TYPE_TYPE           type          ;
        DATA_TYPE           data          ;
        ClearBufferData(
            TARGET_TYPE         const&target        ,
            INTERNALFORMAT_TYPE const&internalformat,
            FORMAT_TYPE         const&format        ,
            TYPE_TYPE           const&type          ,
            DATA_TYPE           const&data          ){
          this->target         = target        ;
          this->internalformat = internalformat;
          this->format         = format        ;
          this->type           = type          ;
          this->data           = data          ;
        }
        virtual~ClearBufferData(){}
        virtual void operator()(){
          glClearBufferData(
            ge::core::convertTo<GLenum     >(this->target        ),
            ge::core::convertTo<GLenum     >(this->internalformat),
            ge::core::convertTo<GLenum     >(this->format        ),
            ge::core::convertTo<GLenum     >(this->type          ),
            ge::core::convertTo<const void*>(this->data          )
          );
        }
    };

    template<
      typename PRIMITIVEMODE_TYPE = GLenum>
    class BeginTransformFeedback:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "primitiveMode")return(void*)&this->primitiveMode;
          return NULL;
        }
      public:
        PRIMITIVEMODE_TYPE primitiveMode;
        BeginTransformFeedback(
            PRIMITIVEMODE_TYPE const&primitiveMode){
          this->primitiveMode = primitiveMode;
        }
        virtual~BeginTransformFeedback(){}
        virtual void operator()(){
          glBeginTransformFeedback(
            ge::core::convertTo<GLenum>(this->primitiveMode)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    class VertexAttribI1iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribI1iv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribI1iv(){}
        virtual void operator()(){
          glVertexAttribI1iv(
            ge::core::convertTo<GLuint      >(this->index),
            ge::core::convertTo<const GLint*>(this->v    )
          );
        }
    };

    template<
      typename RET_TYPE     = GLboolean,
      typename SAMPLER_TYPE = GLuint   >
    class IsSampler:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"    )return(void*)&this->ret    ;
          if(name == "sampler")return(void*)&this->sampler;
          return NULL;
        }
      public:
        RET_TYPE     ret    ;
        SAMPLER_TYPE sampler;
        IsSampler(
            RET_TYPE     const&ret    ,
            SAMPLER_TYPE const&sampler){
          this->ret     = ret    ;
          this->sampler = sampler;
        }
        virtual~IsSampler(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsSampler(
              ge::core::convertTo<GLuint   >(this->sampler))
          );
        }
    };

    template<
      typename INDEX_TYPE   = GLuint,
      typename DIVISOR_TYPE = GLuint>
    class VertexAttribDivisor:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"  )return(void*)&this->index  ;
          if(name == "divisor")return(void*)&this->divisor;
          return NULL;
        }
      public:
        INDEX_TYPE   index  ;
        DIVISOR_TYPE divisor;
        VertexAttribDivisor(
            INDEX_TYPE   const&index  ,
            DIVISOR_TYPE const&divisor){
          this->index   = index  ;
          this->divisor = divisor;
        }
        virtual~VertexAttribDivisor(){}
        virtual void operator()(){
          glVertexAttribDivisor(
            ge::core::convertTo<GLuint>(this->index  ),
            ge::core::convertTo<GLuint>(this->divisor)
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    class GetCompressedTextureImage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "pixels" )return(void*)&this->pixels ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        BUFSIZE_TYPE bufSize;
        PIXELS_TYPE  pixels ;
        GetCompressedTextureImage(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            BUFSIZE_TYPE const&bufSize,
            PIXELS_TYPE  const&pixels ){
          this->texture = texture;
          this->level   = level  ;
          this->bufSize = bufSize;
          this->pixels  = pixels ;
        }
        virtual~GetCompressedTextureImage(){}
        virtual void operator()(){
          glGetCompressedTextureImage(
            ge::core::convertTo<GLuint >(this->texture),
            ge::core::convertTo<GLint  >(this->level  ),
            ge::core::convertTo<GLsizei>(this->bufSize),
            ge::core::convertTo<void*  >(this->pixels )
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename IMAGESIZE_TYPE      = GLsizei    ,
      typename DATA_TYPE           = const void*>
    class CompressedTexImage1D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "level"         )return(void*)&this->level         ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "border"        )return(void*)&this->border        ;
          if(name == "imageSize"     )return(void*)&this->imageSize     ;
          if(name == "data"          )return(void*)&this->data          ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        LEVEL_TYPE          level         ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        BORDER_TYPE         border        ;
        IMAGESIZE_TYPE      imageSize     ;
        DATA_TYPE           data          ;
        CompressedTexImage1D(
            TARGET_TYPE         const&target        ,
            LEVEL_TYPE          const&level         ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            BORDER_TYPE         const&border        ,
            IMAGESIZE_TYPE      const&imageSize     ,
            DATA_TYPE           const&data          ){
          this->target         = target        ;
          this->level          = level         ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->border         = border        ;
          this->imageSize      = imageSize     ;
          this->data           = data          ;
        }
        virtual~CompressedTexImage1D(){}
        virtual void operator()(){
          glCompressedTexImage1D(
            ge::core::convertTo<GLenum     >(this->target        ),
            ge::core::convertTo<GLint      >(this->level         ),
            ge::core::convertTo<GLenum     >(this->internalformat),
            ge::core::convertTo<GLsizei    >(this->width         ),
            ge::core::convertTo<GLint      >(this->border        ),
            ge::core::convertTo<GLsizei    >(this->imageSize     ),
            ge::core::convertTo<const void*>(this->data          )
          );
        }
    };

    template<
      typename N_TYPE   = GLsizei      ,
      typename IDS_TYPE = const GLuint*>
    class DeleteTransformFeedbacks:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"  )return(void*)&this->n  ;
          if(name == "ids")return(void*)&this->ids;
          return NULL;
        }
      public:
        N_TYPE   n  ;
        IDS_TYPE ids;
        DeleteTransformFeedbacks(
            N_TYPE   const&n  ,
            IDS_TYPE const&ids){
          this->n   = n  ;
          this->ids = ids;
        }
        virtual~DeleteTransformFeedbacks(){}
        virtual void operator()(){
          glDeleteTransformFeedbacks(
            ge::core::convertTo<GLsizei      >(this->n  ),
            ge::core::convertTo<const GLuint*>(this->ids)
          );
        }
    };

    template<
      typename TARGET_TYPE  = GLenum ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei>
    class CopyTexSubImage1D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target" )return(void*)&this->target ;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "x"      )return(void*)&this->x      ;
          if(name == "y"      )return(void*)&this->y      ;
          if(name == "width"  )return(void*)&this->width  ;
          return NULL;
        }
      public:
        TARGET_TYPE  target ;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        X_TYPE       x      ;
        Y_TYPE       y      ;
        WIDTH_TYPE   width  ;
        CopyTexSubImage1D(
            TARGET_TYPE  const&target ,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            X_TYPE       const&x      ,
            Y_TYPE       const&y      ,
            WIDTH_TYPE   const&width  ){
          this->target  = target ;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->x       = x      ;
          this->y       = y      ;
          this->width   = width  ;
        }
        virtual~CopyTexSubImage1D(){}
        virtual void operator()(){
          glCopyTexSubImage1D(
            ge::core::convertTo<GLenum >(this->target ),
            ge::core::convertTo<GLint  >(this->level  ),
            ge::core::convertTo<GLint  >(this->xoffset),
            ge::core::convertTo<GLint  >(this->x      ),
            ge::core::convertTo<GLint  >(this->y      ),
            ge::core::convertTo<GLsizei>(this->width  )
          );
        }
    };

    template<
      typename MODE_TYPE       = GLenum     ,
      typename START_TYPE      = GLuint     ,
      typename END_TYPE        = GLuint     ,
      typename COUNT_TYPE      = GLsizei    ,
      typename TYPE_TYPE       = GLenum     ,
      typename INDICES_TYPE    = const void*,
      typename BASEVERTEX_TYPE = GLint      >
    class DrawRangeElementsBaseVertex:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"      )return(void*)&this->mode      ;
          if(name == "start"     )return(void*)&this->start     ;
          if(name == "end"       )return(void*)&this->end       ;
          if(name == "count"     )return(void*)&this->count     ;
          if(name == "type"      )return(void*)&this->type      ;
          if(name == "indices"   )return(void*)&this->indices   ;
          if(name == "basevertex")return(void*)&this->basevertex;
          return NULL;
        }
      public:
        MODE_TYPE       mode      ;
        START_TYPE      start     ;
        END_TYPE        end       ;
        COUNT_TYPE      count     ;
        TYPE_TYPE       type      ;
        INDICES_TYPE    indices   ;
        BASEVERTEX_TYPE basevertex;
        DrawRangeElementsBaseVertex(
            MODE_TYPE       const&mode      ,
            START_TYPE      const&start     ,
            END_TYPE        const&end       ,
            COUNT_TYPE      const&count     ,
            TYPE_TYPE       const&type      ,
            INDICES_TYPE    const&indices   ,
            BASEVERTEX_TYPE const&basevertex){
          this->mode       = mode      ;
          this->start      = start     ;
          this->end        = end       ;
          this->count      = count     ;
          this->type       = type      ;
          this->indices    = indices   ;
          this->basevertex = basevertex;
        }
        virtual~DrawRangeElementsBaseVertex(){}
        virtual void operator()(){
          glDrawRangeElementsBaseVertex(
            ge::core::convertTo<GLenum     >(this->mode      ),
            ge::core::convertTo<GLuint     >(this->start     ),
            ge::core::convertTo<GLuint     >(this->end       ),
            ge::core::convertTo<GLsizei    >(this->count     ),
            ge::core::convertTo<GLenum     >(this->type      ),
            ge::core::convertTo<const void*>(this->indices   ),
            ge::core::convertTo<GLint      >(this->basevertex)
          );
        }
    };

    template<
      typename RET_TYPE    = GLenum,
      typename TARGET_TYPE = GLenum>
    class CheckFramebufferStatus:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"   )return(void*)&this->ret   ;
          if(name == "target")return(void*)&this->target;
          return NULL;
        }
      public:
        RET_TYPE    ret   ;
        TARGET_TYPE target;
        CheckFramebufferStatus(
            RET_TYPE    const&ret   ,
            TARGET_TYPE const&target){
          this->ret    = ret   ;
          this->target = target;
        }
        virtual~CheckFramebufferStatus(){}
        virtual void operator()(){
          ge::core::convertFrom<GLenum>(this->ret,glCheckFramebufferStatus(
              ge::core::convertTo<GLenum>(this->target))
          );
        }
    };

    class EndConditionalRender:
        public ge::core::Command{
      public:
        EndConditionalRender(
            ){
        }
        virtual~EndConditionalRender(){}
        virtual void operator()(){
          glEndConditionalRender(

          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint       ,
      typename INDEX_TYPE   = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    class BindAttribLocation:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          if(name == "index"  )return(void*)&this->index  ;
          if(name == "name"   )return(void*)&this->name   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        INDEX_TYPE   index  ;
        NAME_TYPE    name   ;
        BindAttribLocation(
            PROGRAM_TYPE const&program,
            INDEX_TYPE   const&index  ,
            NAME_TYPE    const&name   ){
          this->program = program;
          this->index   = index  ;
          this->name    = name   ;
        }
        virtual~BindAttribLocation(){}
        virtual void operator()(){
          glBindAttribLocation(
            ge::core::convertTo<GLuint       >(this->program),
            ge::core::convertTo<GLuint       >(this->index  ),
            ge::core::convertTo<const GLchar*>(this->name   )
          );
        }
    };

    template<
      typename UNIT_TYPE    = GLuint   ,
      typename TEXTURE_TYPE = GLuint   ,
      typename LEVEL_TYPE   = GLint    ,
      typename LAYERED_TYPE = GLboolean,
      typename LAYER_TYPE   = GLint    ,
      typename ACCESS_TYPE  = GLenum   ,
      typename FORMAT_TYPE  = GLenum   >
    class BindImageTexture:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "unit"   )return(void*)&this->unit   ;
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "layered")return(void*)&this->layered;
          if(name == "layer"  )return(void*)&this->layer  ;
          if(name == "access" )return(void*)&this->access ;
          if(name == "format" )return(void*)&this->format ;
          return NULL;
        }
      public:
        UNIT_TYPE    unit   ;
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        LAYERED_TYPE layered;
        LAYER_TYPE   layer  ;
        ACCESS_TYPE  access ;
        FORMAT_TYPE  format ;
        BindImageTexture(
            UNIT_TYPE    const&unit   ,
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            LAYERED_TYPE const&layered,
            LAYER_TYPE   const&layer  ,
            ACCESS_TYPE  const&access ,
            FORMAT_TYPE  const&format ){
          this->unit    = unit   ;
          this->texture = texture;
          this->level   = level  ;
          this->layered = layered;
          this->layer   = layer  ;
          this->access  = access ;
          this->format  = format ;
        }
        virtual~BindImageTexture(){}
        virtual void operator()(){
          glBindImageTexture(
            ge::core::convertTo<GLuint   >(this->unit   ),
            ge::core::convertTo<GLuint   >(this->texture),
            ge::core::convertTo<GLint    >(this->level  ),
            ge::core::convertTo<GLboolean>(this->layered),
            ge::core::convertTo<GLint    >(this->layer  ),
            ge::core::convertTo<GLenum   >(this->access ),
            ge::core::convertTo<GLenum   >(this->format )
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class UniformMatrix2dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix2dv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix2dv(){}
        virtual void operator()(){
          glUniformMatrix2dv(
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint       ,
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    class ProgramUniform2uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform2uiv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform2uiv(){}
        virtual void operator()(){
          glProgramUniform2uiv(
            ge::core::convertTo<GLuint       >(this->program ),
            ge::core::convertTo<GLint        >(this->location),
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->value   )
          );
        }
    };

    template<
      typename MODE_TYPE    = GLenum     ,
      typename START_TYPE   = GLuint     ,
      typename END_TYPE     = GLuint     ,
      typename COUNT_TYPE   = GLsizei    ,
      typename TYPE_TYPE    = GLenum     ,
      typename INDICES_TYPE = const void*>
    class DrawRangeElements:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"   )return(void*)&this->mode   ;
          if(name == "start"  )return(void*)&this->start  ;
          if(name == "end"    )return(void*)&this->end    ;
          if(name == "count"  )return(void*)&this->count  ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "indices")return(void*)&this->indices;
          return NULL;
        }
      public:
        MODE_TYPE    mode   ;
        START_TYPE   start  ;
        END_TYPE     end    ;
        COUNT_TYPE   count  ;
        TYPE_TYPE    type   ;
        INDICES_TYPE indices;
        DrawRangeElements(
            MODE_TYPE    const&mode   ,
            START_TYPE   const&start  ,
            END_TYPE     const&end    ,
            COUNT_TYPE   const&count  ,
            TYPE_TYPE    const&type   ,
            INDICES_TYPE const&indices){
          this->mode    = mode   ;
          this->start   = start  ;
          this->end     = end    ;
          this->count   = count  ;
          this->type    = type   ;
          this->indices = indices;
        }
        virtual~DrawRangeElements(){}
        virtual void operator()(){
          glDrawRangeElements(
            ge::core::convertTo<GLenum     >(this->mode   ),
            ge::core::convertTo<GLuint     >(this->start  ),
            ge::core::convertTo<GLuint     >(this->end    ),
            ge::core::convertTo<GLsizei    >(this->count  ),
            ge::core::convertTo<GLenum     >(this->type   ),
            ge::core::convertTo<const void*>(this->indices)
          );
        }
    };

    template<
      typename ID_TYPE     = GLuint ,
      typename PNAME_TYPE  = GLenum ,
      typename PARAMS_TYPE = GLuint*>
    class GetQueryObjectuiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "id"    )return(void*)&this->id    ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        ID_TYPE     id    ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetQueryObjectuiv(
            ID_TYPE     const&id    ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->id     = id    ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetQueryObjectuiv(){}
        virtual void operator()(){
          glGetQueryObjectuiv(
            ge::core::convertTo<GLuint >(this->id    ),
            ge::core::convertTo<GLenum >(this->pname ),
            ge::core::convertTo<GLuint*>(this->params)
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint,
      typename BUFFER_TYPE = GLuint>
    class BindBufferBase:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          if(name == "buffer")return(void*)&this->buffer;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        BUFFER_TYPE buffer;
        BindBufferBase(
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ,
            BUFFER_TYPE const&buffer){
          this->target = target;
          this->index  = index ;
          this->buffer = buffer;
        }
        virtual~BindBufferBase(){}
        virtual void operator()(){
          glBindBufferBase(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLuint>(this->index ),
            ge::core::convertTo<GLuint>(this->buffer)
          );
        }
    };

    template<
      typename PROGRAM_TYPE = GLuint  ,
      typename INDEX_TYPE   = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename SIZE_TYPE    = GLint*  ,
      typename TYPE_TYPE    = GLenum* ,
      typename NAME_TYPE    = GLchar* >
    class GetActiveUniform:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program")return(void*)&this->program;
          if(name == "index"  )return(void*)&this->index  ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "length" )return(void*)&this->length ;
          if(name == "size"   )return(void*)&this->size   ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "name"   )return(void*)&this->name   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE program;
        INDEX_TYPE   index  ;
        BUFSIZE_TYPE bufSize;
        LENGTH_TYPE  length ;
        SIZE_TYPE    size   ;
        TYPE_TYPE    type   ;
        NAME_TYPE    name   ;
        GetActiveUniform(
            PROGRAM_TYPE const&program,
            INDEX_TYPE   const&index  ,
            BUFSIZE_TYPE const&bufSize,
            LENGTH_TYPE  const&length ,
            SIZE_TYPE    const&size   ,
            TYPE_TYPE    const&type   ,
            NAME_TYPE    const&name   ){
          this->program = program;
          this->index   = index  ;
          this->bufSize = bufSize;
          this->length  = length ;
          this->size    = size   ;
          this->type    = type   ;
          this->name    = name   ;
        }
        virtual~GetActiveUniform(){}
        virtual void operator()(){
          glGetActiveUniform(
            ge::core::convertTo<GLuint  >(this->program),
            ge::core::convertTo<GLuint  >(this->index  ),
            ge::core::convertTo<GLsizei >(this->bufSize),
            ge::core::convertTo<GLsizei*>(this->length ),
            ge::core::convertTo<GLint*  >(this->size   ),
            ge::core::convertTo<GLenum* >(this->type   ),
            ge::core::convertTo<GLchar* >(this->name   )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum     ,
      typename OFFSET_TYPE = GLintptr   ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*>
    class BufferSubData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "offset")return(void*)&this->offset;
          if(name == "size"  )return(void*)&this->size  ;
          if(name == "data"  )return(void*)&this->data  ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        OFFSET_TYPE offset;
        SIZE_TYPE   size  ;
        DATA_TYPE   data  ;
        BufferSubData(
            TARGET_TYPE const&target,
            OFFSET_TYPE const&offset,
            SIZE_TYPE   const&size  ,
            DATA_TYPE   const&data  ){
          this->target = target;
          this->offset = offset;
          this->size   = size  ;
          this->data   = data  ;
        }
        virtual~BufferSubData(){}
        virtual void operator()(){
          glBufferSubData(
            ge::core::convertTo<GLenum     >(this->target),
            ge::core::convertTo<GLintptr   >(this->offset),
            ge::core::convertTo<GLsizeiptr >(this->size  ),
            ge::core::convertTo<const void*>(this->data  )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    class VertexAttrib4iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4iv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4iv(){}
        virtual void operator()(){
          glVertexAttrib4iv(
            ge::core::convertTo<GLuint      >(this->index),
            ge::core::convertTo<const GLint*>(this->v    )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint       ,
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    class ProgramUniform1uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform1uiv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform1uiv(){}
        virtual void operator()(){
          glProgramUniform1uiv(
            ge::core::convertTo<GLuint       >(this->program ),
            ge::core::convertTo<GLint        >(this->location),
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->value   )
          );
        }
    };

    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint >
    class FramebufferTexture:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"    )return(void*)&this->target    ;
          if(name == "attachment")return(void*)&this->attachment;
          if(name == "texture"   )return(void*)&this->texture   ;
          if(name == "level"     )return(void*)&this->level     ;
          return NULL;
        }
      public:
        TARGET_TYPE     target    ;
        ATTACHMENT_TYPE attachment;
        TEXTURE_TYPE    texture   ;
        LEVEL_TYPE      level     ;
        FramebufferTexture(
            TARGET_TYPE     const&target    ,
            ATTACHMENT_TYPE const&attachment,
            TEXTURE_TYPE    const&texture   ,
            LEVEL_TYPE      const&level     ){
          this->target     = target    ;
          this->attachment = attachment;
          this->texture    = texture   ;
          this->level      = level     ;
        }
        virtual~FramebufferTexture(){}
        virtual void operator()(){
          glFramebufferTexture(
            ge::core::convertTo<GLenum>(this->target    ),
            ge::core::convertTo<GLenum>(this->attachment),
            ge::core::convertTo<GLuint>(this->texture   ),
            ge::core::convertTo<GLint >(this->level     )
          );
        }
    };

    template<
      typename BUF_TYPE      = GLuint,
      typename SRCRGB_TYPE   = GLenum,
      typename DSTRGB_TYPE   = GLenum,
      typename SRCALPHA_TYPE = GLenum,
      typename DSTALPHA_TYPE = GLenum>
    class BlendFuncSeparatei:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buf"     )return(void*)&this->buf     ;
          if(name == "srcRGB"  )return(void*)&this->srcRGB  ;
          if(name == "dstRGB"  )return(void*)&this->dstRGB  ;
          if(name == "srcAlpha")return(void*)&this->srcAlpha;
          if(name == "dstAlpha")return(void*)&this->dstAlpha;
          return NULL;
        }
      public:
        BUF_TYPE      buf     ;
        SRCRGB_TYPE   srcRGB  ;
        DSTRGB_TYPE   dstRGB  ;
        SRCALPHA_TYPE srcAlpha;
        DSTALPHA_TYPE dstAlpha;
        BlendFuncSeparatei(
            BUF_TYPE      const&buf     ,
            SRCRGB_TYPE   const&srcRGB  ,
            DSTRGB_TYPE   const&dstRGB  ,
            SRCALPHA_TYPE const&srcAlpha,
            DSTALPHA_TYPE const&dstAlpha){
          this->buf      = buf     ;
          this->srcRGB   = srcRGB  ;
          this->dstRGB   = dstRGB  ;
          this->srcAlpha = srcAlpha;
          this->dstAlpha = dstAlpha;
        }
        virtual~BlendFuncSeparatei(){}
        virtual void operator()(){
          glBlendFuncSeparatei(
            ge::core::convertTo<GLuint>(this->buf     ),
            ge::core::convertTo<GLenum>(this->srcRGB  ),
            ge::core::convertTo<GLenum>(this->dstRGB  ),
            ge::core::convertTo<GLenum>(this->srcAlpha),
            ge::core::convertTo<GLenum>(this->dstAlpha)
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class ProgramUniformMatrix4x2fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix4x2fv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix4x2fv(){}
        virtual void operator()(){
          glProgramUniformMatrix4x2fv(
            ge::core::convertTo<GLuint        >(this->program  ),
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename ID_TYPE     = GLuint   ,
      typename PNAME_TYPE  = GLenum   ,
      typename PARAMS_TYPE = GLuint64*>
    class GetQueryObjectui64v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "id"    )return(void*)&this->id    ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        ID_TYPE     id    ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetQueryObjectui64v(
            ID_TYPE     const&id    ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->id     = id    ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetQueryObjectui64v(){}
        virtual void operator()(){
          glGetQueryObjectui64v(
            ge::core::convertTo<GLuint   >(this->id    ),
            ge::core::convertTo<GLenum   >(this->pname ),
            ge::core::convertTo<GLuint64*>(this->params)
          );
        }
    };

    template<
      typename MODE_TYPE      = GLenum        ,
      typename FIRST_TYPE     = const GLint*  ,
      typename COUNT_TYPE     = const GLsizei*,
      typename DRAWCOUNT_TYPE = GLsizei       >
    class MultiDrawArrays:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"     )return(void*)&this->mode     ;
          if(name == "first"    )return(void*)&this->first    ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "drawcount")return(void*)&this->drawcount;
          return NULL;
        }
      public:
        MODE_TYPE      mode     ;
        FIRST_TYPE     first    ;
        COUNT_TYPE     count    ;
        DRAWCOUNT_TYPE drawcount;
        MultiDrawArrays(
            MODE_TYPE      const&mode     ,
            FIRST_TYPE     const&first    ,
            COUNT_TYPE     const&count    ,
            DRAWCOUNT_TYPE const&drawcount){
          this->mode      = mode     ;
          this->first     = first    ;
          this->count     = count    ;
          this->drawcount = drawcount;
        }
        virtual~MultiDrawArrays(){}
        virtual void operator()(){
          glMultiDrawArrays(
            ge::core::convertTo<GLenum        >(this->mode     ),
            ge::core::convertTo<const GLint*  >(this->first    ),
            ge::core::convertTo<const GLsizei*>(this->count    ),
            ge::core::convertTo<GLsizei       >(this->drawcount)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    class VertexAttribI2iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribI2iv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribI2iv(){}
        virtual void operator()(){
          glVertexAttribI2iv(
            ge::core::convertTo<GLuint      >(this->index),
            ge::core::convertTo<const GLint*>(this->v    )
          );
        }
    };

    template<
      typename SHADERTYPE_TYPE    = GLenum,
      typename PRECISIONTYPE_TYPE = GLenum,
      typename RANGE_TYPE         = GLint*,
      typename PRECISION_TYPE     = GLint*>
    class GetShaderPrecisionFormat:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "shadertype"   )return(void*)&this->shadertype   ;
          if(name == "precisiontype")return(void*)&this->precisiontype;
          if(name == "range"        )return(void*)&this->range        ;
          if(name == "precision"    )return(void*)&this->precision    ;
          return NULL;
        }
      public:
        SHADERTYPE_TYPE    shadertype   ;
        PRECISIONTYPE_TYPE precisiontype;
        RANGE_TYPE         range        ;
        PRECISION_TYPE     precision    ;
        GetShaderPrecisionFormat(
            SHADERTYPE_TYPE    const&shadertype   ,
            PRECISIONTYPE_TYPE const&precisiontype,
            RANGE_TYPE         const&range        ,
            PRECISION_TYPE     const&precision    ){
          this->shadertype    = shadertype   ;
          this->precisiontype = precisiontype;
          this->range         = range        ;
          this->precision     = precision    ;
        }
        virtual~GetShaderPrecisionFormat(){}
        virtual void operator()(){
          glGetShaderPrecisionFormat(
            ge::core::convertTo<GLenum>(this->shadertype   ),
            ge::core::convertTo<GLenum>(this->precisiontype),
            ge::core::convertTo<GLint*>(this->range        ),
            ge::core::convertTo<GLint*>(this->precision    )
          );
        }
    };

    template<
      typename FLAG_TYPE = GLboolean>
    class DepthMask:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "flag")return(void*)&this->flag;
          return NULL;
        }
      public:
        FLAG_TYPE flag;
        DepthMask(
            FLAG_TYPE const&flag){
          this->flag = flag;
        }
        virtual~DepthMask(){}
        virtual void operator()(){
          glDepthMask(
            ge::core::convertTo<GLboolean>(this->flag)
          );
        }
    };

    template<
      typename TEXTURE_TYPE        = GLuint,
      typename TARGET_TYPE         = GLenum,
      typename ORIGTEXTURE_TYPE    = GLuint,
      typename INTERNALFORMAT_TYPE = GLenum,
      typename MINLEVEL_TYPE       = GLuint,
      typename NUMLEVELS_TYPE      = GLuint,
      typename MINLAYER_TYPE       = GLuint,
      typename NUMLAYERS_TYPE      = GLuint>
    class TextureView:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture"       )return(void*)&this->texture       ;
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "origtexture"   )return(void*)&this->origtexture   ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "minlevel"      )return(void*)&this->minlevel      ;
          if(name == "numlevels"     )return(void*)&this->numlevels     ;
          if(name == "minlayer"      )return(void*)&this->minlayer      ;
          if(name == "numlayers"     )return(void*)&this->numlayers     ;
          return NULL;
        }
      public:
        TEXTURE_TYPE        texture       ;
        TARGET_TYPE         target        ;
        ORIGTEXTURE_TYPE    origtexture   ;
        INTERNALFORMAT_TYPE internalformat;
        MINLEVEL_TYPE       minlevel      ;
        NUMLEVELS_TYPE      numlevels     ;
        MINLAYER_TYPE       minlayer      ;
        NUMLAYERS_TYPE      numlayers     ;
        TextureView(
            TEXTURE_TYPE        const&texture       ,
            TARGET_TYPE         const&target        ,
            ORIGTEXTURE_TYPE    const&origtexture   ,
            INTERNALFORMAT_TYPE const&internalformat,
            MINLEVEL_TYPE       const&minlevel      ,
            NUMLEVELS_TYPE      const&numlevels     ,
            MINLAYER_TYPE       const&minlayer      ,
            NUMLAYERS_TYPE      const&numlayers     ){
          this->texture        = texture       ;
          this->target         = target        ;
          this->origtexture    = origtexture   ;
          this->internalformat = internalformat;
          this->minlevel       = minlevel      ;
          this->numlevels      = numlevels     ;
          this->minlayer       = minlayer      ;
          this->numlayers      = numlayers     ;
        }
        virtual~TextureView(){}
        virtual void operator()(){
          glTextureView(
            ge::core::convertTo<GLuint>(this->texture       ),
            ge::core::convertTo<GLenum>(this->target        ),
            ge::core::convertTo<GLuint>(this->origtexture   ),
            ge::core::convertTo<GLenum>(this->internalformat),
            ge::core::convertTo<GLuint>(this->minlevel      ),
            ge::core::convertTo<GLuint>(this->numlevels     ),
            ge::core::convertTo<GLuint>(this->minlayer      ),
            ge::core::convertTo<GLuint>(this->numlayers     )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint>
    class Disablei:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "index" )return(void*)&this->index ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        INDEX_TYPE  index ;
        Disablei(
            TARGET_TYPE const&target,
            INDEX_TYPE  const&index ){
          this->target = target;
          this->index  = index ;
        }
        virtual~Disablei(){}
        virtual void operator()(){
          glDisablei(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLuint>(this->index )
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class ProgramUniformMatrix2x4fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix2x4fv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix2x4fv(){}
        virtual void operator()(){
          glProgramUniformMatrix2x4fv(
            ge::core::convertTo<GLuint        >(this->program  ),
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename READTARGET_TYPE  = GLenum    ,
      typename WRITETARGET_TYPE = GLenum    ,
      typename READOFFSET_TYPE  = GLintptr  ,
      typename WRITEOFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE        = GLsizeiptr>
    class CopyBufferSubData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "readTarget" )return(void*)&this->readTarget ;
          if(name == "writeTarget")return(void*)&this->writeTarget;
          if(name == "readOffset" )return(void*)&this->readOffset ;
          if(name == "writeOffset")return(void*)&this->writeOffset;
          if(name == "size"       )return(void*)&this->size       ;
          return NULL;
        }
      public:
        READTARGET_TYPE  readTarget ;
        WRITETARGET_TYPE writeTarget;
        READOFFSET_TYPE  readOffset ;
        WRITEOFFSET_TYPE writeOffset;
        SIZE_TYPE        size       ;
        CopyBufferSubData(
            READTARGET_TYPE  const&readTarget ,
            WRITETARGET_TYPE const&writeTarget,
            READOFFSET_TYPE  const&readOffset ,
            WRITEOFFSET_TYPE const&writeOffset,
            SIZE_TYPE        const&size       ){
          this->readTarget  = readTarget ;
          this->writeTarget = writeTarget;
          this->readOffset  = readOffset ;
          this->writeOffset = writeOffset;
          this->size        = size       ;
        }
        virtual~CopyBufferSubData(){}
        virtual void operator()(){
          glCopyBufferSubData(
            ge::core::convertTo<GLenum    >(this->readTarget ),
            ge::core::convertTo<GLenum    >(this->writeTarget),
            ge::core::convertTo<GLintptr  >(this->readOffset ),
            ge::core::convertTo<GLintptr  >(this->writeOffset),
            ge::core::convertTo<GLsizeiptr>(this->size       )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble>
    class VertexAttribL1d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        VertexAttribL1d(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ){
          this->index = index;
          this->x     = x    ;
        }
        virtual~VertexAttribL1d(){}
        virtual void operator()(){
          glVertexAttribL1d(
            ge::core::convertTo<GLuint  >(this->index),
            ge::core::convertTo<GLdouble>(this->x    )
          );
        }
    };

    template<
      typename N_TYPE             = GLsizei      ,
      typename RENDERBUFFERS_TYPE = const GLuint*>
    class DeleteRenderbuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"            )return(void*)&this->n            ;
          if(name == "renderbuffers")return(void*)&this->renderbuffers;
          return NULL;
        }
      public:
        N_TYPE             n            ;
        RENDERBUFFERS_TYPE renderbuffers;
        DeleteRenderbuffers(
            N_TYPE             const&n            ,
            RENDERBUFFERS_TYPE const&renderbuffers){
          this->n             = n            ;
          this->renderbuffers = renderbuffers;
        }
        virtual~DeleteRenderbuffers(){}
        virtual void operator()(){
          glDeleteRenderbuffers(
            ge::core::convertTo<GLsizei      >(this->n            ),
            ge::core::convertTo<const GLuint*>(this->renderbuffers)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    class VertexAttribI3uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribI3uiv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribI3uiv(){}
        virtual void operator()(){
          glVertexAttribI3uiv(
            ge::core::convertTo<GLuint       >(this->index),
            ge::core::convertTo<const GLuint*>(this->v    )
          );
        }
    };

    class ReleaseShaderCompiler:
        public ge::core::Command{
      public:
        ReleaseShaderCompiler(
            ){
        }
        virtual~ReleaseShaderCompiler(){}
        virtual void operator()(){
          glReleaseShaderCompiler(

          );
        }
    };

    template<
      typename ATTRIBINDEX_TYPE    = GLuint,
      typename SIZE_TYPE           = GLint ,
      typename TYPE_TYPE           = GLenum,
      typename RELATIVEOFFSET_TYPE = GLuint>
    class VertexAttribIFormat:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "attribindex"   )return(void*)&this->attribindex   ;
          if(name == "size"          )return(void*)&this->size          ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "relativeoffset")return(void*)&this->relativeoffset;
          return NULL;
        }
      public:
        ATTRIBINDEX_TYPE    attribindex   ;
        SIZE_TYPE           size          ;
        TYPE_TYPE           type          ;
        RELATIVEOFFSET_TYPE relativeoffset;
        VertexAttribIFormat(
            ATTRIBINDEX_TYPE    const&attribindex   ,
            SIZE_TYPE           const&size          ,
            TYPE_TYPE           const&type          ,
            RELATIVEOFFSET_TYPE const&relativeoffset){
          this->attribindex    = attribindex   ;
          this->size           = size          ;
          this->type           = type          ;
          this->relativeoffset = relativeoffset;
        }
        virtual~VertexAttribIFormat(){}
        virtual void operator()(){
          glVertexAttribIFormat(
            ge::core::convertTo<GLuint>(this->attribindex   ),
            ge::core::convertTo<GLint >(this->size          ),
            ge::core::convertTo<GLenum>(this->type          ),
            ge::core::convertTo<GLuint>(this->relativeoffset)
          );
        }
    };

    template<
      typename N_TYPE            = GLsizei,
      typename FRAMEBUFFERS_TYPE = GLuint*>
    class CreateFramebuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"           )return(void*)&this->n           ;
          if(name == "framebuffers")return(void*)&this->framebuffers;
          return NULL;
        }
      public:
        N_TYPE            n           ;
        FRAMEBUFFERS_TYPE framebuffers;
        CreateFramebuffers(
            N_TYPE            const&n           ,
            FRAMEBUFFERS_TYPE const&framebuffers){
          this->n            = n           ;
          this->framebuffers = framebuffers;
        }
        virtual~CreateFramebuffers(){}
        virtual void operator()(){
          glCreateFramebuffers(
            ge::core::convertTo<GLsizei>(this->n           ),
            ge::core::convertTo<GLuint*>(this->framebuffers)
          );
        }
    };

    template<
      typename SYNC_TYPE    = GLsync  ,
      typename PNAME_TYPE   = GLenum  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename VALUES_TYPE  = GLint*  >
    class GetSynciv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sync"   )return(void*)&this->sync   ;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "length" )return(void*)&this->length ;
          if(name == "values" )return(void*)&this->values ;
          return NULL;
        }
      public:
        SYNC_TYPE    sync   ;
        PNAME_TYPE   pname  ;
        BUFSIZE_TYPE bufSize;
        LENGTH_TYPE  length ;
        VALUES_TYPE  values ;
        GetSynciv(
            SYNC_TYPE    const&sync   ,
            PNAME_TYPE   const&pname  ,
            BUFSIZE_TYPE const&bufSize,
            LENGTH_TYPE  const&length ,
            VALUES_TYPE  const&values ){
          this->sync    = sync   ;
          this->pname   = pname  ;
          this->bufSize = bufSize;
          this->length  = length ;
          this->values  = values ;
        }
        virtual~GetSynciv(){}
        virtual void operator()(){
          glGetSynciv(
            ge::core::convertTo<GLsync  >(this->sync   ),
            ge::core::convertTo<GLenum  >(this->pname  ),
            ge::core::convertTo<GLsizei >(this->bufSize),
            ge::core::convertTo<GLsizei*>(this->length ),
            ge::core::convertTo<GLint*  >(this->values )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint         ,
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    class ProgramUniform2dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform2dv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform2dv(){}
        virtual void operator()(){
          glProgramUniform2dv(
            ge::core::convertTo<GLuint         >(this->program ),
            ge::core::convertTo<GLint          >(this->location),
            ge::core::convertTo<GLsizei        >(this->count   ),
            ge::core::convertTo<const GLdouble*>(this->value   )
          );
        }
    };

    template<
      typename TARGET_TYPE               = GLenum   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename DEPTH_TYPE                = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    class TexImage3DMultisample:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"              )return(void*)&this->target              ;
          if(name == "samples"             )return(void*)&this->samples             ;
          if(name == "internalformat"      )return(void*)&this->internalformat      ;
          if(name == "width"               )return(void*)&this->width               ;
          if(name == "height"              )return(void*)&this->height              ;
          if(name == "depth"               )return(void*)&this->depth               ;
          if(name == "fixedsamplelocations")return(void*)&this->fixedsamplelocations;
          return NULL;
        }
      public:
        TARGET_TYPE               target              ;
        SAMPLES_TYPE              samples             ;
        INTERNALFORMAT_TYPE       internalformat      ;
        WIDTH_TYPE                width               ;
        HEIGHT_TYPE               height              ;
        DEPTH_TYPE                depth               ;
        FIXEDSAMPLELOCATIONS_TYPE fixedsamplelocations;
        TexImage3DMultisample(
            TARGET_TYPE               const&target              ,
            SAMPLES_TYPE              const&samples             ,
            INTERNALFORMAT_TYPE       const&internalformat      ,
            WIDTH_TYPE                const&width               ,
            HEIGHT_TYPE               const&height              ,
            DEPTH_TYPE                const&depth               ,
            FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
          this->target               = target              ;
          this->samples              = samples             ;
          this->internalformat       = internalformat      ;
          this->width                = width               ;
          this->height               = height              ;
          this->depth                = depth               ;
          this->fixedsamplelocations = fixedsamplelocations;
        }
        virtual~TexImage3DMultisample(){}
        virtual void operator()(){
          glTexImage3DMultisample(
            ge::core::convertTo<GLenum   >(this->target              ),
            ge::core::convertTo<GLsizei  >(this->samples             ),
            ge::core::convertTo<GLenum   >(this->internalformat      ),
            ge::core::convertTo<GLsizei  >(this->width               ),
            ge::core::convertTo<GLsizei  >(this->height              ),
            ge::core::convertTo<GLsizei  >(this->depth               ),
            ge::core::convertTo<GLboolean>(this->fixedsamplelocations)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLint ,
      typename V1_TYPE       = GLint >
    class ProgramUniform2i:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        ProgramUniform2i(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
        }
        virtual~ProgramUniform2i(){}
        virtual void operator()(){
          glProgramUniform2i(
            ge::core::convertTo<GLuint>(this->program ),
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLint >(this->v0      ),
            ge::core::convertTo<GLint >(this->v1      )
          );
        }
    };

    template<
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLint64*>
    class GetNamedBufferParameteri64v:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        BUFFER_TYPE buffer;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetNamedBufferParameteri64v(
            BUFFER_TYPE const&buffer,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->buffer = buffer;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetNamedBufferParameteri64v(){}
        virtual void operator()(){
          glGetNamedBufferParameteri64v(
            ge::core::convertTo<GLuint  >(this->buffer),
            ge::core::convertTo<GLenum  >(this->pname ),
            ge::core::convertTo<GLint64*>(this->params)
          );
        }
    };

    template<
      typename MODE_TYPE      = GLenum     ,
      typename TYPE_TYPE      = GLenum     ,
      typename INDIRECT_TYPE  = const void*,
      typename DRAWCOUNT_TYPE = GLsizei    ,
      typename STRIDE_TYPE    = GLsizei    >
    class MultiDrawElementsIndirect:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"     )return(void*)&this->mode     ;
          if(name == "type"     )return(void*)&this->type     ;
          if(name == "indirect" )return(void*)&this->indirect ;
          if(name == "drawcount")return(void*)&this->drawcount;
          if(name == "stride"   )return(void*)&this->stride   ;
          return NULL;
        }
      public:
        MODE_TYPE      mode     ;
        TYPE_TYPE      type     ;
        INDIRECT_TYPE  indirect ;
        DRAWCOUNT_TYPE drawcount;
        STRIDE_TYPE    stride   ;
        MultiDrawElementsIndirect(
            MODE_TYPE      const&mode     ,
            TYPE_TYPE      const&type     ,
            INDIRECT_TYPE  const&indirect ,
            DRAWCOUNT_TYPE const&drawcount,
            STRIDE_TYPE    const&stride   ){
          this->mode      = mode     ;
          this->type      = type     ;
          this->indirect  = indirect ;
          this->drawcount = drawcount;
          this->stride    = stride   ;
        }
        virtual~MultiDrawElementsIndirect(){}
        virtual void operator()(){
          glMultiDrawElementsIndirect(
            ge::core::convertTo<GLenum     >(this->mode     ),
            ge::core::convertTo<GLenum     >(this->type     ),
            ge::core::convertTo<const void*>(this->indirect ),
            ge::core::convertTo<GLsizei    >(this->drawcount),
            ge::core::convertTo<GLsizei    >(this->stride   )
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class UniformMatrix4fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix4fv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix4fv(){}
        virtual void operator()(){
          glUniformMatrix4fv(
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename BUFFER_TYPE = GLuint>
    class BindBuffer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "buffer")return(void*)&this->buffer;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        BUFFER_TYPE buffer;
        BindBuffer(
            TARGET_TYPE const&target,
            BUFFER_TYPE const&buffer){
          this->target = target;
          this->buffer = buffer;
        }
        virtual~BindBuffer(){}
        virtual void operator()(){
          glBindBuffer(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLuint>(this->buffer)
          );
        }
    };

    template<
      typename DEPTH_TYPE = GLdouble>
    class ClearDepth:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "depth")return(void*)&this->depth;
          return NULL;
        }
      public:
        DEPTH_TYPE depth;
        ClearDepth(
            DEPTH_TYPE const&depth){
          this->depth = depth;
        }
        virtual~ClearDepth(){}
        virtual void operator()(){
          glClearDepth(
            ge::core::convertTo<GLdouble>(this->depth)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename V0_TYPE       = GLdouble,
      typename V1_TYPE       = GLdouble>
    class ProgramUniform2d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        ProgramUniform2d(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
        }
        virtual~ProgramUniform2d(){}
        virtual void operator()(){
          glProgramUniform2d(
            ge::core::convertTo<GLuint  >(this->program ),
            ge::core::convertTo<GLint   >(this->location),
            ge::core::convertTo<GLdouble>(this->v0      ),
            ge::core::convertTo<GLdouble>(this->v1      )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat>
    class ProgramUniform2f:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        ProgramUniform2f(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
        }
        virtual~ProgramUniform2f(){}
        virtual void operator()(){
          glProgramUniform2f(
            ge::core::convertTo<GLuint >(this->program ),
            ge::core::convertTo<GLint  >(this->location),
            ge::core::convertTo<GLfloat>(this->v0      ),
            ge::core::convertTo<GLfloat>(this->v1      )
          );
        }
    };

    template<
      typename PROGRAM_TYPE      = GLuint  ,
      typename BUFSIZE_TYPE      = GLsizei ,
      typename LENGTH_TYPE       = GLsizei*,
      typename BINARYFORMAT_TYPE = GLenum* ,
      typename BINARY_TYPE       = void*   >
    class GetProgramBinary:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"     )return(void*)&this->program     ;
          if(name == "bufSize"     )return(void*)&this->bufSize     ;
          if(name == "length"      )return(void*)&this->length      ;
          if(name == "binaryFormat")return(void*)&this->binaryFormat;
          if(name == "binary"      )return(void*)&this->binary      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE      program     ;
        BUFSIZE_TYPE      bufSize     ;
        LENGTH_TYPE       length      ;
        BINARYFORMAT_TYPE binaryFormat;
        BINARY_TYPE       binary      ;
        GetProgramBinary(
            PROGRAM_TYPE      const&program     ,
            BUFSIZE_TYPE      const&bufSize     ,
            LENGTH_TYPE       const&length      ,
            BINARYFORMAT_TYPE const&binaryFormat,
            BINARY_TYPE       const&binary      ){
          this->program      = program     ;
          this->bufSize      = bufSize     ;
          this->length       = length      ;
          this->binaryFormat = binaryFormat;
          this->binary       = binary      ;
        }
        virtual~GetProgramBinary(){}
        virtual void operator()(){
          glGetProgramBinary(
            ge::core::convertTo<GLuint  >(this->program     ),
            ge::core::convertTo<GLsizei >(this->bufSize     ),
            ge::core::convertTo<GLsizei*>(this->length      ),
            ge::core::convertTo<GLenum* >(this->binaryFormat),
            ge::core::convertTo<void*   >(this->binary      )
          );
        }
    };

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    class UniformMatrix2x4fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        UniformMatrix2x4fv(
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~UniformMatrix2x4fv(){}
        virtual void operator()(){
          glUniformMatrix2x4fv(
            ge::core::convertTo<GLint         >(this->location ),
            ge::core::convertTo<GLsizei       >(this->count    ),
            ge::core::convertTo<GLboolean     >(this->transpose),
            ge::core::convertTo<const GLfloat*>(this->value    )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum     ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*,
      typename USAGE_TYPE  = GLenum     >
    class BufferData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "size"  )return(void*)&this->size  ;
          if(name == "data"  )return(void*)&this->data  ;
          if(name == "usage" )return(void*)&this->usage ;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        SIZE_TYPE   size  ;
        DATA_TYPE   data  ;
        USAGE_TYPE  usage ;
        BufferData(
            TARGET_TYPE const&target,
            SIZE_TYPE   const&size  ,
            DATA_TYPE   const&data  ,
            USAGE_TYPE  const&usage ){
          this->target = target;
          this->size   = size  ;
          this->data   = data  ;
          this->usage  = usage ;
        }
        virtual~BufferData(){}
        virtual void operator()(){
          glBufferData(
            ge::core::convertTo<GLenum     >(this->target),
            ge::core::convertTo<GLsizeiptr >(this->size  ),
            ge::core::convertTo<const void*>(this->data  ),
            ge::core::convertTo<GLenum     >(this->usage )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetTexParameterIiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetTexParameterIiv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetTexParameterIiv(){}
        virtual void operator()(){
          glGetTexParameterIiv(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    class PauseTransformFeedback:
        public ge::core::Command{
      public:
        PauseTransformFeedback(
            ){
        }
        virtual~PauseTransformFeedback(){}
        virtual void operator()(){
          glPauseTransformFeedback(

          );
        }
    };

    template<
      typename RET_TYPE = GLenum>
    class GetError:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret")return(void*)&this->ret;
          return NULL;
        }
      public:
        RET_TYPE ret;
        GetError(
            RET_TYPE const&ret){
          this->ret = ret;
        }
        virtual~GetError(){}
        virtual void operator()(){
          ge::core::convertFrom<GLenum>(this->ret,glGetError()
          );
        }
    };

    template<
      typename N_TYPE   = GLsizei,
      typename IDS_TYPE = GLuint*>
    class CreateTransformFeedbacks:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"  )return(void*)&this->n  ;
          if(name == "ids")return(void*)&this->ids;
          return NULL;
        }
      public:
        N_TYPE   n  ;
        IDS_TYPE ids;
        CreateTransformFeedbacks(
            N_TYPE   const&n  ,
            IDS_TYPE const&ids){
          this->n   = n  ;
          this->ids = ids;
        }
        virtual~CreateTransformFeedbacks(){}
        virtual void operator()(){
          glCreateTransformFeedbacks(
            ge::core::convertTo<GLsizei>(this->n  ),
            ge::core::convertTo<GLuint*>(this->ids)
          );
        }
    };

    template<
      typename FAIL_TYPE  = GLenum,
      typename ZFAIL_TYPE = GLenum,
      typename ZPASS_TYPE = GLenum>
    class StencilOp:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "fail" )return(void*)&this->fail ;
          if(name == "zfail")return(void*)&this->zfail;
          if(name == "zpass")return(void*)&this->zpass;
          return NULL;
        }
      public:
        FAIL_TYPE  fail ;
        ZFAIL_TYPE zfail;
        ZPASS_TYPE zpass;
        StencilOp(
            FAIL_TYPE  const&fail ,
            ZFAIL_TYPE const&zfail,
            ZPASS_TYPE const&zpass){
          this->fail  = fail ;
          this->zfail = zfail;
          this->zpass = zpass;
        }
        virtual~StencilOp(){}
        virtual void operator()(){
          glStencilOp(
            ge::core::convertTo<GLenum>(this->fail ),
            ge::core::convertTo<GLenum>(this->zfail),
            ge::core::convertTo<GLenum>(this->zpass)
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei>
    class CopyTextureSubImage3D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "yoffset")return(void*)&this->yoffset;
          if(name == "zoffset")return(void*)&this->zoffset;
          if(name == "x"      )return(void*)&this->x      ;
          if(name == "y"      )return(void*)&this->y      ;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        YOFFSET_TYPE yoffset;
        ZOFFSET_TYPE zoffset;
        X_TYPE       x      ;
        Y_TYPE       y      ;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        CopyTextureSubImage3D(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            YOFFSET_TYPE const&yoffset,
            ZOFFSET_TYPE const&zoffset,
            X_TYPE       const&x      ,
            Y_TYPE       const&y      ,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ){
          this->texture = texture;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->yoffset = yoffset;
          this->zoffset = zoffset;
          this->x       = x      ;
          this->y       = y      ;
          this->width   = width  ;
          this->height  = height ;
        }
        virtual~CopyTextureSubImage3D(){}
        virtual void operator()(){
          glCopyTextureSubImage3D(
            ge::core::convertTo<GLuint >(this->texture),
            ge::core::convertTo<GLint  >(this->level  ),
            ge::core::convertTo<GLint  >(this->xoffset),
            ge::core::convertTo<GLint  >(this->yoffset),
            ge::core::convertTo<GLint  >(this->zoffset),
            ge::core::convertTo<GLint  >(this->x      ),
            ge::core::convertTo<GLint  >(this->y      ),
            ge::core::convertTo<GLsizei>(this->width  ),
            ge::core::convertTo<GLsizei>(this->height )
          );
        }
    };

    template<
      typename TARGET_TYPE  = GLenum     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    class TexSubImage1D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target" )return(void*)&this->target ;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "format" )return(void*)&this->format ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "pixels" )return(void*)&this->pixels ;
          return NULL;
        }
      public:
        TARGET_TYPE  target ;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        WIDTH_TYPE   width  ;
        FORMAT_TYPE  format ;
        TYPE_TYPE    type   ;
        PIXELS_TYPE  pixels ;
        TexSubImage1D(
            TARGET_TYPE  const&target ,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            WIDTH_TYPE   const&width  ,
            FORMAT_TYPE  const&format ,
            TYPE_TYPE    const&type   ,
            PIXELS_TYPE  const&pixels ){
          this->target  = target ;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->width   = width  ;
          this->format  = format ;
          this->type    = type   ;
          this->pixels  = pixels ;
        }
        virtual~TexSubImage1D(){}
        virtual void operator()(){
          glTexSubImage1D(
            ge::core::convertTo<GLenum     >(this->target ),
            ge::core::convertTo<GLint      >(this->level  ),
            ge::core::convertTo<GLint      >(this->xoffset),
            ge::core::convertTo<GLsizei    >(this->width  ),
            ge::core::convertTo<GLenum     >(this->format ),
            ge::core::convertTo<GLenum     >(this->type   ),
            ge::core::convertTo<const void*>(this->pixels )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    class VertexAttrib2fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib2fv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib2fv(){}
        virtual void operator()(){
          glVertexAttrib2fv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLfloat*>(this->v    )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum  ,
      typename LEVEL_TYPE  = GLint   ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLfloat*>
    class GetTexLevelParameterfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "level" )return(void*)&this->level ;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        LEVEL_TYPE  level ;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetTexLevelParameterfv(
            TARGET_TYPE const&target,
            LEVEL_TYPE  const&level ,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->level  = level ;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetTexLevelParameterfv(){}
        virtual void operator()(){
          glGetTexLevelParameterfv(
            ge::core::convertTo<GLenum  >(this->target),
            ge::core::convertTo<GLint   >(this->level ),
            ge::core::convertTo<GLenum  >(this->pname ),
            ge::core::convertTo<GLfloat*>(this->params)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLint >
    class VertexAttribI1i:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        VertexAttribI1i(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ){
          this->index = index;
          this->x     = x    ;
        }
        virtual~VertexAttribI1i(){}
        virtual void operator()(){
          glVertexAttribI1i(
            ge::core::convertTo<GLuint>(this->index),
            ge::core::convertTo<GLint >(this->x    )
          );
        }
    };

    template<
      typename INDEX_TYPE      = GLuint       ,
      typename TYPE_TYPE       = GLenum       ,
      typename NORMALIZED_TYPE = GLboolean    ,
      typename VALUE_TYPE      = const GLuint*>
    class VertexAttribP3uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index"     )return(void*)&this->index     ;
          if(name == "type"      )return(void*)&this->type      ;
          if(name == "normalized")return(void*)&this->normalized;
          if(name == "value"     )return(void*)&this->value     ;
          return NULL;
        }
      public:
        INDEX_TYPE      index     ;
        TYPE_TYPE       type      ;
        NORMALIZED_TYPE normalized;
        VALUE_TYPE      value     ;
        VertexAttribP3uiv(
            INDEX_TYPE      const&index     ,
            TYPE_TYPE       const&type      ,
            NORMALIZED_TYPE const&normalized,
            VALUE_TYPE      const&value     ){
          this->index      = index     ;
          this->type       = type      ;
          this->normalized = normalized;
          this->value      = value     ;
        }
        virtual~VertexAttribP3uiv(){}
        virtual void operator()(){
          glVertexAttribP3uiv(
            ge::core::convertTo<GLuint       >(this->index     ),
            ge::core::convertTo<GLenum       >(this->type      ),
            ge::core::convertTo<GLboolean    >(this->normalized),
            ge::core::convertTo<const GLuint*>(this->value     )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    class VertexAttribI3iv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribI3iv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribI3iv(){}
        virtual void operator()(){
          glVertexAttribI3iv(
            ge::core::convertTo<GLuint      >(this->index),
            ge::core::convertTo<const GLint*>(this->v    )
          );
        }
    };

    template<
      typename PNAME_TYPE = GLenum,
      typename DATA_TYPE  = GLint*>
    class GetIntegerv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname")return(void*)&this->pname;
          if(name == "data" )return(void*)&this->data ;
          return NULL;
        }
      public:
        PNAME_TYPE pname;
        DATA_TYPE  data ;
        GetIntegerv(
            PNAME_TYPE const&pname,
            DATA_TYPE  const&data ){
          this->pname = pname;
          this->data  = data ;
        }
        virtual~GetIntegerv(){}
        virtual void operator()(){
          glGetIntegerv(
            ge::core::convertTo<GLenum>(this->pname),
            ge::core::convertTo<GLint*>(this->data )
          );
        }
    };

    template<
      typename TARGET_TYPE  = GLenum ,
      typename LEVEL_TYPE   = GLint  ,
      typename FORMAT_TYPE  = GLenum ,
      typename TYPE_TYPE    = GLenum ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    class GetnTexImage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target" )return(void*)&this->target ;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "format" )return(void*)&this->format ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "pixels" )return(void*)&this->pixels ;
          return NULL;
        }
      public:
        TARGET_TYPE  target ;
        LEVEL_TYPE   level  ;
        FORMAT_TYPE  format ;
        TYPE_TYPE    type   ;
        BUFSIZE_TYPE bufSize;
        PIXELS_TYPE  pixels ;
        GetnTexImage(
            TARGET_TYPE  const&target ,
            LEVEL_TYPE   const&level  ,
            FORMAT_TYPE  const&format ,
            TYPE_TYPE    const&type   ,
            BUFSIZE_TYPE const&bufSize,
            PIXELS_TYPE  const&pixels ){
          this->target  = target ;
          this->level   = level  ;
          this->format  = format ;
          this->type    = type   ;
          this->bufSize = bufSize;
          this->pixels  = pixels ;
        }
        virtual~GetnTexImage(){}
        virtual void operator()(){
          glGetnTexImage(
            ge::core::convertTo<GLenum >(this->target ),
            ge::core::convertTo<GLint  >(this->level  ),
            ge::core::convertTo<GLenum >(this->format ),
            ge::core::convertTo<GLenum >(this->type   ),
            ge::core::convertTo<GLsizei>(this->bufSize),
            ge::core::convertTo<void*  >(this->pixels )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = void**>
    class GetBufferPointerv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetBufferPointerv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetBufferPointerv(){}
        virtual void operator()(){
          glGetBufferPointerv(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<void**>(this->params)
          );
        }
    };

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    class ProgramUniformMatrix3dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program"  )return(void*)&this->program  ;
          if(name == "location" )return(void*)&this->location ;
          if(name == "count"    )return(void*)&this->count    ;
          if(name == "transpose")return(void*)&this->transpose;
          if(name == "value"    )return(void*)&this->value    ;
          return NULL;
        }
      public:
        PROGRAM_TYPE   program  ;
        LOCATION_TYPE  location ;
        COUNT_TYPE     count    ;
        TRANSPOSE_TYPE transpose;
        VALUE_TYPE     value    ;
        ProgramUniformMatrix3dv(
            PROGRAM_TYPE   const&program  ,
            LOCATION_TYPE  const&location ,
            COUNT_TYPE     const&count    ,
            TRANSPOSE_TYPE const&transpose,
            VALUE_TYPE     const&value    ){
          this->program   = program  ;
          this->location  = location ;
          this->count     = count    ;
          this->transpose = transpose;
          this->value     = value    ;
        }
        virtual~ProgramUniformMatrix3dv(){}
        virtual void operator()(){
          glProgramUniformMatrix3dv(
            ge::core::convertTo<GLuint         >(this->program  ),
            ge::core::convertTo<GLint          >(this->location ),
            ge::core::convertTo<GLsizei        >(this->count    ),
            ge::core::convertTo<GLboolean      >(this->transpose),
            ge::core::convertTo<const GLdouble*>(this->value    )
          );
        }
    };

    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTARGET_TYPE  = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint ,
      typename ZOFFSET_TYPE    = GLint >
    class FramebufferTexture3D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"    )return(void*)&this->target    ;
          if(name == "attachment")return(void*)&this->attachment;
          if(name == "textarget" )return(void*)&this->textarget ;
          if(name == "texture"   )return(void*)&this->texture   ;
          if(name == "level"     )return(void*)&this->level     ;
          if(name == "zoffset"   )return(void*)&this->zoffset   ;
          return NULL;
        }
      public:
        TARGET_TYPE     target    ;
        ATTACHMENT_TYPE attachment;
        TEXTARGET_TYPE  textarget ;
        TEXTURE_TYPE    texture   ;
        LEVEL_TYPE      level     ;
        ZOFFSET_TYPE    zoffset   ;
        FramebufferTexture3D(
            TARGET_TYPE     const&target    ,
            ATTACHMENT_TYPE const&attachment,
            TEXTARGET_TYPE  const&textarget ,
            TEXTURE_TYPE    const&texture   ,
            LEVEL_TYPE      const&level     ,
            ZOFFSET_TYPE    const&zoffset   ){
          this->target     = target    ;
          this->attachment = attachment;
          this->textarget  = textarget ;
          this->texture    = texture   ;
          this->level      = level     ;
          this->zoffset    = zoffset   ;
        }
        virtual~FramebufferTexture3D(){}
        virtual void operator()(){
          glFramebufferTexture3D(
            ge::core::convertTo<GLenum>(this->target    ),
            ge::core::convertTo<GLenum>(this->attachment),
            ge::core::convertTo<GLenum>(this->textarget ),
            ge::core::convertTo<GLuint>(this->texture   ),
            ge::core::convertTo<GLint >(this->level     ),
            ge::core::convertTo<GLint >(this->zoffset   )
          );
        }
    };

    template<
      typename RET_TYPE = GLboolean,
      typename ID_TYPE  = GLuint   >
    class IsQuery:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret")return(void*)&this->ret;
          if(name == "id" )return(void*)&this->id ;
          return NULL;
        }
      public:
        RET_TYPE ret;
        ID_TYPE  id ;
        IsQuery(
            RET_TYPE const&ret,
            ID_TYPE  const&id ){
          this->ret = ret;
          this->id  = id ;
        }
        virtual~IsQuery(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsQuery(
              ge::core::convertTo<GLuint   >(this->id ))
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint>
    class ProgramUniform2ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        ProgramUniform2ui(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
        }
        virtual~ProgramUniform2ui(){}
        virtual void operator()(){
          glProgramUniform2ui(
            ge::core::convertTo<GLuint>(this->program ),
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLuint>(this->v0      ),
            ge::core::convertTo<GLuint>(this->v1      )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint,
      typename V2_TYPE       = GLuint,
      typename V3_TYPE       = GLuint>
    class ProgramUniform4ui:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "v0"      )return(void*)&this->v0      ;
          if(name == "v1"      )return(void*)&this->v1      ;
          if(name == "v2"      )return(void*)&this->v2      ;
          if(name == "v3"      )return(void*)&this->v3      ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        V0_TYPE       v0      ;
        V1_TYPE       v1      ;
        V2_TYPE       v2      ;
        V3_TYPE       v3      ;
        ProgramUniform4ui(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            V0_TYPE       const&v0      ,
            V1_TYPE       const&v1      ,
            V2_TYPE       const&v2      ,
            V3_TYPE       const&v3      ){
          this->program  = program ;
          this->location = location;
          this->v0       = v0      ;
          this->v1       = v1      ;
          this->v2       = v2      ;
          this->v3       = v3      ;
        }
        virtual~ProgramUniform4ui(){}
        virtual void operator()(){
          glProgramUniform4ui(
            ge::core::convertTo<GLuint>(this->program ),
            ge::core::convertTo<GLint >(this->location),
            ge::core::convertTo<GLuint>(this->v0      ),
            ge::core::convertTo<GLuint>(this->v1      ),
            ge::core::convertTo<GLuint>(this->v2      ),
            ge::core::convertTo<GLuint>(this->v3      )
          );
        }
    };

    template<
      typename VAOBJ_TYPE = GLuint,
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint*>
    class GetVertexArrayiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "vaobj")return(void*)&this->vaobj;
          if(name == "pname")return(void*)&this->pname;
          if(name == "param")return(void*)&this->param;
          return NULL;
        }
      public:
        VAOBJ_TYPE vaobj;
        PNAME_TYPE pname;
        PARAM_TYPE param;
        GetVertexArrayiv(
            VAOBJ_TYPE const&vaobj,
            PNAME_TYPE const&pname,
            PARAM_TYPE const&param){
          this->vaobj = vaobj;
          this->pname = pname;
          this->param = param;
        }
        virtual~GetVertexArrayiv(){}
        virtual void operator()(){
          glGetVertexArrayiv(
            ge::core::convertTo<GLuint>(this->vaobj),
            ge::core::convertTo<GLenum>(this->pname),
            ge::core::convertTo<GLint*>(this->param)
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLint      ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename HEIGHT_TYPE         = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename PIXELS_TYPE         = const void*>
    class TexImage2D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "level"         )return(void*)&this->level         ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          if(name == "border"        )return(void*)&this->border        ;
          if(name == "format"        )return(void*)&this->format        ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "pixels"        )return(void*)&this->pixels        ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        LEVEL_TYPE          level         ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        BORDER_TYPE         border        ;
        FORMAT_TYPE         format        ;
        TYPE_TYPE           type          ;
        PIXELS_TYPE         pixels        ;
        TexImage2D(
            TARGET_TYPE         const&target        ,
            LEVEL_TYPE          const&level         ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ,
            BORDER_TYPE         const&border        ,
            FORMAT_TYPE         const&format        ,
            TYPE_TYPE           const&type          ,
            PIXELS_TYPE         const&pixels        ){
          this->target         = target        ;
          this->level          = level         ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->height         = height        ;
          this->border         = border        ;
          this->format         = format        ;
          this->type           = type          ;
          this->pixels         = pixels        ;
        }
        virtual~TexImage2D(){}
        virtual void operator()(){
          glTexImage2D(
            ge::core::convertTo<GLenum     >(this->target        ),
            ge::core::convertTo<GLint      >(this->level         ),
            ge::core::convertTo<GLint      >(this->internalformat),
            ge::core::convertTo<GLsizei    >(this->width         ),
            ge::core::convertTo<GLsizei    >(this->height        ),
            ge::core::convertTo<GLint      >(this->border        ),
            ge::core::convertTo<GLenum     >(this->format        ),
            ge::core::convertTo<GLenum     >(this->type          ),
            ge::core::convertTo<const void*>(this->pixels        )
          );
        }
    };

    template<
      typename MASK_TYPE = GLuint>
    class StencilMask:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mask")return(void*)&this->mask;
          return NULL;
        }
      public:
        MASK_TYPE mask;
        StencilMask(
            MASK_TYPE const&mask){
          this->mask = mask;
        }
        virtual~StencilMask(){}
        virtual void operator()(){
          glStencilMask(
            ge::core::convertTo<GLuint>(this->mask)
          );
        }
    };

    template<
      typename SAMPLER_TYPE = GLuint        ,
      typename PNAME_TYPE   = GLenum        ,
      typename PARAM_TYPE   = const GLfloat*>
    class SamplerParameterfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sampler")return(void*)&this->sampler;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "param"  )return(void*)&this->param  ;
          return NULL;
        }
      public:
        SAMPLER_TYPE sampler;
        PNAME_TYPE   pname  ;
        PARAM_TYPE   param  ;
        SamplerParameterfv(
            SAMPLER_TYPE const&sampler,
            PNAME_TYPE   const&pname  ,
            PARAM_TYPE   const&param  ){
          this->sampler = sampler;
          this->pname   = pname  ;
          this->param   = param  ;
        }
        virtual~SamplerParameterfv(){}
        virtual void operator()(){
          glSamplerParameterfv(
            ge::core::convertTo<GLuint        >(this->sampler),
            ge::core::convertTo<GLenum        >(this->pname  ),
            ge::core::convertTo<const GLfloat*>(this->param  )
          );
        }
    };

    template<
      typename RET_TYPE     = GLboolean,
      typename TEXTURE_TYPE = GLuint   >
    class IsTexture:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"    )return(void*)&this->ret    ;
          if(name == "texture")return(void*)&this->texture;
          return NULL;
        }
      public:
        RET_TYPE     ret    ;
        TEXTURE_TYPE texture;
        IsTexture(
            RET_TYPE     const&ret    ,
            TEXTURE_TYPE const&texture){
          this->ret     = ret    ;
          this->texture = texture;
        }
        virtual~IsTexture(){}
        virtual void operator()(){
          ge::core::convertFrom<GLboolean>(this->ret,glIsTexture(
              ge::core::convertTo<GLuint   >(this->texture))
          );
        }
    };

    template<
      typename BUFFER_TYPE = GLuint     ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*,
      typename USAGE_TYPE  = GLenum     >
    class NamedBufferData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer")return(void*)&this->buffer;
          if(name == "size"  )return(void*)&this->size  ;
          if(name == "data"  )return(void*)&this->data  ;
          if(name == "usage" )return(void*)&this->usage ;
          return NULL;
        }
      public:
        BUFFER_TYPE buffer;
        SIZE_TYPE   size  ;
        DATA_TYPE   data  ;
        USAGE_TYPE  usage ;
        NamedBufferData(
            BUFFER_TYPE const&buffer,
            SIZE_TYPE   const&size  ,
            DATA_TYPE   const&data  ,
            USAGE_TYPE  const&usage ){
          this->buffer = buffer;
          this->size   = size  ;
          this->data   = data  ;
          this->usage  = usage ;
        }
        virtual~NamedBufferData(){}
        virtual void operator()(){
          glNamedBufferData(
            ge::core::convertTo<GLuint     >(this->buffer),
            ge::core::convertTo<GLsizeiptr >(this->size  ),
            ge::core::convertTo<const void*>(this->data  ),
            ge::core::convertTo<GLenum     >(this->usage )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    class Uniform1fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform1fv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform1fv(){}
        virtual void operator()(){
          glUniform1fv(
            ge::core::convertTo<GLint         >(this->location),
            ge::core::convertTo<GLsizei       >(this->count   ),
            ge::core::convertTo<const GLfloat*>(this->value   )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLubyte*>
    class VertexAttrib4Nubv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib4Nubv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib4Nubv(){}
        virtual void operator()(){
          glVertexAttrib4Nubv(
            ge::core::convertTo<GLuint        >(this->index),
            ge::core::convertTo<const GLubyte*>(this->v    )
          );
        }
    };

    template<
      typename BUFFER_TYPE         = GLuint     ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename OFFSET_TYPE         = GLintptr   ,
      typename SIZE_TYPE           = GLsizeiptr ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename DATA_TYPE           = const void*>
    class ClearNamedBufferSubData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "buffer"        )return(void*)&this->buffer        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "offset"        )return(void*)&this->offset        ;
          if(name == "size"          )return(void*)&this->size          ;
          if(name == "format"        )return(void*)&this->format        ;
          if(name == "type"          )return(void*)&this->type          ;
          if(name == "data"          )return(void*)&this->data          ;
          return NULL;
        }
      public:
        BUFFER_TYPE         buffer        ;
        INTERNALFORMAT_TYPE internalformat;
        OFFSET_TYPE         offset        ;
        SIZE_TYPE           size          ;
        FORMAT_TYPE         format        ;
        TYPE_TYPE           type          ;
        DATA_TYPE           data          ;
        ClearNamedBufferSubData(
            BUFFER_TYPE         const&buffer        ,
            INTERNALFORMAT_TYPE const&internalformat,
            OFFSET_TYPE         const&offset        ,
            SIZE_TYPE           const&size          ,
            FORMAT_TYPE         const&format        ,
            TYPE_TYPE           const&type          ,
            DATA_TYPE           const&data          ){
          this->buffer         = buffer        ;
          this->internalformat = internalformat;
          this->offset         = offset        ;
          this->size           = size          ;
          this->format         = format        ;
          this->type           = type          ;
          this->data           = data          ;
        }
        virtual~ClearNamedBufferSubData(){}
        virtual void operator()(){
          glClearNamedBufferSubData(
            ge::core::convertTo<GLuint     >(this->buffer        ),
            ge::core::convertTo<GLenum     >(this->internalformat),
            ge::core::convertTo<GLintptr   >(this->offset        ),
            ge::core::convertTo<GLsizeiptr >(this->size          ),
            ge::core::convertTo<GLenum     >(this->format        ),
            ge::core::convertTo<GLenum     >(this->type          ),
            ge::core::convertTo<const void*>(this->data          )
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum        ,
      typename PNAME_TYPE  = GLenum        ,
      typename PARAMS_TYPE = const GLfloat*>
    class TexParameterfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        TexParameterfv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~TexParameterfv(){}
        virtual void operator()(){
          glTexParameterfv(
            ge::core::convertTo<GLenum        >(this->target),
            ge::core::convertTo<GLenum        >(this->pname ),
            ge::core::convertTo<const GLfloat*>(this->params)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    class ScissorIndexedv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        ScissorIndexedv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~ScissorIndexedv(){}
        virtual void operator()(){
          glScissorIndexedv(
            ge::core::convertTo<GLuint      >(this->index),
            ge::core::convertTo<const GLint*>(this->v    )
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    class Uniform3dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform3dv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform3dv(){}
        virtual void operator()(){
          glUniform3dv(
            ge::core::convertTo<GLint          >(this->location),
            ge::core::convertTo<GLsizei        >(this->count   ),
            ge::core::convertTo<const GLdouble*>(this->value   )
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint        ,
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    class ProgramUniform3fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform3fv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform3fv(){}
        virtual void operator()(){
          glProgramUniform3fv(
            ge::core::convertTo<GLuint        >(this->program ),
            ge::core::convertTo<GLint         >(this->location),
            ge::core::convertTo<GLsizei       >(this->count   ),
            ge::core::convertTo<const GLfloat*>(this->value   )
          );
        }
    };

    template<
      typename RET_TYPE        = GLint        ,
      typename PROGRAM_TYPE    = GLuint       ,
      typename SHADERTYPE_TYPE = GLenum       ,
      typename NAME_TYPE       = const GLchar*>
    class GetSubroutineUniformLocation:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"       )return(void*)&this->ret       ;
          if(name == "program"   )return(void*)&this->program   ;
          if(name == "shadertype")return(void*)&this->shadertype;
          if(name == "name"      )return(void*)&this->name      ;
          return NULL;
        }
      public:
        RET_TYPE        ret       ;
        PROGRAM_TYPE    program   ;
        SHADERTYPE_TYPE shadertype;
        NAME_TYPE       name      ;
        GetSubroutineUniformLocation(
            RET_TYPE        const&ret       ,
            PROGRAM_TYPE    const&program   ,
            SHADERTYPE_TYPE const&shadertype,
            NAME_TYPE       const&name      ){
          this->ret        = ret       ;
          this->program    = program   ;
          this->shadertype = shadertype;
          this->name       = name      ;
        }
        virtual~GetSubroutineUniformLocation(){}
        virtual void operator()(){
          ge::core::convertFrom<GLint>(this->ret,glGetSubroutineUniformLocation(
              ge::core::convertTo<GLuint       >(this->program   ),
              ge::core::convertTo<GLenum       >(this->shadertype),
              ge::core::convertTo<const GLchar*>(this->name      ))
          );
        }
    };

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    class GetFramebufferParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target")return(void*)&this->target;
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "params")return(void*)&this->params;
          return NULL;
        }
      public:
        TARGET_TYPE target;
        PNAME_TYPE  pname ;
        PARAMS_TYPE params;
        GetFramebufferParameteriv(
            TARGET_TYPE const&target,
            PNAME_TYPE  const&pname ,
            PARAMS_TYPE const&params){
          this->target = target;
          this->pname  = pname ;
          this->params = params;
        }
        virtual~GetFramebufferParameteriv(){}
        virtual void operator()(){
          glGetFramebufferParameteriv(
            ge::core::convertTo<GLenum>(this->target),
            ge::core::convertTo<GLenum>(this->pname ),
            ge::core::convertTo<GLint*>(this->params)
          );
        }
    };

    template<
      typename SAMPLER_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    class GetSamplerParameteriv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "sampler")return(void*)&this->sampler;
          if(name == "pname"  )return(void*)&this->pname  ;
          if(name == "params" )return(void*)&this->params ;
          return NULL;
        }
      public:
        SAMPLER_TYPE sampler;
        PNAME_TYPE   pname  ;
        PARAMS_TYPE  params ;
        GetSamplerParameteriv(
            SAMPLER_TYPE const&sampler,
            PNAME_TYPE   const&pname  ,
            PARAMS_TYPE  const&params ){
          this->sampler = sampler;
          this->pname   = pname  ;
          this->params  = params ;
        }
        virtual~GetSamplerParameteriv(){}
        virtual void operator()(){
          glGetSamplerParameteriv(
            ge::core::convertTo<GLuint>(this->sampler),
            ge::core::convertTo<GLenum>(this->pname  ),
            ge::core::convertTo<GLint*>(this->params )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei,
      typename DEPTH_TYPE   = GLsizei,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    class GetCompressedTextureSubImage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "xoffset")return(void*)&this->xoffset;
          if(name == "yoffset")return(void*)&this->yoffset;
          if(name == "zoffset")return(void*)&this->zoffset;
          if(name == "width"  )return(void*)&this->width  ;
          if(name == "height" )return(void*)&this->height ;
          if(name == "depth"  )return(void*)&this->depth  ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "pixels" )return(void*)&this->pixels ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        XOFFSET_TYPE xoffset;
        YOFFSET_TYPE yoffset;
        ZOFFSET_TYPE zoffset;
        WIDTH_TYPE   width  ;
        HEIGHT_TYPE  height ;
        DEPTH_TYPE   depth  ;
        BUFSIZE_TYPE bufSize;
        PIXELS_TYPE  pixels ;
        GetCompressedTextureSubImage(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            XOFFSET_TYPE const&xoffset,
            YOFFSET_TYPE const&yoffset,
            ZOFFSET_TYPE const&zoffset,
            WIDTH_TYPE   const&width  ,
            HEIGHT_TYPE  const&height ,
            DEPTH_TYPE   const&depth  ,
            BUFSIZE_TYPE const&bufSize,
            PIXELS_TYPE  const&pixels ){
          this->texture = texture;
          this->level   = level  ;
          this->xoffset = xoffset;
          this->yoffset = yoffset;
          this->zoffset = zoffset;
          this->width   = width  ;
          this->height  = height ;
          this->depth   = depth  ;
          this->bufSize = bufSize;
          this->pixels  = pixels ;
        }
        virtual~GetCompressedTextureSubImage(){}
        virtual void operator()(){
          glGetCompressedTextureSubImage(
            ge::core::convertTo<GLuint >(this->texture),
            ge::core::convertTo<GLint  >(this->level  ),
            ge::core::convertTo<GLint  >(this->xoffset),
            ge::core::convertTo<GLint  >(this->yoffset),
            ge::core::convertTo<GLint  >(this->zoffset),
            ge::core::convertTo<GLsizei>(this->width  ),
            ge::core::convertTo<GLsizei>(this->height ),
            ge::core::convertTo<GLsizei>(this->depth  ),
            ge::core::convertTo<GLsizei>(this->bufSize),
            ge::core::convertTo<void*  >(this->pixels )
          );
        }
    };

    template<
      typename N_TYPE    = GLsizei      ,
      typename BUFS_TYPE = const GLenum*>
    class DrawBuffers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"   )return(void*)&this->n   ;
          if(name == "bufs")return(void*)&this->bufs;
          return NULL;
        }
      public:
        N_TYPE    n   ;
        BUFS_TYPE bufs;
        DrawBuffers(
            N_TYPE    const&n   ,
            BUFS_TYPE const&bufs){
          this->n    = n   ;
          this->bufs = bufs;
        }
        virtual~DrawBuffers(){}
        virtual void operator()(){
          glDrawBuffers(
            ge::core::convertTo<GLsizei      >(this->n   ),
            ge::core::convertTo<const GLenum*>(this->bufs)
          );
        }
    };

    template<
      typename FIRST_TYPE    = GLuint       ,
      typename COUNT_TYPE    = GLsizei      ,
      typename SAMPLERS_TYPE = const GLuint*>
    class BindSamplers:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "first"   )return(void*)&this->first   ;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "samplers")return(void*)&this->samplers;
          return NULL;
        }
      public:
        FIRST_TYPE    first   ;
        COUNT_TYPE    count   ;
        SAMPLERS_TYPE samplers;
        BindSamplers(
            FIRST_TYPE    const&first   ,
            COUNT_TYPE    const&count   ,
            SAMPLERS_TYPE const&samplers){
          this->first    = first   ;
          this->count    = count   ;
          this->samplers = samplers;
        }
        virtual~BindSamplers(){}
        virtual void operator()(){
          glBindSamplers(
            ge::core::convertTo<GLuint       >(this->first   ),
            ge::core::convertTo<GLsizei      >(this->count   ),
            ge::core::convertTo<const GLuint*>(this->samplers)
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    class VertexAttribI1uiv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttribI1uiv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttribI1uiv(){}
        virtual void operator()(){
          glVertexAttribI1uiv(
            ge::core::convertTo<GLuint       >(this->index),
            ge::core::convertTo<const GLuint*>(this->v    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble>
    class VertexAttrib2d:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        VertexAttrib2d(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
        }
        virtual~VertexAttrib2d(){}
        virtual void operator()(){
          glVertexAttrib2d(
            ge::core::convertTo<GLuint  >(this->index),
            ge::core::convertTo<GLdouble>(this->x    ),
            ge::core::convertTo<GLdouble>(this->y    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat,
      typename Y_TYPE     = GLfloat>
    class VertexAttrib2f:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "x"    )return(void*)&this->x    ;
          if(name == "y"    )return(void*)&this->y    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        X_TYPE     x    ;
        Y_TYPE     y    ;
        VertexAttrib2f(
            INDEX_TYPE const&index,
            X_TYPE     const&x    ,
            Y_TYPE     const&y    ){
          this->index = index;
          this->x     = x    ;
          this->y     = y    ;
        }
        virtual~VertexAttrib2f(){}
        virtual void operator()(){
          glVertexAttrib2f(
            ge::core::convertTo<GLuint >(this->index),
            ge::core::convertTo<GLfloat>(this->x    ),
            ge::core::convertTo<GLfloat>(this->y    )
          );
        }
    };

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    class VertexAttrib3dv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "index")return(void*)&this->index;
          if(name == "v"    )return(void*)&this->v    ;
          return NULL;
        }
      public:
        INDEX_TYPE index;
        V_TYPE     v    ;
        VertexAttrib3dv(
            INDEX_TYPE const&index,
            V_TYPE     const&v    ){
          this->index = index;
          this->v     = v    ;
        }
        virtual~VertexAttrib3dv(){}
        virtual void operator()(){
          glVertexAttrib3dv(
            ge::core::convertTo<GLuint         >(this->index),
            ge::core::convertTo<const GLdouble*>(this->v    )
          );
        }
    };

    template<
      typename SRCNAME_TYPE   = GLuint ,
      typename SRCTARGET_TYPE = GLenum ,
      typename SRCLEVEL_TYPE  = GLint  ,
      typename SRCX_TYPE      = GLint  ,
      typename SRCY_TYPE      = GLint  ,
      typename SRCZ_TYPE      = GLint  ,
      typename DSTNAME_TYPE   = GLuint ,
      typename DSTTARGET_TYPE = GLenum ,
      typename DSTLEVEL_TYPE  = GLint  ,
      typename DSTX_TYPE      = GLint  ,
      typename DSTY_TYPE      = GLint  ,
      typename DSTZ_TYPE      = GLint  ,
      typename SRCWIDTH_TYPE  = GLsizei,
      typename SRCHEIGHT_TYPE = GLsizei,
      typename SRCDEPTH_TYPE  = GLsizei>
    class CopyImageSubData:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "srcName"  )return(void*)&this->srcName  ;
          if(name == "srcTarget")return(void*)&this->srcTarget;
          if(name == "srcLevel" )return(void*)&this->srcLevel ;
          if(name == "srcX"     )return(void*)&this->srcX     ;
          if(name == "srcY"     )return(void*)&this->srcY     ;
          if(name == "srcZ"     )return(void*)&this->srcZ     ;
          if(name == "dstName"  )return(void*)&this->dstName  ;
          if(name == "dstTarget")return(void*)&this->dstTarget;
          if(name == "dstLevel" )return(void*)&this->dstLevel ;
          if(name == "dstX"     )return(void*)&this->dstX     ;
          if(name == "dstY"     )return(void*)&this->dstY     ;
          if(name == "dstZ"     )return(void*)&this->dstZ     ;
          if(name == "srcWidth" )return(void*)&this->srcWidth ;
          if(name == "srcHeight")return(void*)&this->srcHeight;
          if(name == "srcDepth" )return(void*)&this->srcDepth ;
          return NULL;
        }
      public:
        SRCNAME_TYPE   srcName  ;
        SRCTARGET_TYPE srcTarget;
        SRCLEVEL_TYPE  srcLevel ;
        SRCX_TYPE      srcX     ;
        SRCY_TYPE      srcY     ;
        SRCZ_TYPE      srcZ     ;
        DSTNAME_TYPE   dstName  ;
        DSTTARGET_TYPE dstTarget;
        DSTLEVEL_TYPE  dstLevel ;
        DSTX_TYPE      dstX     ;
        DSTY_TYPE      dstY     ;
        DSTZ_TYPE      dstZ     ;
        SRCWIDTH_TYPE  srcWidth ;
        SRCHEIGHT_TYPE srcHeight;
        SRCDEPTH_TYPE  srcDepth ;
        CopyImageSubData(
            SRCNAME_TYPE   const&srcName  ,
            SRCTARGET_TYPE const&srcTarget,
            SRCLEVEL_TYPE  const&srcLevel ,
            SRCX_TYPE      const&srcX     ,
            SRCY_TYPE      const&srcY     ,
            SRCZ_TYPE      const&srcZ     ,
            DSTNAME_TYPE   const&dstName  ,
            DSTTARGET_TYPE const&dstTarget,
            DSTLEVEL_TYPE  const&dstLevel ,
            DSTX_TYPE      const&dstX     ,
            DSTY_TYPE      const&dstY     ,
            DSTZ_TYPE      const&dstZ     ,
            SRCWIDTH_TYPE  const&srcWidth ,
            SRCHEIGHT_TYPE const&srcHeight,
            SRCDEPTH_TYPE  const&srcDepth ){
          this->srcName   = srcName  ;
          this->srcTarget = srcTarget;
          this->srcLevel  = srcLevel ;
          this->srcX      = srcX     ;
          this->srcY      = srcY     ;
          this->srcZ      = srcZ     ;
          this->dstName   = dstName  ;
          this->dstTarget = dstTarget;
          this->dstLevel  = dstLevel ;
          this->dstX      = dstX     ;
          this->dstY      = dstY     ;
          this->dstZ      = dstZ     ;
          this->srcWidth  = srcWidth ;
          this->srcHeight = srcHeight;
          this->srcDepth  = srcDepth ;
        }
        virtual~CopyImageSubData(){}
        virtual void operator()(){
          glCopyImageSubData(
            ge::core::convertTo<GLuint >(this->srcName  ),
            ge::core::convertTo<GLenum >(this->srcTarget),
            ge::core::convertTo<GLint  >(this->srcLevel ),
            ge::core::convertTo<GLint  >(this->srcX     ),
            ge::core::convertTo<GLint  >(this->srcY     ),
            ge::core::convertTo<GLint  >(this->srcZ     ),
            ge::core::convertTo<GLuint >(this->dstName  ),
            ge::core::convertTo<GLenum >(this->dstTarget),
            ge::core::convertTo<GLint  >(this->dstLevel ),
            ge::core::convertTo<GLint  >(this->dstX     ),
            ge::core::convertTo<GLint  >(this->dstY     ),
            ge::core::convertTo<GLint  >(this->dstZ     ),
            ge::core::convertTo<GLsizei>(this->srcWidth ),
            ge::core::convertTo<GLsizei>(this->srcHeight),
            ge::core::convertTo<GLsizei>(this->srcDepth )
          );
        }
    };

    template<
      typename PIPELINE_TYPE = GLuint,
      typename PROGRAM_TYPE  = GLuint>
    class ActiveShaderProgram:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pipeline")return(void*)&this->pipeline;
          if(name == "program" )return(void*)&this->program ;
          return NULL;
        }
      public:
        PIPELINE_TYPE pipeline;
        PROGRAM_TYPE  program ;
        ActiveShaderProgram(
            PIPELINE_TYPE const&pipeline,
            PROGRAM_TYPE  const&program ){
          this->pipeline = pipeline;
          this->program  = program ;
        }
        virtual~ActiveShaderProgram(){}
        virtual void operator()(){
          glActiveShaderProgram(
            ge::core::convertTo<GLuint>(this->pipeline),
            ge::core::convertTo<GLuint>(this->program )
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename FORMAT_TYPE  = GLenum ,
      typename TYPE_TYPE    = GLenum ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    class GetTextureImage:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture")return(void*)&this->texture;
          if(name == "level"  )return(void*)&this->level  ;
          if(name == "format" )return(void*)&this->format ;
          if(name == "type"   )return(void*)&this->type   ;
          if(name == "bufSize")return(void*)&this->bufSize;
          if(name == "pixels" )return(void*)&this->pixels ;
          return NULL;
        }
      public:
        TEXTURE_TYPE texture;
        LEVEL_TYPE   level  ;
        FORMAT_TYPE  format ;
        TYPE_TYPE    type   ;
        BUFSIZE_TYPE bufSize;
        PIXELS_TYPE  pixels ;
        GetTextureImage(
            TEXTURE_TYPE const&texture,
            LEVEL_TYPE   const&level  ,
            FORMAT_TYPE  const&format ,
            TYPE_TYPE    const&type   ,
            BUFSIZE_TYPE const&bufSize,
            PIXELS_TYPE  const&pixels ){
          this->texture = texture;
          this->level   = level  ;
          this->format  = format ;
          this->type    = type   ;
          this->bufSize = bufSize;
          this->pixels  = pixels ;
        }
        virtual~GetTextureImage(){}
        virtual void operator()(){
          glGetTextureImage(
            ge::core::convertTo<GLuint >(this->texture),
            ge::core::convertTo<GLint  >(this->level  ),
            ge::core::convertTo<GLenum >(this->format ),
            ge::core::convertTo<GLenum >(this->type   ),
            ge::core::convertTo<GLsizei>(this->bufSize),
            ge::core::convertTo<void*  >(this->pixels )
          );
        }
    };

    template<
      typename PNAME_TYPE  = GLenum        ,
      typename VALUES_TYPE = const GLfloat*>
    class PatchParameterfv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "pname" )return(void*)&this->pname ;
          if(name == "values")return(void*)&this->values;
          return NULL;
        }
      public:
        PNAME_TYPE  pname ;
        VALUES_TYPE values;
        PatchParameterfv(
            PNAME_TYPE  const&pname ,
            VALUES_TYPE const&values){
          this->pname  = pname ;
          this->values = values;
        }
        virtual~PatchParameterfv(){}
        virtual void operator()(){
          glPatchParameterfv(
            ge::core::convertTo<GLenum        >(this->pname ),
            ge::core::convertTo<const GLfloat*>(this->values)
          );
        }
    };

    template<
      typename PROGRAM_TYPE  = GLuint        ,
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    class ProgramUniform1fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "program" )return(void*)&this->program ;
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        PROGRAM_TYPE  program ;
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        ProgramUniform1fv(
            PROGRAM_TYPE  const&program ,
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->program  = program ;
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~ProgramUniform1fv(){}
        virtual void operator()(){
          glProgramUniform1fv(
            ge::core::convertTo<GLuint        >(this->program ),
            ge::core::convertTo<GLint         >(this->location),
            ge::core::convertTo<GLsizei       >(this->count   ),
            ge::core::convertTo<const GLfloat*>(this->value   )
          );
        }
    };

    template<
      typename RET_TYPE              = GLuint       ,
      typename PROGRAM_TYPE          = GLuint       ,
      typename UNIFORMBLOCKNAME_TYPE = const GLchar*>
    class GetUniformBlockIndex:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "ret"             )return(void*)&this->ret             ;
          if(name == "program"         )return(void*)&this->program         ;
          if(name == "uniformBlockName")return(void*)&this->uniformBlockName;
          return NULL;
        }
      public:
        RET_TYPE              ret             ;
        PROGRAM_TYPE          program         ;
        UNIFORMBLOCKNAME_TYPE uniformBlockName;
        GetUniformBlockIndex(
            RET_TYPE              const&ret             ,
            PROGRAM_TYPE          const&program         ,
            UNIFORMBLOCKNAME_TYPE const&uniformBlockName){
          this->ret              = ret             ;
          this->program          = program         ;
          this->uniformBlockName = uniformBlockName;
        }
        virtual~GetUniformBlockIndex(){}
        virtual void operator()(){
          ge::core::convertFrom<GLuint>(this->ret,glGetUniformBlockIndex(
              ge::core::convertTo<GLuint       >(this->program         ),
              ge::core::convertTo<const GLchar*>(this->uniformBlockName))
          );
        }
    };

    template<
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    class Uniform4fv:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "location")return(void*)&this->location;
          if(name == "count"   )return(void*)&this->count   ;
          if(name == "value"   )return(void*)&this->value   ;
          return NULL;
        }
      public:
        LOCATION_TYPE location;
        COUNT_TYPE    count   ;
        VALUE_TYPE    value   ;
        Uniform4fv(
            LOCATION_TYPE const&location,
            COUNT_TYPE    const&count   ,
            VALUE_TYPE    const&value   ){
          this->location = location;
          this->count    = count   ;
          this->value    = value   ;
        }
        virtual~Uniform4fv(){}
        virtual void operator()(){
          glUniform4fv(
            ge::core::convertTo<GLint         >(this->location),
            ge::core::convertTo<GLsizei       >(this->count   ),
            ge::core::convertTo<const GLfloat*>(this->value   )
          );
        }
    };

    template<
      typename TEXTURE_TYPE        = GLuint ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    class TextureStorage2D:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "texture"       )return(void*)&this->texture       ;
          if(name == "levels"        )return(void*)&this->levels        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "width"         )return(void*)&this->width         ;
          if(name == "height"        )return(void*)&this->height        ;
          return NULL;
        }
      public:
        TEXTURE_TYPE        texture       ;
        LEVELS_TYPE         levels        ;
        INTERNALFORMAT_TYPE internalformat;
        WIDTH_TYPE          width         ;
        HEIGHT_TYPE         height        ;
        TextureStorage2D(
            TEXTURE_TYPE        const&texture       ,
            LEVELS_TYPE         const&levels        ,
            INTERNALFORMAT_TYPE const&internalformat,
            WIDTH_TYPE          const&width         ,
            HEIGHT_TYPE         const&height        ){
          this->texture        = texture       ;
          this->levels         = levels        ;
          this->internalformat = internalformat;
          this->width          = width         ;
          this->height         = height        ;
        }
        virtual~TextureStorage2D(){}
        virtual void operator()(){
          glTextureStorage2D(
            ge::core::convertTo<GLuint >(this->texture       ),
            ge::core::convertTo<GLsizei>(this->levels        ),
            ge::core::convertTo<GLenum >(this->internalformat),
            ge::core::convertTo<GLsizei>(this->width         ),
            ge::core::convertTo<GLsizei>(this->height        )
          );
        }
    };

    template<
      typename MODE_TYPE = GLenum>
    class FrontFace:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode")return(void*)&this->mode;
          return NULL;
        }
      public:
        MODE_TYPE mode;
        FrontFace(
            MODE_TYPE const&mode){
          this->mode = mode;
        }
        virtual~FrontFace(){}
        virtual void operator()(){
          glFrontFace(
            ge::core::convertTo<GLenum>(this->mode)
          );
        }
    };

    template<
      typename TARGET_TYPE         = GLenum    ,
      typename INTERNALFORMAT_TYPE = GLenum    ,
      typename BUFFER_TYPE         = GLuint    ,
      typename OFFSET_TYPE         = GLintptr  ,
      typename SIZE_TYPE           = GLsizeiptr>
    class TexBufferRange:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "target"        )return(void*)&this->target        ;
          if(name == "internalformat")return(void*)&this->internalformat;
          if(name == "buffer"        )return(void*)&this->buffer        ;
          if(name == "offset"        )return(void*)&this->offset        ;
          if(name == "size"          )return(void*)&this->size          ;
          return NULL;
        }
      public:
        TARGET_TYPE         target        ;
        INTERNALFORMAT_TYPE internalformat;
        BUFFER_TYPE         buffer        ;
        OFFSET_TYPE         offset        ;
        SIZE_TYPE           size          ;
        TexBufferRange(
            TARGET_TYPE         const&target        ,
            INTERNALFORMAT_TYPE const&internalformat,
            BUFFER_TYPE         const&buffer        ,
            OFFSET_TYPE         const&offset        ,
            SIZE_TYPE           const&size          ){
          this->target         = target        ;
          this->internalformat = internalformat;
          this->buffer         = buffer        ;
          this->offset         = offset        ;
          this->size           = size          ;
        }
        virtual~TexBufferRange(){}
        virtual void operator()(){
          glTexBufferRange(
            ge::core::convertTo<GLenum    >(this->target        ),
            ge::core::convertTo<GLenum    >(this->internalformat),
            ge::core::convertTo<GLuint    >(this->buffer        ),
            ge::core::convertTo<GLintptr  >(this->offset        ),
            ge::core::convertTo<GLsizeiptr>(this->size          )
          );
        }
    };

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename ATTACHMENT_TYPE  = GLenum,
      typename TEXTURE_TYPE     = GLuint,
      typename LEVEL_TYPE       = GLint ,
      typename LAYER_TYPE       = GLint >
    class NamedFramebufferTextureLayer:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "framebuffer")return(void*)&this->framebuffer;
          if(name == "attachment" )return(void*)&this->attachment ;
          if(name == "texture"    )return(void*)&this->texture    ;
          if(name == "level"      )return(void*)&this->level      ;
          if(name == "layer"      )return(void*)&this->layer      ;
          return NULL;
        }
      public:
        FRAMEBUFFER_TYPE framebuffer;
        ATTACHMENT_TYPE  attachment ;
        TEXTURE_TYPE     texture    ;
        LEVEL_TYPE       level      ;
        LAYER_TYPE       layer      ;
        NamedFramebufferTextureLayer(
            FRAMEBUFFER_TYPE const&framebuffer,
            ATTACHMENT_TYPE  const&attachment ,
            TEXTURE_TYPE     const&texture    ,
            LEVEL_TYPE       const&level      ,
            LAYER_TYPE       const&layer      ){
          this->framebuffer = framebuffer;
          this->attachment  = attachment ;
          this->texture     = texture    ;
          this->level       = level      ;
          this->layer       = layer      ;
        }
        virtual~NamedFramebufferTextureLayer(){}
        virtual void operator()(){
          glNamedFramebufferTextureLayer(
            ge::core::convertTo<GLuint>(this->framebuffer),
            ge::core::convertTo<GLenum>(this->attachment ),
            ge::core::convertTo<GLuint>(this->texture    ),
            ge::core::convertTo<GLint >(this->level      ),
            ge::core::convertTo<GLint >(this->layer      )
          );
        }
    };

    template<
      typename MODE_TYPE          = GLenum ,
      typename FIRST_TYPE         = GLint  ,
      typename COUNT_TYPE         = GLsizei,
      typename INSTANCECOUNT_TYPE = GLsizei,
      typename BASEINSTANCE_TYPE  = GLuint >
    class DrawArraysInstancedBaseInstance:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "mode"         )return(void*)&this->mode         ;
          if(name == "first"        )return(void*)&this->first        ;
          if(name == "count"        )return(void*)&this->count        ;
          if(name == "instancecount")return(void*)&this->instancecount;
          if(name == "baseinstance" )return(void*)&this->baseinstance ;
          return NULL;
        }
      public:
        MODE_TYPE          mode         ;
        FIRST_TYPE         first        ;
        COUNT_TYPE         count        ;
        INSTANCECOUNT_TYPE instancecount;
        BASEINSTANCE_TYPE  baseinstance ;
        DrawArraysInstancedBaseInstance(
            MODE_TYPE          const&mode         ,
            FIRST_TYPE         const&first        ,
            COUNT_TYPE         const&count        ,
            INSTANCECOUNT_TYPE const&instancecount,
            BASEINSTANCE_TYPE  const&baseinstance ){
          this->mode          = mode         ;
          this->first         = first        ;
          this->count         = count        ;
          this->instancecount = instancecount;
          this->baseinstance  = baseinstance ;
        }
        virtual~DrawArraysInstancedBaseInstance(){}
        virtual void operator()(){
          glDrawArraysInstancedBaseInstance(
            ge::core::convertTo<GLenum >(this->mode         ),
            ge::core::convertTo<GLint  >(this->first        ),
            ge::core::convertTo<GLsizei>(this->count        ),
            ge::core::convertTo<GLsizei>(this->instancecount),
            ge::core::convertTo<GLuint >(this->baseinstance )
          );
        }
    };

    template<
      typename N_TYPE         = GLsizei      ,
      typename PIPELINES_TYPE = const GLuint*>
    class DeleteProgramPipelines:
        public ge::core::Command{
      protected:
        void*_getAttribAddress(std::string name){
          if(name == "n"        )return(void*)&this->n        ;
          if(name == "pipelines")return(void*)&this->pipelines;
          return NULL;
        }
      public:
        N_TYPE         n        ;
        PIPELINES_TYPE pipelines;
        DeleteProgramPipelines(
            N_TYPE         const&n        ,
            PIPELINES_TYPE const&pipelines){
          this->n         = n        ;
          this->pipelines = pipelines;
        }
        virtual~DeleteProgramPipelines(){}
        virtual void operator()(){
          glDeleteProgramPipelines(
            ge::core::convertTo<GLsizei      >(this->n        ),
            ge::core::convertTo<const GLuint*>(this->pipelines)
          );
        }
    };

    template<
      typename TEXTURE_TYPE = GLuint        ,
      typename PNAME_TYPE   = GLenum        ,
      typename PARAM_TYPE   = const GLfloat*>
    inline TextureParameterfv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >* newTextureParameterfv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return new TextureParameterfv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >(
              texture,
              pname  ,
              param  );
    }
    template<
      typename TEXTURE_TYPE = GLuint        ,
      typename PNAME_TYPE   = GLenum        ,
      typename PARAM_TYPE   = const GLfloat*>
    inline std::shared_ptr<TextureParameterfv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >> sharedTextureParameterfv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return std::make_shared<TextureParameterfv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >>(
              texture,
              pname  ,
              param  );
    }

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLuint,
      typename Y_TYPE     = GLuint,
      typename Z_TYPE     = GLuint>
    inline VertexAttribI3ui<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    >* newVertexAttribI3ui(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ){
        return new VertexAttribI3ui<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    >(
              index,
              x    ,
              y    ,
              z    );
    }
    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLuint,
      typename Y_TYPE     = GLuint,
      typename Z_TYPE     = GLuint>
    inline std::shared_ptr<VertexAttribI3ui<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    >> sharedVertexAttribI3ui(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ){
        return std::make_shared<VertexAttribI3ui<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    >>(
              index,
              x    ,
              y    ,
              z    );
    }

    template<
      typename VAOBJ_TYPE  = GLuint,
      typename BUFFER_TYPE = GLuint>
    inline VertexArrayElementBuffer<
      VAOBJ_TYPE ,
      BUFFER_TYPE>* newVertexArrayElementBuffer(
        VAOBJ_TYPE  const&vaobj ,
        BUFFER_TYPE const&buffer){
        return new VertexArrayElementBuffer<
          VAOBJ_TYPE ,
          BUFFER_TYPE>(
              vaobj ,
              buffer);
    }
    template<
      typename VAOBJ_TYPE  = GLuint,
      typename BUFFER_TYPE = GLuint>
    inline std::shared_ptr<VertexArrayElementBuffer<
      VAOBJ_TYPE ,
      BUFFER_TYPE>> sharedVertexArrayElementBuffer(
        VAOBJ_TYPE  const&vaobj ,
        BUFFER_TYPE const&buffer){
        return std::make_shared<VertexArrayElementBuffer<
          VAOBJ_TYPE ,
          BUFFER_TYPE>>(
              vaobj ,
              buffer);
    }

    template<
      typename FACE_TYPE = GLenum,
      typename MASK_TYPE = GLuint>
    inline StencilMaskSeparate<
      FACE_TYPE,
      MASK_TYPE>* newStencilMaskSeparate(
        FACE_TYPE const&face,
        MASK_TYPE const&mask){
        return new StencilMaskSeparate<
          FACE_TYPE,
          MASK_TYPE>(
              face,
              mask);
    }
    template<
      typename FACE_TYPE = GLenum,
      typename MASK_TYPE = GLuint>
    inline std::shared_ptr<StencilMaskSeparate<
      FACE_TYPE,
      MASK_TYPE>> sharedStencilMaskSeparate(
        FACE_TYPE const&face,
        MASK_TYPE const&mask){
        return std::make_shared<StencilMaskSeparate<
          FACE_TYPE,
          MASK_TYPE>>(
              face,
              mask);
    }

    template<
      typename TEXTURE_TYPE              = GLuint   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename DEPTH_TYPE                = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    inline TextureStorage3DMultisample<
      TEXTURE_TYPE             ,
      SAMPLES_TYPE             ,
      INTERNALFORMAT_TYPE      ,
      WIDTH_TYPE               ,
      HEIGHT_TYPE              ,
      DEPTH_TYPE               ,
      FIXEDSAMPLELOCATIONS_TYPE>* newTextureStorage3DMultisample(
        TEXTURE_TYPE              const&texture             ,
        SAMPLES_TYPE              const&samples             ,
        INTERNALFORMAT_TYPE       const&internalformat      ,
        WIDTH_TYPE                const&width               ,
        HEIGHT_TYPE               const&height              ,
        DEPTH_TYPE                const&depth               ,
        FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
        return new TextureStorage3DMultisample<
          TEXTURE_TYPE             ,
          SAMPLES_TYPE             ,
          INTERNALFORMAT_TYPE      ,
          WIDTH_TYPE               ,
          HEIGHT_TYPE              ,
          DEPTH_TYPE               ,
          FIXEDSAMPLELOCATIONS_TYPE>(
              texture             ,
              samples             ,
              internalformat      ,
              width               ,
              height              ,
              depth               ,
              fixedsamplelocations);
    }
    template<
      typename TEXTURE_TYPE              = GLuint   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename DEPTH_TYPE                = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    inline std::shared_ptr<TextureStorage3DMultisample<
      TEXTURE_TYPE             ,
      SAMPLES_TYPE             ,
      INTERNALFORMAT_TYPE      ,
      WIDTH_TYPE               ,
      HEIGHT_TYPE              ,
      DEPTH_TYPE               ,
      FIXEDSAMPLELOCATIONS_TYPE>> sharedTextureStorage3DMultisample(
        TEXTURE_TYPE              const&texture             ,
        SAMPLES_TYPE              const&samples             ,
        INTERNALFORMAT_TYPE       const&internalformat      ,
        WIDTH_TYPE                const&width               ,
        HEIGHT_TYPE               const&height              ,
        DEPTH_TYPE                const&depth               ,
        FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
        return std::make_shared<TextureStorage3DMultisample<
          TEXTURE_TYPE             ,
          SAMPLES_TYPE             ,
          INTERNALFORMAT_TYPE      ,
          WIDTH_TYPE               ,
          HEIGHT_TYPE              ,
          DEPTH_TYPE               ,
          FIXEDSAMPLELOCATIONS_TYPE>>(
              texture             ,
              samples             ,
              internalformat      ,
              width               ,
              height              ,
              depth               ,
              fixedsamplelocations);
    }

    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVEL_TYPE          = GLint  ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename X_TYPE              = GLint  ,
      typename Y_TYPE              = GLint  ,
      typename WIDTH_TYPE          = GLsizei,
      typename BORDER_TYPE         = GLint  >
    inline CopyTexImage1D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      X_TYPE             ,
      Y_TYPE             ,
      WIDTH_TYPE         ,
      BORDER_TYPE        >* newCopyTexImage1D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        X_TYPE              const&x             ,
        Y_TYPE              const&y             ,
        WIDTH_TYPE          const&width         ,
        BORDER_TYPE         const&border        ){
        return new CopyTexImage1D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          X_TYPE             ,
          Y_TYPE             ,
          WIDTH_TYPE         ,
          BORDER_TYPE        >(
              target        ,
              level         ,
              internalformat,
              x             ,
              y             ,
              width         ,
              border        );
    }
    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVEL_TYPE          = GLint  ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename X_TYPE              = GLint  ,
      typename Y_TYPE              = GLint  ,
      typename WIDTH_TYPE          = GLsizei,
      typename BORDER_TYPE         = GLint  >
    inline std::shared_ptr<CopyTexImage1D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      X_TYPE             ,
      Y_TYPE             ,
      WIDTH_TYPE         ,
      BORDER_TYPE        >> sharedCopyTexImage1D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        X_TYPE              const&x             ,
        Y_TYPE              const&y             ,
        WIDTH_TYPE          const&width         ,
        BORDER_TYPE         const&border        ){
        return std::make_shared<CopyTexImage1D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          X_TYPE             ,
          Y_TYPE             ,
          WIDTH_TYPE         ,
          BORDER_TYPE        >>(
              target        ,
              level         ,
              internalformat,
              x             ,
              y             ,
              width         ,
              border        );
    }

    template<
      typename VALUE_TYPE = GLfloat>
    inline MinSampleShading<
      VALUE_TYPE>* newMinSampleShading(
        VALUE_TYPE const&value){
        return new MinSampleShading<
          VALUE_TYPE>(
              value);
    }
    template<
      typename VALUE_TYPE = GLfloat>
    inline std::shared_ptr<MinSampleShading<
      VALUE_TYPE>> sharedMinSampleShading(
        VALUE_TYPE const&value){
        return std::make_shared<MinSampleShading<
          VALUE_TYPE>>(
              value);
    }

    template<
      typename TARGET_TYPE             = GLenum,
      typename ATTACHMENT_TYPE         = GLenum,
      typename RENDERBUFFERTARGET_TYPE = GLenum,
      typename RENDERBUFFER_TYPE       = GLuint>
    inline FramebufferRenderbuffer<
      TARGET_TYPE            ,
      ATTACHMENT_TYPE        ,
      RENDERBUFFERTARGET_TYPE,
      RENDERBUFFER_TYPE      >* newFramebufferRenderbuffer(
        TARGET_TYPE             const&target            ,
        ATTACHMENT_TYPE         const&attachment        ,
        RENDERBUFFERTARGET_TYPE const&renderbuffertarget,
        RENDERBUFFER_TYPE       const&renderbuffer      ){
        return new FramebufferRenderbuffer<
          TARGET_TYPE            ,
          ATTACHMENT_TYPE        ,
          RENDERBUFFERTARGET_TYPE,
          RENDERBUFFER_TYPE      >(
              target            ,
              attachment        ,
              renderbuffertarget,
              renderbuffer      );
    }
    template<
      typename TARGET_TYPE             = GLenum,
      typename ATTACHMENT_TYPE         = GLenum,
      typename RENDERBUFFERTARGET_TYPE = GLenum,
      typename RENDERBUFFER_TYPE       = GLuint>
    inline std::shared_ptr<FramebufferRenderbuffer<
      TARGET_TYPE            ,
      ATTACHMENT_TYPE        ,
      RENDERBUFFERTARGET_TYPE,
      RENDERBUFFER_TYPE      >> sharedFramebufferRenderbuffer(
        TARGET_TYPE             const&target            ,
        ATTACHMENT_TYPE         const&attachment        ,
        RENDERBUFFERTARGET_TYPE const&renderbuffertarget,
        RENDERBUFFER_TYPE       const&renderbuffer      ){
        return std::make_shared<FramebufferRenderbuffer<
          TARGET_TYPE            ,
          ATTACHMENT_TYPE        ,
          RENDERBUFFERTARGET_TYPE,
          RENDERBUFFER_TYPE      >>(
              target            ,
              attachment        ,
              renderbuffertarget,
              renderbuffer      );
    }

    template<
      typename SHADERTYPE_TYPE = GLenum       ,
      typename COUNT_TYPE      = GLsizei      ,
      typename INDICES_TYPE    = const GLuint*>
    inline UniformSubroutinesuiv<
      SHADERTYPE_TYPE,
      COUNT_TYPE     ,
      INDICES_TYPE   >* newUniformSubroutinesuiv(
        SHADERTYPE_TYPE const&shadertype,
        COUNT_TYPE      const&count     ,
        INDICES_TYPE    const&indices   ){
        return new UniformSubroutinesuiv<
          SHADERTYPE_TYPE,
          COUNT_TYPE     ,
          INDICES_TYPE   >(
              shadertype,
              count     ,
              indices   );
    }
    template<
      typename SHADERTYPE_TYPE = GLenum       ,
      typename COUNT_TYPE      = GLsizei      ,
      typename INDICES_TYPE    = const GLuint*>
    inline std::shared_ptr<UniformSubroutinesuiv<
      SHADERTYPE_TYPE,
      COUNT_TYPE     ,
      INDICES_TYPE   >> sharedUniformSubroutinesuiv(
        SHADERTYPE_TYPE const&shadertype,
        COUNT_TYPE      const&count     ,
        INDICES_TYPE    const&indices   ){
        return std::make_shared<UniformSubroutinesuiv<
          SHADERTYPE_TYPE,
          COUNT_TYPE     ,
          INDICES_TYPE   >>(
              shadertype,
              count     ,
              indices   );
    }

    template<
      typename TARGET_TYPE    = GLenum     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename YOFFSET_TYPE   = GLint      ,
      typename ZOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename HEIGHT_TYPE    = GLsizei    ,
      typename DEPTH_TYPE     = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    inline CompressedTexSubImage3D<
      TARGET_TYPE   ,
      LEVEL_TYPE    ,
      XOFFSET_TYPE  ,
      YOFFSET_TYPE  ,
      ZOFFSET_TYPE  ,
      WIDTH_TYPE    ,
      HEIGHT_TYPE   ,
      DEPTH_TYPE    ,
      FORMAT_TYPE   ,
      IMAGESIZE_TYPE,
      DATA_TYPE     >* newCompressedTexSubImage3D(
        TARGET_TYPE    const&target   ,
        LEVEL_TYPE     const&level    ,
        XOFFSET_TYPE   const&xoffset  ,
        YOFFSET_TYPE   const&yoffset  ,
        ZOFFSET_TYPE   const&zoffset  ,
        WIDTH_TYPE     const&width    ,
        HEIGHT_TYPE    const&height   ,
        DEPTH_TYPE     const&depth    ,
        FORMAT_TYPE    const&format   ,
        IMAGESIZE_TYPE const&imageSize,
        DATA_TYPE      const&data     ){
        return new CompressedTexSubImage3D<
          TARGET_TYPE   ,
          LEVEL_TYPE    ,
          XOFFSET_TYPE  ,
          YOFFSET_TYPE  ,
          ZOFFSET_TYPE  ,
          WIDTH_TYPE    ,
          HEIGHT_TYPE   ,
          DEPTH_TYPE    ,
          FORMAT_TYPE   ,
          IMAGESIZE_TYPE,
          DATA_TYPE     >(
              target   ,
              level    ,
              xoffset  ,
              yoffset  ,
              zoffset  ,
              width    ,
              height   ,
              depth    ,
              format   ,
              imageSize,
              data     );
    }
    template<
      typename TARGET_TYPE    = GLenum     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename YOFFSET_TYPE   = GLint      ,
      typename ZOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename HEIGHT_TYPE    = GLsizei    ,
      typename DEPTH_TYPE     = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    inline std::shared_ptr<CompressedTexSubImage3D<
      TARGET_TYPE   ,
      LEVEL_TYPE    ,
      XOFFSET_TYPE  ,
      YOFFSET_TYPE  ,
      ZOFFSET_TYPE  ,
      WIDTH_TYPE    ,
      HEIGHT_TYPE   ,
      DEPTH_TYPE    ,
      FORMAT_TYPE   ,
      IMAGESIZE_TYPE,
      DATA_TYPE     >> sharedCompressedTexSubImage3D(
        TARGET_TYPE    const&target   ,
        LEVEL_TYPE     const&level    ,
        XOFFSET_TYPE   const&xoffset  ,
        YOFFSET_TYPE   const&yoffset  ,
        ZOFFSET_TYPE   const&zoffset  ,
        WIDTH_TYPE     const&width    ,
        HEIGHT_TYPE    const&height   ,
        DEPTH_TYPE     const&depth    ,
        FORMAT_TYPE    const&format   ,
        IMAGESIZE_TYPE const&imageSize,
        DATA_TYPE      const&data     ){
        return std::make_shared<CompressedTexSubImage3D<
          TARGET_TYPE   ,
          LEVEL_TYPE    ,
          XOFFSET_TYPE  ,
          YOFFSET_TYPE  ,
          ZOFFSET_TYPE  ,
          WIDTH_TYPE    ,
          HEIGHT_TYPE   ,
          DEPTH_TYPE    ,
          FORMAT_TYPE   ,
          IMAGESIZE_TYPE,
          DATA_TYPE     >>(
              target   ,
              level    ,
              xoffset  ,
              yoffset  ,
              zoffset  ,
              width    ,
              height   ,
              depth    ,
              format   ,
              imageSize,
              data     );
    }

    template<
      typename TARGET_TYPE = GLenum   ,
      typename INDEX_TYPE  = GLuint   ,
      typename DATA_TYPE   = GLdouble*>
    inline GetDoublei_v<
      TARGET_TYPE,
      INDEX_TYPE ,
      DATA_TYPE  >* newGetDoublei_v(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        DATA_TYPE   const&data  ){
        return new GetDoublei_v<
          TARGET_TYPE,
          INDEX_TYPE ,
          DATA_TYPE  >(
              target,
              index ,
              data  );
    }
    template<
      typename TARGET_TYPE = GLenum   ,
      typename INDEX_TYPE  = GLuint   ,
      typename DATA_TYPE   = GLdouble*>
    inline std::shared_ptr<GetDoublei_v<
      TARGET_TYPE,
      INDEX_TYPE ,
      DATA_TYPE  >> sharedGetDoublei_v(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        DATA_TYPE   const&data  ){
        return std::make_shared<GetDoublei_v<
          TARGET_TYPE,
          INDEX_TYPE ,
          DATA_TYPE  >>(
              target,
              index ,
              data  );
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    inline VertexAttrib1sv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib1sv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib1sv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    inline std::shared_ptr<VertexAttrib1sv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib1sv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib1sv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename VAOBJ_TYPE   = GLuint         ,
      typename FIRST_TYPE   = GLuint         ,
      typename COUNT_TYPE   = GLsizei        ,
      typename BUFFERS_TYPE = const GLuint*  ,
      typename OFFSETS_TYPE = const GLintptr*,
      typename STRIDES_TYPE = const GLsizei* >
    inline VertexArrayVertexBuffers<
      VAOBJ_TYPE  ,
      FIRST_TYPE  ,
      COUNT_TYPE  ,
      BUFFERS_TYPE,
      OFFSETS_TYPE,
      STRIDES_TYPE>* newVertexArrayVertexBuffers(
        VAOBJ_TYPE   const&vaobj  ,
        FIRST_TYPE   const&first  ,
        COUNT_TYPE   const&count  ,
        BUFFERS_TYPE const&buffers,
        OFFSETS_TYPE const&offsets,
        STRIDES_TYPE const&strides){
        return new VertexArrayVertexBuffers<
          VAOBJ_TYPE  ,
          FIRST_TYPE  ,
          COUNT_TYPE  ,
          BUFFERS_TYPE,
          OFFSETS_TYPE,
          STRIDES_TYPE>(
              vaobj  ,
              first  ,
              count  ,
              buffers,
              offsets,
              strides);
    }
    template<
      typename VAOBJ_TYPE   = GLuint         ,
      typename FIRST_TYPE   = GLuint         ,
      typename COUNT_TYPE   = GLsizei        ,
      typename BUFFERS_TYPE = const GLuint*  ,
      typename OFFSETS_TYPE = const GLintptr*,
      typename STRIDES_TYPE = const GLsizei* >
    inline std::shared_ptr<VertexArrayVertexBuffers<
      VAOBJ_TYPE  ,
      FIRST_TYPE  ,
      COUNT_TYPE  ,
      BUFFERS_TYPE,
      OFFSETS_TYPE,
      STRIDES_TYPE>> sharedVertexArrayVertexBuffers(
        VAOBJ_TYPE   const&vaobj  ,
        FIRST_TYPE   const&first  ,
        COUNT_TYPE   const&count  ,
        BUFFERS_TYPE const&buffers,
        OFFSETS_TYPE const&offsets,
        STRIDES_TYPE const&strides){
        return std::make_shared<VertexArrayVertexBuffers<
          VAOBJ_TYPE  ,
          FIRST_TYPE  ,
          COUNT_TYPE  ,
          BUFFERS_TYPE,
          OFFSETS_TYPE,
          STRIDES_TYPE>>(
              vaobj  ,
              first  ,
              count  ,
              buffers,
              offsets,
              strides);
    }

    template<
      typename UNIT_TYPE    = GLuint,
      typename SAMPLER_TYPE = GLuint>
    inline BindSampler<
      UNIT_TYPE   ,
      SAMPLER_TYPE>* newBindSampler(
        UNIT_TYPE    const&unit   ,
        SAMPLER_TYPE const&sampler){
        return new BindSampler<
          UNIT_TYPE   ,
          SAMPLER_TYPE>(
              unit   ,
              sampler);
    }
    template<
      typename UNIT_TYPE    = GLuint,
      typename SAMPLER_TYPE = GLuint>
    inline std::shared_ptr<BindSampler<
      UNIT_TYPE   ,
      SAMPLER_TYPE>> sharedBindSampler(
        UNIT_TYPE    const&unit   ,
        SAMPLER_TYPE const&sampler){
        return std::make_shared<BindSampler<
          UNIT_TYPE   ,
          SAMPLER_TYPE>>(
              unit   ,
              sampler);
    }

    template<
      typename WIDTH_TYPE = GLfloat>
    inline LineWidth<
      WIDTH_TYPE>* newLineWidth(
        WIDTH_TYPE const&width){
        return new LineWidth<
          WIDTH_TYPE>(
              width);
    }
    template<
      typename WIDTH_TYPE = GLfloat>
    inline std::shared_ptr<LineWidth<
      WIDTH_TYPE>> sharedLineWidth(
        WIDTH_TYPE const&width){
        return std::make_shared<LineWidth<
          WIDTH_TYPE>>(
              width);
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint,
      typename DATA_TYPE   = GLint*>
    inline GetIntegeri_v<
      TARGET_TYPE,
      INDEX_TYPE ,
      DATA_TYPE  >* newGetIntegeri_v(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        DATA_TYPE   const&data  ){
        return new GetIntegeri_v<
          TARGET_TYPE,
          INDEX_TYPE ,
          DATA_TYPE  >(
              target,
              index ,
              data  );
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint,
      typename DATA_TYPE   = GLint*>
    inline std::shared_ptr<GetIntegeri_v<
      TARGET_TYPE,
      INDEX_TYPE ,
      DATA_TYPE  >> sharedGetIntegeri_v(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        DATA_TYPE   const&data  ){
        return std::make_shared<GetIntegeri_v<
          TARGET_TYPE,
          INDEX_TYPE ,
          DATA_TYPE  >>(
              target,
              index ,
              data  );
    }

    template<
      typename SHADER_TYPE = GLuint>
    inline CompileShader<
      SHADER_TYPE>* newCompileShader(
        SHADER_TYPE const&shader){
        return new CompileShader<
          SHADER_TYPE>(
              shader);
    }
    template<
      typename SHADER_TYPE = GLuint>
    inline std::shared_ptr<CompileShader<
      SHADER_TYPE>> sharedCompileShader(
        SHADER_TYPE const&shader){
        return std::make_shared<CompileShader<
          SHADER_TYPE>>(
              shader);
    }

    template<
      typename PROGRAM_TYPE = GLuint  ,
      typename INDEX_TYPE   = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename SIZE_TYPE    = GLsizei*,
      typename TYPE_TYPE    = GLenum* ,
      typename NAME_TYPE    = GLchar* >
    inline GetTransformFeedbackVarying<
      PROGRAM_TYPE,
      INDEX_TYPE  ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      SIZE_TYPE   ,
      TYPE_TYPE   ,
      NAME_TYPE   >* newGetTransformFeedbackVarying(
        PROGRAM_TYPE const&program,
        INDEX_TYPE   const&index  ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        SIZE_TYPE    const&size   ,
        TYPE_TYPE    const&type   ,
        NAME_TYPE    const&name   ){
        return new GetTransformFeedbackVarying<
          PROGRAM_TYPE,
          INDEX_TYPE  ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          SIZE_TYPE   ,
          TYPE_TYPE   ,
          NAME_TYPE   >(
              program,
              index  ,
              bufSize,
              length ,
              size   ,
              type   ,
              name   );
    }
    template<
      typename PROGRAM_TYPE = GLuint  ,
      typename INDEX_TYPE   = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename SIZE_TYPE    = GLsizei*,
      typename TYPE_TYPE    = GLenum* ,
      typename NAME_TYPE    = GLchar* >
    inline std::shared_ptr<GetTransformFeedbackVarying<
      PROGRAM_TYPE,
      INDEX_TYPE  ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      SIZE_TYPE   ,
      TYPE_TYPE   ,
      NAME_TYPE   >> sharedGetTransformFeedbackVarying(
        PROGRAM_TYPE const&program,
        INDEX_TYPE   const&index  ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        SIZE_TYPE    const&size   ,
        TYPE_TYPE    const&type   ,
        NAME_TYPE    const&name   ){
        return std::make_shared<GetTransformFeedbackVarying<
          PROGRAM_TYPE,
          INDEX_TYPE  ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          SIZE_TYPE   ,
          TYPE_TYPE   ,
          NAME_TYPE   >>(
              program,
              index  ,
              bufSize,
              length ,
              size   ,
              type   ,
              name   );
    }

    template<
      typename TEXTURE_TYPE   = GLuint     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename YOFFSET_TYPE   = GLint      ,
      typename ZOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename HEIGHT_TYPE    = GLsizei    ,
      typename DEPTH_TYPE     = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    inline CompressedTextureSubImage3D<
      TEXTURE_TYPE  ,
      LEVEL_TYPE    ,
      XOFFSET_TYPE  ,
      YOFFSET_TYPE  ,
      ZOFFSET_TYPE  ,
      WIDTH_TYPE    ,
      HEIGHT_TYPE   ,
      DEPTH_TYPE    ,
      FORMAT_TYPE   ,
      IMAGESIZE_TYPE,
      DATA_TYPE     >* newCompressedTextureSubImage3D(
        TEXTURE_TYPE   const&texture  ,
        LEVEL_TYPE     const&level    ,
        XOFFSET_TYPE   const&xoffset  ,
        YOFFSET_TYPE   const&yoffset  ,
        ZOFFSET_TYPE   const&zoffset  ,
        WIDTH_TYPE     const&width    ,
        HEIGHT_TYPE    const&height   ,
        DEPTH_TYPE     const&depth    ,
        FORMAT_TYPE    const&format   ,
        IMAGESIZE_TYPE const&imageSize,
        DATA_TYPE      const&data     ){
        return new CompressedTextureSubImage3D<
          TEXTURE_TYPE  ,
          LEVEL_TYPE    ,
          XOFFSET_TYPE  ,
          YOFFSET_TYPE  ,
          ZOFFSET_TYPE  ,
          WIDTH_TYPE    ,
          HEIGHT_TYPE   ,
          DEPTH_TYPE    ,
          FORMAT_TYPE   ,
          IMAGESIZE_TYPE,
          DATA_TYPE     >(
              texture  ,
              level    ,
              xoffset  ,
              yoffset  ,
              zoffset  ,
              width    ,
              height   ,
              depth    ,
              format   ,
              imageSize,
              data     );
    }
    template<
      typename TEXTURE_TYPE   = GLuint     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename YOFFSET_TYPE   = GLint      ,
      typename ZOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename HEIGHT_TYPE    = GLsizei    ,
      typename DEPTH_TYPE     = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    inline std::shared_ptr<CompressedTextureSubImage3D<
      TEXTURE_TYPE  ,
      LEVEL_TYPE    ,
      XOFFSET_TYPE  ,
      YOFFSET_TYPE  ,
      ZOFFSET_TYPE  ,
      WIDTH_TYPE    ,
      HEIGHT_TYPE   ,
      DEPTH_TYPE    ,
      FORMAT_TYPE   ,
      IMAGESIZE_TYPE,
      DATA_TYPE     >> sharedCompressedTextureSubImage3D(
        TEXTURE_TYPE   const&texture  ,
        LEVEL_TYPE     const&level    ,
        XOFFSET_TYPE   const&xoffset  ,
        YOFFSET_TYPE   const&yoffset  ,
        ZOFFSET_TYPE   const&zoffset  ,
        WIDTH_TYPE     const&width    ,
        HEIGHT_TYPE    const&height   ,
        DEPTH_TYPE     const&depth    ,
        FORMAT_TYPE    const&format   ,
        IMAGESIZE_TYPE const&imageSize,
        DATA_TYPE      const&data     ){
        return std::make_shared<CompressedTextureSubImage3D<
          TEXTURE_TYPE  ,
          LEVEL_TYPE    ,
          XOFFSET_TYPE  ,
          YOFFSET_TYPE  ,
          ZOFFSET_TYPE  ,
          WIDTH_TYPE    ,
          HEIGHT_TYPE   ,
          DEPTH_TYPE    ,
          FORMAT_TYPE   ,
          IMAGESIZE_TYPE,
          DATA_TYPE     >>(
              texture  ,
              level    ,
              xoffset  ,
              yoffset  ,
              zoffset  ,
              width    ,
              height   ,
              depth    ,
              format   ,
              imageSize,
              data     );
    }

    template<
      typename XFB_TYPE    = GLuint    ,
      typename INDEX_TYPE  = GLuint    ,
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr>
    inline TransformFeedbackBufferRange<
      XFB_TYPE   ,
      INDEX_TYPE ,
      BUFFER_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  >* newTransformFeedbackBufferRange(
        XFB_TYPE    const&xfb   ,
        INDEX_TYPE  const&index ,
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ){
        return new TransformFeedbackBufferRange<
          XFB_TYPE   ,
          INDEX_TYPE ,
          BUFFER_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  >(
              xfb   ,
              index ,
              buffer,
              offset,
              size  );
    }
    template<
      typename XFB_TYPE    = GLuint    ,
      typename INDEX_TYPE  = GLuint    ,
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr>
    inline std::shared_ptr<TransformFeedbackBufferRange<
      XFB_TYPE   ,
      INDEX_TYPE ,
      BUFFER_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  >> sharedTransformFeedbackBufferRange(
        XFB_TYPE    const&xfb   ,
        INDEX_TYPE  const&index ,
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ){
        return std::make_shared<TransformFeedbackBufferRange<
          XFB_TYPE   ,
          INDEX_TYPE ,
          BUFFER_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  >>(
              xfb   ,
              index ,
              buffer,
              offset,
              size  );
    }

    template<
      typename N_TYPE = GLfloat,
      typename F_TYPE = GLfloat>
    inline DepthRangef<
      N_TYPE,
      F_TYPE>* newDepthRangef(
        N_TYPE const&n,
        F_TYPE const&f){
        return new DepthRangef<
          N_TYPE,
          F_TYPE>(
              n,
              f);
    }
    template<
      typename N_TYPE = GLfloat,
      typename F_TYPE = GLfloat>
    inline std::shared_ptr<DepthRangef<
      N_TYPE,
      F_TYPE>> sharedDepthRangef(
        N_TYPE const&n,
        F_TYPE const&f){
        return std::make_shared<DepthRangef<
          N_TYPE,
          F_TYPE>>(
              n,
              f);
    }

    template<
      typename INDEX_TYPE   = GLuint     ,
      typename SIZE_TYPE    = GLint      ,
      typename TYPE_TYPE    = GLenum     ,
      typename STRIDE_TYPE  = GLsizei    ,
      typename POINTER_TYPE = const void*>
    inline VertexAttribIPointer<
      INDEX_TYPE  ,
      SIZE_TYPE   ,
      TYPE_TYPE   ,
      STRIDE_TYPE ,
      POINTER_TYPE>* newVertexAttribIPointer(
        INDEX_TYPE   const&index  ,
        SIZE_TYPE    const&size   ,
        TYPE_TYPE    const&type   ,
        STRIDE_TYPE  const&stride ,
        POINTER_TYPE const&pointer){
        return new VertexAttribIPointer<
          INDEX_TYPE  ,
          SIZE_TYPE   ,
          TYPE_TYPE   ,
          STRIDE_TYPE ,
          POINTER_TYPE>(
              index  ,
              size   ,
              type   ,
              stride ,
              pointer);
    }
    template<
      typename INDEX_TYPE   = GLuint     ,
      typename SIZE_TYPE    = GLint      ,
      typename TYPE_TYPE    = GLenum     ,
      typename STRIDE_TYPE  = GLsizei    ,
      typename POINTER_TYPE = const void*>
    inline std::shared_ptr<VertexAttribIPointer<
      INDEX_TYPE  ,
      SIZE_TYPE   ,
      TYPE_TYPE   ,
      STRIDE_TYPE ,
      POINTER_TYPE>> sharedVertexAttribIPointer(
        INDEX_TYPE   const&index  ,
        SIZE_TYPE    const&size   ,
        TYPE_TYPE    const&type   ,
        STRIDE_TYPE  const&stride ,
        POINTER_TYPE const&pointer){
        return std::make_shared<VertexAttribIPointer<
          INDEX_TYPE  ,
          SIZE_TYPE   ,
          TYPE_TYPE   ,
          STRIDE_TYPE ,
          POINTER_TYPE>>(
              index  ,
              size   ,
              type   ,
              stride ,
              pointer);
    }

    template<
      typename BUFFER_TYPE = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetNamedBufferParameteriv<
      BUFFER_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetNamedBufferParameteriv(
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetNamedBufferParameteriv<
          BUFFER_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              buffer,
              pname ,
              params);
    }
    template<
      typename BUFFER_TYPE = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetNamedBufferParameteriv<
      BUFFER_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetNamedBufferParameteriv(
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetNamedBufferParameteriv<
          BUFFER_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              buffer,
              pname ,
              params);
    }

    template<
      typename MODE_TYPE          = GLenum     ,
      typename COUNT_TYPE         = GLsizei    ,
      typename TYPE_TYPE          = GLenum     ,
      typename INDICES_TYPE       = const void*,
      typename INSTANCECOUNT_TYPE = GLsizei    ,
      typename BASEINSTANCE_TYPE  = GLuint     >
    inline DrawElementsInstancedBaseInstance<
      MODE_TYPE         ,
      COUNT_TYPE        ,
      TYPE_TYPE         ,
      INDICES_TYPE      ,
      INSTANCECOUNT_TYPE,
      BASEINSTANCE_TYPE >* newDrawElementsInstancedBaseInstance(
        MODE_TYPE          const&mode         ,
        COUNT_TYPE         const&count        ,
        TYPE_TYPE          const&type         ,
        INDICES_TYPE       const&indices      ,
        INSTANCECOUNT_TYPE const&instancecount,
        BASEINSTANCE_TYPE  const&baseinstance ){
        return new DrawElementsInstancedBaseInstance<
          MODE_TYPE         ,
          COUNT_TYPE        ,
          TYPE_TYPE         ,
          INDICES_TYPE      ,
          INSTANCECOUNT_TYPE,
          BASEINSTANCE_TYPE >(
              mode         ,
              count        ,
              type         ,
              indices      ,
              instancecount,
              baseinstance );
    }
    template<
      typename MODE_TYPE          = GLenum     ,
      typename COUNT_TYPE         = GLsizei    ,
      typename TYPE_TYPE          = GLenum     ,
      typename INDICES_TYPE       = const void*,
      typename INSTANCECOUNT_TYPE = GLsizei    ,
      typename BASEINSTANCE_TYPE  = GLuint     >
    inline std::shared_ptr<DrawElementsInstancedBaseInstance<
      MODE_TYPE         ,
      COUNT_TYPE        ,
      TYPE_TYPE         ,
      INDICES_TYPE      ,
      INSTANCECOUNT_TYPE,
      BASEINSTANCE_TYPE >> sharedDrawElementsInstancedBaseInstance(
        MODE_TYPE          const&mode         ,
        COUNT_TYPE         const&count        ,
        TYPE_TYPE          const&type         ,
        INDICES_TYPE       const&indices      ,
        INSTANCECOUNT_TYPE const&instancecount,
        BASEINSTANCE_TYPE  const&baseinstance ){
        return std::make_shared<DrawElementsInstancedBaseInstance<
          MODE_TYPE         ,
          COUNT_TYPE        ,
          TYPE_TYPE         ,
          INDICES_TYPE      ,
          INSTANCECOUNT_TYPE,
          BASEINSTANCE_TYPE >>(
              mode         ,
              count        ,
              type         ,
              indices      ,
              instancecount,
              baseinstance );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint>
    inline Enablei<
      TARGET_TYPE,
      INDEX_TYPE >* newEnablei(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ){
        return new Enablei<
          TARGET_TYPE,
          INDEX_TYPE >(
              target,
              index );
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint>
    inline std::shared_ptr<Enablei<
      TARGET_TYPE,
      INDEX_TYPE >> sharedEnablei(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ){
        return std::make_shared<Enablei<
          TARGET_TYPE,
          INDEX_TYPE >>(
              target,
              index );
    }

    template<
      typename INDEX_TYPE      = GLuint   ,
      typename TYPE_TYPE       = GLenum   ,
      typename NORMALIZED_TYPE = GLboolean,
      typename VALUE_TYPE      = GLuint   >
    inline VertexAttribP4ui<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >* newVertexAttribP4ui(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return new VertexAttribP4ui<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >(
              index     ,
              type      ,
              normalized,
              value     );
    }
    template<
      typename INDEX_TYPE      = GLuint   ,
      typename TYPE_TYPE       = GLenum   ,
      typename NORMALIZED_TYPE = GLboolean,
      typename VALUE_TYPE      = GLuint   >
    inline std::shared_ptr<VertexAttribP4ui<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >> sharedVertexAttribP4ui(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return std::make_shared<VertexAttribP4ui<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >>(
              index     ,
              type      ,
              normalized,
              value     );
    }

    template<
      typename RET_TYPE  = GLuint,
      typename TYPE_TYPE = GLenum>
    inline CreateShader<
      RET_TYPE ,
      TYPE_TYPE>* newCreateShader(
        RET_TYPE  const&ret ,
        TYPE_TYPE const&type){
        return new CreateShader<
          RET_TYPE ,
          TYPE_TYPE>(
              ret ,
              type);
    }
    template<
      typename RET_TYPE  = GLuint,
      typename TYPE_TYPE = GLenum>
    inline std::shared_ptr<CreateShader<
      RET_TYPE ,
      TYPE_TYPE>> sharedCreateShader(
        RET_TYPE  const&ret ,
        TYPE_TYPE const&type){
        return std::make_shared<CreateShader<
          RET_TYPE ,
          TYPE_TYPE>>(
              ret ,
              type);
    }

    template<
      typename RET_TYPE    = GLboolean,
      typename BUFFER_TYPE = GLuint   >
    inline IsBuffer<
      RET_TYPE   ,
      BUFFER_TYPE>* newIsBuffer(
        RET_TYPE    const&ret   ,
        BUFFER_TYPE const&buffer){
        return new IsBuffer<
          RET_TYPE   ,
          BUFFER_TYPE>(
              ret   ,
              buffer);
    }
    template<
      typename RET_TYPE    = GLboolean,
      typename BUFFER_TYPE = GLuint   >
    inline std::shared_ptr<IsBuffer<
      RET_TYPE   ,
      BUFFER_TYPE>> sharedIsBuffer(
        RET_TYPE    const&ret   ,
        BUFFER_TYPE const&buffer){
        return std::make_shared<IsBuffer<
          RET_TYPE   ,
          BUFFER_TYPE>>(
              ret   ,
              buffer);
    }

    template<
      typename PNAME_TYPE = GLenum  ,
      typename INDEX_TYPE = GLuint  ,
      typename VAL_TYPE   = GLfloat*>
    inline GetMultisamplefv<
      PNAME_TYPE,
      INDEX_TYPE,
      VAL_TYPE  >* newGetMultisamplefv(
        PNAME_TYPE const&pname,
        INDEX_TYPE const&index,
        VAL_TYPE   const&val  ){
        return new GetMultisamplefv<
          PNAME_TYPE,
          INDEX_TYPE,
          VAL_TYPE  >(
              pname,
              index,
              val  );
    }
    template<
      typename PNAME_TYPE = GLenum  ,
      typename INDEX_TYPE = GLuint  ,
      typename VAL_TYPE   = GLfloat*>
    inline std::shared_ptr<GetMultisamplefv<
      PNAME_TYPE,
      INDEX_TYPE,
      VAL_TYPE  >> sharedGetMultisamplefv(
        PNAME_TYPE const&pname,
        INDEX_TYPE const&index,
        VAL_TYPE   const&val  ){
        return std::make_shared<GetMultisamplefv<
          PNAME_TYPE,
          INDEX_TYPE,
          VAL_TYPE  >>(
              pname,
              index,
              val  );
    }

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline ProgramUniformMatrix2dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix2dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix2dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<ProgramUniformMatrix2dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix2dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix2dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename N_TYPE             = GLsizei,
      typename RENDERBUFFERS_TYPE = GLuint*>
    inline GenRenderbuffers<
      N_TYPE            ,
      RENDERBUFFERS_TYPE>* newGenRenderbuffers(
        N_TYPE             const&n            ,
        RENDERBUFFERS_TYPE const&renderbuffers){
        return new GenRenderbuffers<
          N_TYPE            ,
          RENDERBUFFERS_TYPE>(
              n            ,
              renderbuffers);
    }
    template<
      typename N_TYPE             = GLsizei,
      typename RENDERBUFFERS_TYPE = GLuint*>
    inline std::shared_ptr<GenRenderbuffers<
      N_TYPE            ,
      RENDERBUFFERS_TYPE>> sharedGenRenderbuffers(
        N_TYPE             const&n            ,
        RENDERBUFFERS_TYPE const&renderbuffers){
        return std::make_shared<GenRenderbuffers<
          N_TYPE            ,
          RENDERBUFFERS_TYPE>>(
              n            ,
              renderbuffers);
    }

    template<
      typename TARGET_TYPE  = GLenum ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei>
    inline CopyTexSubImage2D<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  ,
      HEIGHT_TYPE >* newCopyTexSubImage2D(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ){
        return new CopyTexSubImage2D<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  ,
          HEIGHT_TYPE >(
              target ,
              level  ,
              xoffset,
              yoffset,
              x      ,
              y      ,
              width  ,
              height );
    }
    template<
      typename TARGET_TYPE  = GLenum ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei>
    inline std::shared_ptr<CopyTexSubImage2D<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  ,
      HEIGHT_TYPE >> sharedCopyTexSubImage2D(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ){
        return std::make_shared<CopyTexSubImage2D<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  ,
          HEIGHT_TYPE >>(
              target ,
              level  ,
              xoffset,
              yoffset,
              x      ,
              y      ,
              width  ,
              height );
    }

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble>
    inline VertexAttrib1d<
      INDEX_TYPE,
      X_TYPE    >* newVertexAttrib1d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ){
        return new VertexAttrib1d<
          INDEX_TYPE,
          X_TYPE    >(
              index,
              x    );
    }
    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble>
    inline std::shared_ptr<VertexAttrib1d<
      INDEX_TYPE,
      X_TYPE    >> sharedVertexAttrib1d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ){
        return std::make_shared<VertexAttrib1d<
          INDEX_TYPE,
          X_TYPE    >>(
              index,
              x    );
    }

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat>
    inline VertexAttrib1f<
      INDEX_TYPE,
      X_TYPE    >* newVertexAttrib1f(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ){
        return new VertexAttrib1f<
          INDEX_TYPE,
          X_TYPE    >(
              index,
              x    );
    }
    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat>
    inline std::shared_ptr<VertexAttrib1f<
      INDEX_TYPE,
      X_TYPE    >> sharedVertexAttrib1f(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ){
        return std::make_shared<VertexAttrib1f<
          INDEX_TYPE,
          X_TYPE    >>(
              index,
              x    );
    }

    template<
      typename SFACTORRGB_TYPE   = GLenum,
      typename DFACTORRGB_TYPE   = GLenum,
      typename SFACTORALPHA_TYPE = GLenum,
      typename DFACTORALPHA_TYPE = GLenum>
    inline BlendFuncSeparate<
      SFACTORRGB_TYPE  ,
      DFACTORRGB_TYPE  ,
      SFACTORALPHA_TYPE,
      DFACTORALPHA_TYPE>* newBlendFuncSeparate(
        SFACTORRGB_TYPE   const&sfactorRGB  ,
        DFACTORRGB_TYPE   const&dfactorRGB  ,
        SFACTORALPHA_TYPE const&sfactorAlpha,
        DFACTORALPHA_TYPE const&dfactorAlpha){
        return new BlendFuncSeparate<
          SFACTORRGB_TYPE  ,
          DFACTORRGB_TYPE  ,
          SFACTORALPHA_TYPE,
          DFACTORALPHA_TYPE>(
              sfactorRGB  ,
              dfactorRGB  ,
              sfactorAlpha,
              dfactorAlpha);
    }
    template<
      typename SFACTORRGB_TYPE   = GLenum,
      typename DFACTORRGB_TYPE   = GLenum,
      typename SFACTORALPHA_TYPE = GLenum,
      typename DFACTORALPHA_TYPE = GLenum>
    inline std::shared_ptr<BlendFuncSeparate<
      SFACTORRGB_TYPE  ,
      DFACTORRGB_TYPE  ,
      SFACTORALPHA_TYPE,
      DFACTORALPHA_TYPE>> sharedBlendFuncSeparate(
        SFACTORRGB_TYPE   const&sfactorRGB  ,
        DFACTORRGB_TYPE   const&dfactorRGB  ,
        SFACTORALPHA_TYPE const&sfactorAlpha,
        DFACTORALPHA_TYPE const&dfactorAlpha){
        return std::make_shared<BlendFuncSeparate<
          SFACTORRGB_TYPE  ,
          DFACTORRGB_TYPE  ,
          SFACTORALPHA_TYPE,
          DFACTORALPHA_TYPE>>(
              sfactorRGB  ,
              dfactorRGB  ,
              sfactorAlpha,
              dfactorAlpha);
    }

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline ProgramUniformMatrix4fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix4fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix4fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<ProgramUniformMatrix4fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix4fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix4fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename FRAMEBUFFER_TYPE = GLuint       ,
      typename BUFFER_TYPE      = GLenum       ,
      typename DEPTH_TYPE       = const GLfloat,
      typename STENCIL_TYPE     = GLint        >
    inline ClearNamedFramebufferfi<
      FRAMEBUFFER_TYPE,
      BUFFER_TYPE     ,
      DEPTH_TYPE      ,
      STENCIL_TYPE    >* newClearNamedFramebufferfi(
        FRAMEBUFFER_TYPE const&framebuffer,
        BUFFER_TYPE      const&buffer     ,
        DEPTH_TYPE       const&depth      ,
        STENCIL_TYPE     const&stencil    ){
        return new ClearNamedFramebufferfi<
          FRAMEBUFFER_TYPE,
          BUFFER_TYPE     ,
          DEPTH_TYPE      ,
          STENCIL_TYPE    >(
              framebuffer,
              buffer     ,
              depth      ,
              stencil    );
    }
    template<
      typename FRAMEBUFFER_TYPE = GLuint       ,
      typename BUFFER_TYPE      = GLenum       ,
      typename DEPTH_TYPE       = const GLfloat,
      typename STENCIL_TYPE     = GLint        >
    inline std::shared_ptr<ClearNamedFramebufferfi<
      FRAMEBUFFER_TYPE,
      BUFFER_TYPE     ,
      DEPTH_TYPE      ,
      STENCIL_TYPE    >> sharedClearNamedFramebufferfi(
        FRAMEBUFFER_TYPE const&framebuffer,
        BUFFER_TYPE      const&buffer     ,
        DEPTH_TYPE       const&depth      ,
        STENCIL_TYPE     const&stencil    ){
        return std::make_shared<ClearNamedFramebufferfi<
          FRAMEBUFFER_TYPE,
          BUFFER_TYPE     ,
          DEPTH_TYPE      ,
          STENCIL_TYPE    >>(
              framebuffer,
              buffer     ,
              depth      ,
              stencil    );
    }

    template<
      typename ID_TYPE     = GLuint  ,
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename OFFSET_TYPE = GLintptr>
    inline GetQueryBufferObjectuiv<
      ID_TYPE    ,
      BUFFER_TYPE,
      PNAME_TYPE ,
      OFFSET_TYPE>* newGetQueryBufferObjectuiv(
        ID_TYPE     const&id    ,
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        OFFSET_TYPE const&offset){
        return new GetQueryBufferObjectuiv<
          ID_TYPE    ,
          BUFFER_TYPE,
          PNAME_TYPE ,
          OFFSET_TYPE>(
              id    ,
              buffer,
              pname ,
              offset);
    }
    template<
      typename ID_TYPE     = GLuint  ,
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename OFFSET_TYPE = GLintptr>
    inline std::shared_ptr<GetQueryBufferObjectuiv<
      ID_TYPE    ,
      BUFFER_TYPE,
      PNAME_TYPE ,
      OFFSET_TYPE>> sharedGetQueryBufferObjectuiv(
        ID_TYPE     const&id    ,
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        OFFSET_TYPE const&offset){
        return std::make_shared<GetQueryBufferObjectuiv<
          ID_TYPE    ,
          BUFFER_TYPE,
          PNAME_TYPE ,
          OFFSET_TYPE>>(
              id    ,
              buffer,
              pname ,
              offset);
    }

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLshort,
      typename Y_TYPE     = GLshort>
    inline VertexAttrib2s<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    >* newVertexAttrib2s(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ){
        return new VertexAttrib2s<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    >(
              index,
              x    ,
              y    );
    }
    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLshort,
      typename Y_TYPE     = GLshort>
    inline std::shared_ptr<VertexAttrib2s<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    >> sharedVertexAttrib2s(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ){
        return std::make_shared<VertexAttrib2s<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    >>(
              index,
              x    ,
              y    );
    }

    template<
      typename FRAMEBUFFER_TYPE = GLuint        ,
      typename BUFFER_TYPE      = GLenum        ,
      typename DRAWBUFFER_TYPE  = GLint         ,
      typename VALUE_TYPE       = const GLfloat*>
    inline ClearNamedFramebufferfv<
      FRAMEBUFFER_TYPE,
      BUFFER_TYPE     ,
      DRAWBUFFER_TYPE ,
      VALUE_TYPE      >* newClearNamedFramebufferfv(
        FRAMEBUFFER_TYPE const&framebuffer,
        BUFFER_TYPE      const&buffer     ,
        DRAWBUFFER_TYPE  const&drawbuffer ,
        VALUE_TYPE       const&value      ){
        return new ClearNamedFramebufferfv<
          FRAMEBUFFER_TYPE,
          BUFFER_TYPE     ,
          DRAWBUFFER_TYPE ,
          VALUE_TYPE      >(
              framebuffer,
              buffer     ,
              drawbuffer ,
              value      );
    }
    template<
      typename FRAMEBUFFER_TYPE = GLuint        ,
      typename BUFFER_TYPE      = GLenum        ,
      typename DRAWBUFFER_TYPE  = GLint         ,
      typename VALUE_TYPE       = const GLfloat*>
    inline std::shared_ptr<ClearNamedFramebufferfv<
      FRAMEBUFFER_TYPE,
      BUFFER_TYPE     ,
      DRAWBUFFER_TYPE ,
      VALUE_TYPE      >> sharedClearNamedFramebufferfv(
        FRAMEBUFFER_TYPE const&framebuffer,
        BUFFER_TYPE      const&buffer     ,
        DRAWBUFFER_TYPE  const&drawbuffer ,
        VALUE_TYPE       const&value      ){
        return std::make_shared<ClearNamedFramebufferfv<
          FRAMEBUFFER_TYPE,
          BUFFER_TYPE     ,
          DRAWBUFFER_TYPE ,
          VALUE_TYPE      >>(
              framebuffer,
              buffer     ,
              drawbuffer ,
              value      );
    }

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLshort>
    inline VertexAttrib1s<
      INDEX_TYPE,
      X_TYPE    >* newVertexAttrib1s(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ){
        return new VertexAttrib1s<
          INDEX_TYPE,
          X_TYPE    >(
              index,
              x    );
    }
    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLshort>
    inline std::shared_ptr<VertexAttrib1s<
      INDEX_TYPE,
      X_TYPE    >> sharedVertexAttrib1s(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ){
        return std::make_shared<VertexAttrib1s<
          INDEX_TYPE,
          X_TYPE    >>(
              index,
              x    );
    }

    template<
      typename MASKNUMBER_TYPE = GLuint    ,
      typename MASK_TYPE       = GLbitfield>
    inline SampleMaski<
      MASKNUMBER_TYPE,
      MASK_TYPE      >* newSampleMaski(
        MASKNUMBER_TYPE const&maskNumber,
        MASK_TYPE       const&mask      ){
        return new SampleMaski<
          MASKNUMBER_TYPE,
          MASK_TYPE      >(
              maskNumber,
              mask      );
    }
    template<
      typename MASKNUMBER_TYPE = GLuint    ,
      typename MASK_TYPE       = GLbitfield>
    inline std::shared_ptr<SampleMaski<
      MASKNUMBER_TYPE,
      MASK_TYPE      >> sharedSampleMaski(
        MASKNUMBER_TYPE const&maskNumber,
        MASK_TYPE       const&mask      ){
        return std::make_shared<SampleMaski<
          MASKNUMBER_TYPE,
          MASK_TYPE      >>(
              maskNumber,
              mask      );
    }

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline UniformMatrix3x2fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix3x2fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix3x2fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<UniformMatrix3x2fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix3x2fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix3x2fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename SOURCE_TYPE   = GLenum       ,
      typename TYPE_TYPE     = GLenum       ,
      typename SEVERITY_TYPE = GLenum       ,
      typename COUNT_TYPE    = GLsizei      ,
      typename IDS_TYPE      = const GLuint*,
      typename ENABLED_TYPE  = GLboolean    >
    inline DebugMessageControl<
      SOURCE_TYPE  ,
      TYPE_TYPE    ,
      SEVERITY_TYPE,
      COUNT_TYPE   ,
      IDS_TYPE     ,
      ENABLED_TYPE >* newDebugMessageControl(
        SOURCE_TYPE   const&source  ,
        TYPE_TYPE     const&type    ,
        SEVERITY_TYPE const&severity,
        COUNT_TYPE    const&count   ,
        IDS_TYPE      const&ids     ,
        ENABLED_TYPE  const&enabled ){
        return new DebugMessageControl<
          SOURCE_TYPE  ,
          TYPE_TYPE    ,
          SEVERITY_TYPE,
          COUNT_TYPE   ,
          IDS_TYPE     ,
          ENABLED_TYPE >(
              source  ,
              type    ,
              severity,
              count   ,
              ids     ,
              enabled );
    }
    template<
      typename SOURCE_TYPE   = GLenum       ,
      typename TYPE_TYPE     = GLenum       ,
      typename SEVERITY_TYPE = GLenum       ,
      typename COUNT_TYPE    = GLsizei      ,
      typename IDS_TYPE      = const GLuint*,
      typename ENABLED_TYPE  = GLboolean    >
    inline std::shared_ptr<DebugMessageControl<
      SOURCE_TYPE  ,
      TYPE_TYPE    ,
      SEVERITY_TYPE,
      COUNT_TYPE   ,
      IDS_TYPE     ,
      ENABLED_TYPE >> sharedDebugMessageControl(
        SOURCE_TYPE   const&source  ,
        TYPE_TYPE     const&type    ,
        SEVERITY_TYPE const&severity,
        COUNT_TYPE    const&count   ,
        IDS_TYPE      const&ids     ,
        ENABLED_TYPE  const&enabled ){
        return std::make_shared<DebugMessageControl<
          SOURCE_TYPE  ,
          TYPE_TYPE    ,
          SEVERITY_TYPE,
          COUNT_TYPE   ,
          IDS_TYPE     ,
          ENABLED_TYPE >>(
              source  ,
              type    ,
              severity,
              count   ,
              ids     ,
              enabled );
    }

    template<
      typename SIZE_TYPE = GLfloat>
    inline PointSize<
      SIZE_TYPE>* newPointSize(
        SIZE_TYPE const&size){
        return new PointSize<
          SIZE_TYPE>(
              size);
    }
    template<
      typename SIZE_TYPE = GLfloat>
    inline std::shared_ptr<PointSize<
      SIZE_TYPE>> sharedPointSize(
        SIZE_TYPE const&size){
        return std::make_shared<PointSize<
          SIZE_TYPE>>(
              size);
    }

    template<
      typename UNIT_TYPE    = GLuint,
      typename TEXTURE_TYPE = GLuint>
    inline BindTextureUnit<
      UNIT_TYPE   ,
      TEXTURE_TYPE>* newBindTextureUnit(
        UNIT_TYPE    const&unit   ,
        TEXTURE_TYPE const&texture){
        return new BindTextureUnit<
          UNIT_TYPE   ,
          TEXTURE_TYPE>(
              unit   ,
              texture);
    }
    template<
      typename UNIT_TYPE    = GLuint,
      typename TEXTURE_TYPE = GLuint>
    inline std::shared_ptr<BindTextureUnit<
      UNIT_TYPE   ,
      TEXTURE_TYPE>> sharedBindTextureUnit(
        UNIT_TYPE    const&unit   ,
        TEXTURE_TYPE const&texture){
        return std::make_shared<BindTextureUnit<
          UNIT_TYPE   ,
          TEXTURE_TYPE>>(
              unit   ,
              texture);
    }

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline VertexAttrib2dv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib2dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib2dv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline std::shared_ptr<VertexAttrib2dv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib2dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib2dv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename ID_TYPE     = GLuint  ,
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename OFFSET_TYPE = GLintptr>
    inline GetQueryBufferObjectiv<
      ID_TYPE    ,
      BUFFER_TYPE,
      PNAME_TYPE ,
      OFFSET_TYPE>* newGetQueryBufferObjectiv(
        ID_TYPE     const&id    ,
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        OFFSET_TYPE const&offset){
        return new GetQueryBufferObjectiv<
          ID_TYPE    ,
          BUFFER_TYPE,
          PNAME_TYPE ,
          OFFSET_TYPE>(
              id    ,
              buffer,
              pname ,
              offset);
    }
    template<
      typename ID_TYPE     = GLuint  ,
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename OFFSET_TYPE = GLintptr>
    inline std::shared_ptr<GetQueryBufferObjectiv<
      ID_TYPE    ,
      BUFFER_TYPE,
      PNAME_TYPE ,
      OFFSET_TYPE>> sharedGetQueryBufferObjectiv(
        ID_TYPE     const&id    ,
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        OFFSET_TYPE const&offset){
        return std::make_shared<GetQueryBufferObjectiv<
          ID_TYPE    ,
          BUFFER_TYPE,
          PNAME_TYPE ,
          OFFSET_TYPE>>(
              id    ,
              buffer,
              pname ,
              offset);
    }

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    inline VertexAttrib4Nuiv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4Nuiv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4Nuiv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    inline std::shared_ptr<VertexAttrib4Nuiv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4Nuiv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4Nuiv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    inline TexStorage2D<
      TARGET_TYPE        ,
      LEVELS_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >* newTexStorage2D(
        TARGET_TYPE         const&target        ,
        LEVELS_TYPE         const&levels        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return new TexStorage2D<
          TARGET_TYPE        ,
          LEVELS_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >(
              target        ,
              levels        ,
              internalformat,
              width         ,
              height        );
    }
    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    inline std::shared_ptr<TexStorage2D<
      TARGET_TYPE        ,
      LEVELS_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >> sharedTexStorage2D(
        TARGET_TYPE         const&target        ,
        LEVELS_TYPE         const&levels        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return std::make_shared<TexStorage2D<
          TARGET_TYPE        ,
          LEVELS_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >>(
              target        ,
              levels        ,
              internalformat,
              width         ,
              height        );
    }

    template<
      typename TARGET_TYPE         = GLenum ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    inline RenderbufferStorage<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >* newRenderbufferStorage(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return new RenderbufferStorage<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >(
              target        ,
              internalformat,
              width         ,
              height        );
    }
    template<
      typename TARGET_TYPE         = GLenum ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    inline std::shared_ptr<RenderbufferStorage<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >> sharedRenderbufferStorage(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return std::make_shared<RenderbufferStorage<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >>(
              target        ,
              internalformat,
              width         ,
              height        );
    }

    template<
      typename SYNC_TYPE    = GLsync    ,
      typename FLAGS_TYPE   = GLbitfield,
      typename TIMEOUT_TYPE = GLuint64  >
    inline WaitSync<
      SYNC_TYPE   ,
      FLAGS_TYPE  ,
      TIMEOUT_TYPE>* newWaitSync(
        SYNC_TYPE    const&sync   ,
        FLAGS_TYPE   const&flags  ,
        TIMEOUT_TYPE const&timeout){
        return new WaitSync<
          SYNC_TYPE   ,
          FLAGS_TYPE  ,
          TIMEOUT_TYPE>(
              sync   ,
              flags  ,
              timeout);
    }
    template<
      typename SYNC_TYPE    = GLsync    ,
      typename FLAGS_TYPE   = GLbitfield,
      typename TIMEOUT_TYPE = GLuint64  >
    inline std::shared_ptr<WaitSync<
      SYNC_TYPE   ,
      FLAGS_TYPE  ,
      TIMEOUT_TYPE>> sharedWaitSync(
        SYNC_TYPE    const&sync   ,
        FLAGS_TYPE   const&flags  ,
        TIMEOUT_TYPE const&timeout){
        return std::make_shared<WaitSync<
          SYNC_TYPE   ,
          FLAGS_TYPE  ,
          TIMEOUT_TYPE>>(
              sync   ,
              flags  ,
              timeout);
    }

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline UniformMatrix4x3fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix4x3fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix4x3fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<UniformMatrix4x3fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix4x3fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix4x3fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename LOCATION_TYPE = GLint,
      typename V0_TYPE       = GLint,
      typename V1_TYPE       = GLint,
      typename V2_TYPE       = GLint>
    inline Uniform3i<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >* newUniform3i(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return new Uniform3i<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >(
              location,
              v0      ,
              v1      ,
              v2      );
    }
    template<
      typename LOCATION_TYPE = GLint,
      typename V0_TYPE       = GLint,
      typename V1_TYPE       = GLint,
      typename V2_TYPE       = GLint>
    inline std::shared_ptr<Uniform3i<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >> sharedUniform3i(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return std::make_shared<Uniform3i<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >>(
              location,
              v0      ,
              v1      ,
              v2      );
    }

    template<
      typename IDENTIFIER_TYPE = GLenum  ,
      typename NAME_TYPE       = GLuint  ,
      typename BUFSIZE_TYPE    = GLsizei ,
      typename LENGTH_TYPE     = GLsizei*,
      typename LABEL_TYPE      = GLchar* >
    inline GetObjectLabel<
      IDENTIFIER_TYPE,
      NAME_TYPE      ,
      BUFSIZE_TYPE   ,
      LENGTH_TYPE    ,
      LABEL_TYPE     >* newGetObjectLabel(
        IDENTIFIER_TYPE const&identifier,
        NAME_TYPE       const&name      ,
        BUFSIZE_TYPE    const&bufSize   ,
        LENGTH_TYPE     const&length    ,
        LABEL_TYPE      const&label     ){
        return new GetObjectLabel<
          IDENTIFIER_TYPE,
          NAME_TYPE      ,
          BUFSIZE_TYPE   ,
          LENGTH_TYPE    ,
          LABEL_TYPE     >(
              identifier,
              name      ,
              bufSize   ,
              length    ,
              label     );
    }
    template<
      typename IDENTIFIER_TYPE = GLenum  ,
      typename NAME_TYPE       = GLuint  ,
      typename BUFSIZE_TYPE    = GLsizei ,
      typename LENGTH_TYPE     = GLsizei*,
      typename LABEL_TYPE      = GLchar* >
    inline std::shared_ptr<GetObjectLabel<
      IDENTIFIER_TYPE,
      NAME_TYPE      ,
      BUFSIZE_TYPE   ,
      LENGTH_TYPE    ,
      LABEL_TYPE     >> sharedGetObjectLabel(
        IDENTIFIER_TYPE const&identifier,
        NAME_TYPE       const&name      ,
        BUFSIZE_TYPE    const&bufSize   ,
        LENGTH_TYPE     const&length    ,
        LABEL_TYPE      const&label     ){
        return std::make_shared<GetObjectLabel<
          IDENTIFIER_TYPE,
          NAME_TYPE      ,
          BUFSIZE_TYPE   ,
          LENGTH_TYPE    ,
          LABEL_TYPE     >>(
              identifier,
              name      ,
              bufSize   ,
              length    ,
              label     );
    }

    template<
      typename COUNT_TYPE    = GLsizei      ,
      typename SAMPLERS_TYPE = const GLuint*>
    inline DeleteSamplers<
      COUNT_TYPE   ,
      SAMPLERS_TYPE>* newDeleteSamplers(
        COUNT_TYPE    const&count   ,
        SAMPLERS_TYPE const&samplers){
        return new DeleteSamplers<
          COUNT_TYPE   ,
          SAMPLERS_TYPE>(
              count   ,
              samplers);
    }
    template<
      typename COUNT_TYPE    = GLsizei      ,
      typename SAMPLERS_TYPE = const GLuint*>
    inline std::shared_ptr<DeleteSamplers<
      COUNT_TYPE   ,
      SAMPLERS_TYPE>> sharedDeleteSamplers(
        COUNT_TYPE    const&count   ,
        SAMPLERS_TYPE const&samplers){
        return std::make_shared<DeleteSamplers<
          COUNT_TYPE   ,
          SAMPLERS_TYPE>>(
              count   ,
              samplers);
    }

    template<
      typename BUF_TYPE       = GLuint,
      typename MODERGB_TYPE   = GLenum,
      typename MODEALPHA_TYPE = GLenum>
    inline BlendEquationSeparatei<
      BUF_TYPE      ,
      MODERGB_TYPE  ,
      MODEALPHA_TYPE>* newBlendEquationSeparatei(
        BUF_TYPE       const&buf      ,
        MODERGB_TYPE   const&modeRGB  ,
        MODEALPHA_TYPE const&modeAlpha){
        return new BlendEquationSeparatei<
          BUF_TYPE      ,
          MODERGB_TYPE  ,
          MODEALPHA_TYPE>(
              buf      ,
              modeRGB  ,
              modeAlpha);
    }
    template<
      typename BUF_TYPE       = GLuint,
      typename MODERGB_TYPE   = GLenum,
      typename MODEALPHA_TYPE = GLenum>
    inline std::shared_ptr<BlendEquationSeparatei<
      BUF_TYPE      ,
      MODERGB_TYPE  ,
      MODEALPHA_TYPE>> sharedBlendEquationSeparatei(
        BUF_TYPE       const&buf      ,
        MODERGB_TYPE   const&modeRGB  ,
        MODEALPHA_TYPE const&modeAlpha){
        return std::make_shared<BlendEquationSeparatei<
          BUF_TYPE      ,
          MODERGB_TYPE  ,
          MODEALPHA_TYPE>>(
              buf      ,
              modeRGB  ,
              modeAlpha);
    }


    template<
      typename LOCATION_TYPE = GLint   ,
      typename X_TYPE        = GLdouble,
      typename Y_TYPE        = GLdouble,
      typename Z_TYPE        = GLdouble>
    inline Uniform3d<
      LOCATION_TYPE,
      X_TYPE       ,
      Y_TYPE       ,
      Z_TYPE       >* newUniform3d(
        LOCATION_TYPE const&location,
        X_TYPE        const&x       ,
        Y_TYPE        const&y       ,
        Z_TYPE        const&z       ){
        return new Uniform3d<
          LOCATION_TYPE,
          X_TYPE       ,
          Y_TYPE       ,
          Z_TYPE       >(
              location,
              x       ,
              y       ,
              z       );
    }
    template<
      typename LOCATION_TYPE = GLint   ,
      typename X_TYPE        = GLdouble,
      typename Y_TYPE        = GLdouble,
      typename Z_TYPE        = GLdouble>
    inline std::shared_ptr<Uniform3d<
      LOCATION_TYPE,
      X_TYPE       ,
      Y_TYPE       ,
      Z_TYPE       >> sharedUniform3d(
        LOCATION_TYPE const&location,
        X_TYPE        const&x       ,
        Y_TYPE        const&y       ,
        Z_TYPE        const&z       ){
        return std::make_shared<Uniform3d<
          LOCATION_TYPE,
          X_TYPE       ,
          Y_TYPE       ,
          Z_TYPE       >>(
              location,
              x       ,
              y       ,
              z       );
    }

    template<
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat,
      typename V2_TYPE       = GLfloat>
    inline Uniform3f<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >* newUniform3f(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return new Uniform3f<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >(
              location,
              v0      ,
              v1      ,
              v2      );
    }
    template<
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat,
      typename V2_TYPE       = GLfloat>
    inline std::shared_ptr<Uniform3f<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >> sharedUniform3f(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return std::make_shared<Uniform3f<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >>(
              location,
              v0      ,
              v1      ,
              v2      );
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLubyte*>
    inline VertexAttrib4ubv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4ubv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4ubv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLubyte*>
    inline std::shared_ptr<VertexAttrib4ubv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4ubv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4ubv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetBufferParameteriv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetBufferParameteriv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetBufferParameteriv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetBufferParameteriv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetBufferParameteriv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetBufferParameteriv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename INDEX_TYPE = GLuint   ,
      typename R_TYPE     = GLboolean,
      typename G_TYPE     = GLboolean,
      typename B_TYPE     = GLboolean,
      typename A_TYPE     = GLboolean>
    inline ColorMaski<
      INDEX_TYPE,
      R_TYPE    ,
      G_TYPE    ,
      B_TYPE    ,
      A_TYPE    >* newColorMaski(
        INDEX_TYPE const&index,
        R_TYPE     const&r    ,
        G_TYPE     const&g    ,
        B_TYPE     const&b    ,
        A_TYPE     const&a    ){
        return new ColorMaski<
          INDEX_TYPE,
          R_TYPE    ,
          G_TYPE    ,
          B_TYPE    ,
          A_TYPE    >(
              index,
              r    ,
              g    ,
              b    ,
              a    );
    }
    template<
      typename INDEX_TYPE = GLuint   ,
      typename R_TYPE     = GLboolean,
      typename G_TYPE     = GLboolean,
      typename B_TYPE     = GLboolean,
      typename A_TYPE     = GLboolean>
    inline std::shared_ptr<ColorMaski<
      INDEX_TYPE,
      R_TYPE    ,
      G_TYPE    ,
      B_TYPE    ,
      A_TYPE    >> sharedColorMaski(
        INDEX_TYPE const&index,
        R_TYPE     const&r    ,
        G_TYPE     const&g    ,
        B_TYPE     const&b    ,
        A_TYPE     const&a    ){
        return std::make_shared<ColorMaski<
          INDEX_TYPE,
          R_TYPE    ,
          G_TYPE    ,
          B_TYPE    ,
          A_TYPE    >>(
              index,
              r    ,
              g    ,
              b    ,
              a    );
    }

    template<
      typename BUFFER_TYPE     = GLenum ,
      typename DRAWBUFFER_TYPE = GLint  ,
      typename DEPTH_TYPE      = GLfloat,
      typename STENCIL_TYPE    = GLint  >
    inline ClearBufferfi<
      BUFFER_TYPE    ,
      DRAWBUFFER_TYPE,
      DEPTH_TYPE     ,
      STENCIL_TYPE   >* newClearBufferfi(
        BUFFER_TYPE     const&buffer    ,
        DRAWBUFFER_TYPE const&drawbuffer,
        DEPTH_TYPE      const&depth     ,
        STENCIL_TYPE    const&stencil   ){
        return new ClearBufferfi<
          BUFFER_TYPE    ,
          DRAWBUFFER_TYPE,
          DEPTH_TYPE     ,
          STENCIL_TYPE   >(
              buffer    ,
              drawbuffer,
              depth     ,
              stencil   );
    }
    template<
      typename BUFFER_TYPE     = GLenum ,
      typename DRAWBUFFER_TYPE = GLint  ,
      typename DEPTH_TYPE      = GLfloat,
      typename STENCIL_TYPE    = GLint  >
    inline std::shared_ptr<ClearBufferfi<
      BUFFER_TYPE    ,
      DRAWBUFFER_TYPE,
      DEPTH_TYPE     ,
      STENCIL_TYPE   >> sharedClearBufferfi(
        BUFFER_TYPE     const&buffer    ,
        DRAWBUFFER_TYPE const&drawbuffer,
        DEPTH_TYPE      const&depth     ,
        STENCIL_TYPE    const&stencil   ){
        return std::make_shared<ClearBufferfi<
          BUFFER_TYPE    ,
          DRAWBUFFER_TYPE,
          DEPTH_TYPE     ,
          STENCIL_TYPE   >>(
              buffer    ,
              drawbuffer,
              depth     ,
              stencil   );
    }

    template<
      typename MODE_TYPE     = GLenum     ,
      typename INDIRECT_TYPE = const void*>
    inline DrawArraysIndirect<
      MODE_TYPE    ,
      INDIRECT_TYPE>* newDrawArraysIndirect(
        MODE_TYPE     const&mode    ,
        INDIRECT_TYPE const&indirect){
        return new DrawArraysIndirect<
          MODE_TYPE    ,
          INDIRECT_TYPE>(
              mode    ,
              indirect);
    }
    template<
      typename MODE_TYPE     = GLenum     ,
      typename INDIRECT_TYPE = const void*>
    inline std::shared_ptr<DrawArraysIndirect<
      MODE_TYPE    ,
      INDIRECT_TYPE>> sharedDrawArraysIndirect(
        MODE_TYPE     const&mode    ,
        INDIRECT_TYPE const&indirect){
        return std::make_shared<DrawArraysIndirect<
          MODE_TYPE    ,
          INDIRECT_TYPE>>(
              mode    ,
              indirect);
    }

    template<
      typename N_TYPE      = GLsizei,
      typename ARRAYS_TYPE = GLuint*>
    inline GenVertexArrays<
      N_TYPE     ,
      ARRAYS_TYPE>* newGenVertexArrays(
        N_TYPE      const&n     ,
        ARRAYS_TYPE const&arrays){
        return new GenVertexArrays<
          N_TYPE     ,
          ARRAYS_TYPE>(
              n     ,
              arrays);
    }
    template<
      typename N_TYPE      = GLsizei,
      typename ARRAYS_TYPE = GLuint*>
    inline std::shared_ptr<GenVertexArrays<
      N_TYPE     ,
      ARRAYS_TYPE>> sharedGenVertexArrays(
        N_TYPE      const&n     ,
        ARRAYS_TYPE const&arrays){
        return std::make_shared<GenVertexArrays<
          N_TYPE     ,
          ARRAYS_TYPE>>(
              n     ,
              arrays);
    }

    template<
      typename VAOBJ_TYPE = GLuint,
      typename INDEX_TYPE = GLuint>
    inline EnableVertexArrayAttrib<
      VAOBJ_TYPE,
      INDEX_TYPE>* newEnableVertexArrayAttrib(
        VAOBJ_TYPE const&vaobj,
        INDEX_TYPE const&index){
        return new EnableVertexArrayAttrib<
          VAOBJ_TYPE,
          INDEX_TYPE>(
              vaobj,
              index);
    }
    template<
      typename VAOBJ_TYPE = GLuint,
      typename INDEX_TYPE = GLuint>
    inline std::shared_ptr<EnableVertexArrayAttrib<
      VAOBJ_TYPE,
      INDEX_TYPE>> sharedEnableVertexArrayAttrib(
        VAOBJ_TYPE const&vaobj,
        INDEX_TYPE const&index){
        return std::make_shared<EnableVertexArrayAttrib<
          VAOBJ_TYPE,
          INDEX_TYPE>>(
              vaobj,
              index);
    }

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline ProgramUniformMatrix3x2dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix3x2dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix3x2dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<ProgramUniformMatrix3x2dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix3x2dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix3x2dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename READBUFFER_TYPE  = GLuint    ,
      typename WRITEBUFFER_TYPE = GLuint    ,
      typename READOFFSET_TYPE  = GLintptr  ,
      typename WRITEOFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE        = GLsizeiptr>
    inline CopyNamedBufferSubData<
      READBUFFER_TYPE ,
      WRITEBUFFER_TYPE,
      READOFFSET_TYPE ,
      WRITEOFFSET_TYPE,
      SIZE_TYPE       >* newCopyNamedBufferSubData(
        READBUFFER_TYPE  const&readBuffer ,
        WRITEBUFFER_TYPE const&writeBuffer,
        READOFFSET_TYPE  const&readOffset ,
        WRITEOFFSET_TYPE const&writeOffset,
        SIZE_TYPE        const&size       ){
        return new CopyNamedBufferSubData<
          READBUFFER_TYPE ,
          WRITEBUFFER_TYPE,
          READOFFSET_TYPE ,
          WRITEOFFSET_TYPE,
          SIZE_TYPE       >(
              readBuffer ,
              writeBuffer,
              readOffset ,
              writeOffset,
              size       );
    }
    template<
      typename READBUFFER_TYPE  = GLuint    ,
      typename WRITEBUFFER_TYPE = GLuint    ,
      typename READOFFSET_TYPE  = GLintptr  ,
      typename WRITEOFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE        = GLsizeiptr>
    inline std::shared_ptr<CopyNamedBufferSubData<
      READBUFFER_TYPE ,
      WRITEBUFFER_TYPE,
      READOFFSET_TYPE ,
      WRITEOFFSET_TYPE,
      SIZE_TYPE       >> sharedCopyNamedBufferSubData(
        READBUFFER_TYPE  const&readBuffer ,
        WRITEBUFFER_TYPE const&writeBuffer,
        READOFFSET_TYPE  const&readOffset ,
        WRITEOFFSET_TYPE const&writeOffset,
        SIZE_TYPE        const&size       ){
        return std::make_shared<CopyNamedBufferSubData<
          READBUFFER_TYPE ,
          WRITEBUFFER_TYPE,
          READOFFSET_TYPE ,
          WRITEOFFSET_TYPE,
          SIZE_TYPE       >>(
              readBuffer ,
              writeBuffer,
              readOffset ,
              writeOffset,
              size       );
    }

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat,
      typename V2_TYPE       = GLfloat>
    inline ProgramUniform3f<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >* newProgramUniform3f(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return new ProgramUniform3f<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >(
              program ,
              location,
              v0      ,
              v1      ,
              v2      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat,
      typename V2_TYPE       = GLfloat>
    inline std::shared_ptr<ProgramUniform3f<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >> sharedProgramUniform3f(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return std::make_shared<ProgramUniform3f<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >>(
              program ,
              location,
              v0      ,
              v1      ,
              v2      );
    }

    template<
      typename SAMPLER_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    inline GetSamplerParameterIiv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newGetSamplerParameterIiv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new GetSamplerParameterIiv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              sampler,
              pname  ,
              params );
    }
    template<
      typename SAMPLER_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    inline std::shared_ptr<GetSamplerParameterIiv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedGetSamplerParameterIiv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<GetSamplerParameterIiv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              sampler,
              pname  ,
              params );
    }

    template<
      typename RET_TYPE     = GLint        ,
      typename PROGRAM_TYPE = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    inline GetFragDataIndex<
      RET_TYPE    ,
      PROGRAM_TYPE,
      NAME_TYPE   >* newGetFragDataIndex(
        RET_TYPE     const&ret    ,
        PROGRAM_TYPE const&program,
        NAME_TYPE    const&name   ){
        return new GetFragDataIndex<
          RET_TYPE    ,
          PROGRAM_TYPE,
          NAME_TYPE   >(
              ret    ,
              program,
              name   );
    }
    template<
      typename RET_TYPE     = GLint        ,
      typename PROGRAM_TYPE = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    inline std::shared_ptr<GetFragDataIndex<
      RET_TYPE    ,
      PROGRAM_TYPE,
      NAME_TYPE   >> sharedGetFragDataIndex(
        RET_TYPE     const&ret    ,
        PROGRAM_TYPE const&program,
        NAME_TYPE    const&name   ){
        return std::make_shared<GetFragDataIndex<
          RET_TYPE    ,
          PROGRAM_TYPE,
          NAME_TYPE   >>(
              ret    ,
              program,
              name   );
    }

    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei,
      typename DEPTH_TYPE          = GLsizei>
    inline TexStorage3D<
      TARGET_TYPE        ,
      LEVELS_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      DEPTH_TYPE         >* newTexStorage3D(
        TARGET_TYPE         const&target        ,
        LEVELS_TYPE         const&levels        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        DEPTH_TYPE          const&depth         ){
        return new TexStorage3D<
          TARGET_TYPE        ,
          LEVELS_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          DEPTH_TYPE         >(
              target        ,
              levels        ,
              internalformat,
              width         ,
              height        ,
              depth         );
    }
    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei,
      typename DEPTH_TYPE          = GLsizei>
    inline std::shared_ptr<TexStorage3D<
      TARGET_TYPE        ,
      LEVELS_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      DEPTH_TYPE         >> sharedTexStorage3D(
        TARGET_TYPE         const&target        ,
        LEVELS_TYPE         const&levels        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        DEPTH_TYPE          const&depth         ){
        return std::make_shared<TexStorage3D<
          TARGET_TYPE        ,
          LEVELS_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          DEPTH_TYPE         >>(
              target        ,
              levels        ,
              internalformat,
              width         ,
              height        ,
              depth         );
    }

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline UniformMatrix4x2fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix4x2fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix4x2fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<UniformMatrix4x2fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix4x2fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix4x2fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename TEXTURE_TYPE = GLuint      ,
      typename PNAME_TYPE   = GLenum      ,
      typename PARAM_TYPE   = const GLint*>
    inline TextureParameteriv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >* newTextureParameteriv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return new TextureParameteriv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >(
              texture,
              pname  ,
              param  );
    }
    template<
      typename TEXTURE_TYPE = GLuint      ,
      typename PNAME_TYPE   = GLenum      ,
      typename PARAM_TYPE   = const GLint*>
    inline std::shared_ptr<TextureParameteriv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >> sharedTextureParameteriv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return std::make_shared<TextureParameteriv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >>(
              texture,
              pname  ,
              param  );
    }

    template<
      typename ID_TYPE     = GLuint  ,
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename OFFSET_TYPE = GLintptr>
    inline GetQueryBufferObjecti64v<
      ID_TYPE    ,
      BUFFER_TYPE,
      PNAME_TYPE ,
      OFFSET_TYPE>* newGetQueryBufferObjecti64v(
        ID_TYPE     const&id    ,
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        OFFSET_TYPE const&offset){
        return new GetQueryBufferObjecti64v<
          ID_TYPE    ,
          BUFFER_TYPE,
          PNAME_TYPE ,
          OFFSET_TYPE>(
              id    ,
              buffer,
              pname ,
              offset);
    }
    template<
      typename ID_TYPE     = GLuint  ,
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename OFFSET_TYPE = GLintptr>
    inline std::shared_ptr<GetQueryBufferObjecti64v<
      ID_TYPE    ,
      BUFFER_TYPE,
      PNAME_TYPE ,
      OFFSET_TYPE>> sharedGetQueryBufferObjecti64v(
        ID_TYPE     const&id    ,
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        OFFSET_TYPE const&offset){
        return std::make_shared<GetQueryBufferObjecti64v<
          ID_TYPE    ,
          BUFFER_TYPE,
          PNAME_TYPE ,
          OFFSET_TYPE>>(
              id    ,
              buffer,
              pname ,
              offset);
    }

    template<
      typename INDEX_TYPE  = GLuint   ,
      typename PNAME_TYPE  = GLenum   ,
      typename PARAMS_TYPE = GLdouble*>
    inline GetVertexAttribdv<
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetVertexAttribdv(
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetVertexAttribdv<
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              index ,
              pname ,
              params);
    }
    template<
      typename INDEX_TYPE  = GLuint   ,
      typename PNAME_TYPE  = GLenum   ,
      typename PARAMS_TYPE = GLdouble*>
    inline std::shared_ptr<GetVertexAttribdv<
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetVertexAttribdv(
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetVertexAttribdv<
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              index ,
              pname ,
              params);
    }

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline UniformMatrix3x4fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix3x4fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix3x4fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<UniformMatrix3x4fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix3x4fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix3x4fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline UniformMatrix3dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix3dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix3dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<UniformMatrix3dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix3dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix3dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline ProgramUniformMatrix3x4dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix3x4dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix3x4dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<ProgramUniformMatrix3x4dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix3x4dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix3x4dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename ATTACHMENT_TYPE  = GLenum,
      typename TEXTURE_TYPE     = GLuint,
      typename LEVEL_TYPE       = GLint >
    inline NamedFramebufferTexture<
      FRAMEBUFFER_TYPE,
      ATTACHMENT_TYPE ,
      TEXTURE_TYPE    ,
      LEVEL_TYPE      >* newNamedFramebufferTexture(
        FRAMEBUFFER_TYPE const&framebuffer,
        ATTACHMENT_TYPE  const&attachment ,
        TEXTURE_TYPE     const&texture    ,
        LEVEL_TYPE       const&level      ){
        return new NamedFramebufferTexture<
          FRAMEBUFFER_TYPE,
          ATTACHMENT_TYPE ,
          TEXTURE_TYPE    ,
          LEVEL_TYPE      >(
              framebuffer,
              attachment ,
              texture    ,
              level      );
    }
    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename ATTACHMENT_TYPE  = GLenum,
      typename TEXTURE_TYPE     = GLuint,
      typename LEVEL_TYPE       = GLint >
    inline std::shared_ptr<NamedFramebufferTexture<
      FRAMEBUFFER_TYPE,
      ATTACHMENT_TYPE ,
      TEXTURE_TYPE    ,
      LEVEL_TYPE      >> sharedNamedFramebufferTexture(
        FRAMEBUFFER_TYPE const&framebuffer,
        ATTACHMENT_TYPE  const&attachment ,
        TEXTURE_TYPE     const&texture    ,
        LEVEL_TYPE       const&level      ){
        return std::make_shared<NamedFramebufferTexture<
          FRAMEBUFFER_TYPE,
          ATTACHMENT_TYPE ,
          TEXTURE_TYPE    ,
          LEVEL_TYPE      >>(
              framebuffer,
              attachment ,
              texture    ,
              level      );
    }

    template<
      typename TARGET_TYPE  = GLenum           ,
      typename FIRST_TYPE   = GLuint           ,
      typename COUNT_TYPE   = GLsizei          ,
      typename BUFFERS_TYPE = const GLuint*    ,
      typename OFFSETS_TYPE = const GLintptr*  ,
      typename SIZES_TYPE   = const GLsizeiptr*>
    inline BindBuffersRange<
      TARGET_TYPE ,
      FIRST_TYPE  ,
      COUNT_TYPE  ,
      BUFFERS_TYPE,
      OFFSETS_TYPE,
      SIZES_TYPE  >* newBindBuffersRange(
        TARGET_TYPE  const&target ,
        FIRST_TYPE   const&first  ,
        COUNT_TYPE   const&count  ,
        BUFFERS_TYPE const&buffers,
        OFFSETS_TYPE const&offsets,
        SIZES_TYPE   const&sizes  ){
        return new BindBuffersRange<
          TARGET_TYPE ,
          FIRST_TYPE  ,
          COUNT_TYPE  ,
          BUFFERS_TYPE,
          OFFSETS_TYPE,
          SIZES_TYPE  >(
              target ,
              first  ,
              count  ,
              buffers,
              offsets,
              sizes  );
    }
    template<
      typename TARGET_TYPE  = GLenum           ,
      typename FIRST_TYPE   = GLuint           ,
      typename COUNT_TYPE   = GLsizei          ,
      typename BUFFERS_TYPE = const GLuint*    ,
      typename OFFSETS_TYPE = const GLintptr*  ,
      typename SIZES_TYPE   = const GLsizeiptr*>
    inline std::shared_ptr<BindBuffersRange<
      TARGET_TYPE ,
      FIRST_TYPE  ,
      COUNT_TYPE  ,
      BUFFERS_TYPE,
      OFFSETS_TYPE,
      SIZES_TYPE  >> sharedBindBuffersRange(
        TARGET_TYPE  const&target ,
        FIRST_TYPE   const&first  ,
        COUNT_TYPE   const&count  ,
        BUFFERS_TYPE const&buffers,
        OFFSETS_TYPE const&offsets,
        SIZES_TYPE   const&sizes  ){
        return std::make_shared<BindBuffersRange<
          TARGET_TYPE ,
          FIRST_TYPE  ,
          COUNT_TYPE  ,
          BUFFERS_TYPE,
          OFFSETS_TYPE,
          SIZES_TYPE  >>(
              target ,
              first  ,
              count  ,
              buffers,
              offsets,
              sizes  );
    }

    template<
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr>
    inline InvalidateBufferSubData<
      BUFFER_TYPE,
      OFFSET_TYPE,
      LENGTH_TYPE>* newInvalidateBufferSubData(
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        LENGTH_TYPE const&length){
        return new InvalidateBufferSubData<
          BUFFER_TYPE,
          OFFSET_TYPE,
          LENGTH_TYPE>(
              buffer,
              offset,
              length);
    }
    template<
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr>
    inline std::shared_ptr<InvalidateBufferSubData<
      BUFFER_TYPE,
      OFFSET_TYPE,
      LENGTH_TYPE>> sharedInvalidateBufferSubData(
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        LENGTH_TYPE const&length){
        return std::make_shared<InvalidateBufferSubData<
          BUFFER_TYPE,
          OFFSET_TYPE,
          LENGTH_TYPE>>(
              buffer,
              offset,
              length);
    }


    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline ProgramUniformMatrix4x3fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix4x3fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix4x3fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<ProgramUniformMatrix4x3fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix4x3fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix4x3fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename FIRST_TYPE = GLuint        ,
      typename COUNT_TYPE = GLsizei       ,
      typename V_TYPE     = const GLfloat*>
    inline ViewportArrayv<
      FIRST_TYPE,
      COUNT_TYPE,
      V_TYPE    >* newViewportArrayv(
        FIRST_TYPE const&first,
        COUNT_TYPE const&count,
        V_TYPE     const&v    ){
        return new ViewportArrayv<
          FIRST_TYPE,
          COUNT_TYPE,
          V_TYPE    >(
              first,
              count,
              v    );
    }
    template<
      typename FIRST_TYPE = GLuint        ,
      typename COUNT_TYPE = GLsizei       ,
      typename V_TYPE     = const GLfloat*>
    inline std::shared_ptr<ViewportArrayv<
      FIRST_TYPE,
      COUNT_TYPE,
      V_TYPE    >> sharedViewportArrayv(
        FIRST_TYPE const&first,
        COUNT_TYPE const&count,
        V_TYPE     const&v    ){
        return std::make_shared<ViewportArrayv<
          FIRST_TYPE,
          COUNT_TYPE,
          V_TYPE    >>(
              first,
              count,
              v    );
    }

    template<
      typename N_TYPE            = GLsizei      ,
      typename FRAMEBUFFERS_TYPE = const GLuint*>
    inline DeleteFramebuffers<
      N_TYPE           ,
      FRAMEBUFFERS_TYPE>* newDeleteFramebuffers(
        N_TYPE            const&n           ,
        FRAMEBUFFERS_TYPE const&framebuffers){
        return new DeleteFramebuffers<
          N_TYPE           ,
          FRAMEBUFFERS_TYPE>(
              n           ,
              framebuffers);
    }
    template<
      typename N_TYPE            = GLsizei      ,
      typename FRAMEBUFFERS_TYPE = const GLuint*>
    inline std::shared_ptr<DeleteFramebuffers<
      N_TYPE           ,
      FRAMEBUFFERS_TYPE>> sharedDeleteFramebuffers(
        N_TYPE            const&n           ,
        FRAMEBUFFERS_TYPE const&framebuffers){
        return std::make_shared<DeleteFramebuffers<
          N_TYPE           ,
          FRAMEBUFFERS_TYPE>>(
              n           ,
              framebuffers);
    }

    template<
      typename MODE_TYPE  = GLenum ,
      typename FIRST_TYPE = GLint  ,
      typename COUNT_TYPE = GLsizei>
    inline DrawArrays<
      MODE_TYPE ,
      FIRST_TYPE,
      COUNT_TYPE>* newDrawArrays(
        MODE_TYPE  const&mode ,
        FIRST_TYPE const&first,
        COUNT_TYPE const&count){
        return new DrawArrays<
          MODE_TYPE ,
          FIRST_TYPE,
          COUNT_TYPE>(
              mode ,
              first,
              count);
    }
    template<
      typename MODE_TYPE  = GLenum ,
      typename FIRST_TYPE = GLint  ,
      typename COUNT_TYPE = GLsizei>
    inline std::shared_ptr<DrawArrays<
      MODE_TYPE ,
      FIRST_TYPE,
      COUNT_TYPE>> sharedDrawArrays(
        MODE_TYPE  const&mode ,
        FIRST_TYPE const&first,
        COUNT_TYPE const&count){
        return std::make_shared<DrawArrays<
          MODE_TYPE ,
          FIRST_TYPE,
          COUNT_TYPE>>(
              mode ,
              first,
              count);
    }

    template<
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint>
    inline Uniform1ui<
      LOCATION_TYPE,
      V0_TYPE      >* newUniform1ui(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return new Uniform1ui<
          LOCATION_TYPE,
          V0_TYPE      >(
              location,
              v0      );
    }
    template<
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint>
    inline std::shared_ptr<Uniform1ui<
      LOCATION_TYPE,
      V0_TYPE      >> sharedUniform1ui(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return std::make_shared<Uniform1ui<
          LOCATION_TYPE,
          V0_TYPE      >>(
              location,
              v0      );
    }

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline VertexAttrib1dv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib1dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib1dv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline std::shared_ptr<VertexAttrib1dv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib1dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib1dv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLint ,
      typename Y_TYPE     = GLint >
    inline VertexAttribI2i<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    >* newVertexAttribI2i(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ){
        return new VertexAttribI2i<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    >(
              index,
              x    ,
              y    );
    }
    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLint ,
      typename Y_TYPE     = GLint >
    inline std::shared_ptr<VertexAttribI2i<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    >> sharedVertexAttribI2i(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ){
        return std::make_shared<VertexAttribI2i<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    >>(
              index,
              x    ,
              y    );
    }

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble,
      typename Z_TYPE     = GLdouble>
    inline VertexAttrib3d<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    >* newVertexAttrib3d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ){
        return new VertexAttrib3d<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    >(
              index,
              x    ,
              y    ,
              z    );
    }
    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble,
      typename Z_TYPE     = GLdouble>
    inline std::shared_ptr<VertexAttrib3d<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    >> sharedVertexAttrib3d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ){
        return std::make_shared<VertexAttrib3d<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    >>(
              index,
              x    ,
              y    ,
              z    );
    }

    template<
      typename MASK_TYPE = GLbitfield>
    inline Clear<
      MASK_TYPE>* newClear(
        MASK_TYPE const&mask){
        return new Clear<
          MASK_TYPE>(
              mask);
    }
    template<
      typename MASK_TYPE = GLbitfield>
    inline std::shared_ptr<Clear<
      MASK_TYPE>> sharedClear(
        MASK_TYPE const&mask){
        return std::make_shared<Clear<
          MASK_TYPE>>(
              mask);
    }

    template<
      typename PROGRAM_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename VALUE_TYPE   = GLint >
    inline ProgramParameteri<
      PROGRAM_TYPE,
      PNAME_TYPE  ,
      VALUE_TYPE  >* newProgramParameteri(
        PROGRAM_TYPE const&program,
        PNAME_TYPE   const&pname  ,
        VALUE_TYPE   const&value  ){
        return new ProgramParameteri<
          PROGRAM_TYPE,
          PNAME_TYPE  ,
          VALUE_TYPE  >(
              program,
              pname  ,
              value  );
    }
    template<
      typename PROGRAM_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename VALUE_TYPE   = GLint >
    inline std::shared_ptr<ProgramParameteri<
      PROGRAM_TYPE,
      PNAME_TYPE  ,
      VALUE_TYPE  >> sharedProgramParameteri(
        PROGRAM_TYPE const&program,
        PNAME_TYPE   const&pname  ,
        VALUE_TYPE   const&value  ){
        return std::make_shared<ProgramParameteri<
          PROGRAM_TYPE,
          PNAME_TYPE  ,
          VALUE_TYPE  >>(
              program,
              pname  ,
              value  );
    }

    template<
      typename PROGRAM_TYPE      = GLuint  ,
      typename UNIFORMINDEX_TYPE = GLuint  ,
      typename BUFSIZE_TYPE      = GLsizei ,
      typename LENGTH_TYPE       = GLsizei*,
      typename UNIFORMNAME_TYPE  = GLchar* >
    inline GetActiveUniformName<
      PROGRAM_TYPE     ,
      UNIFORMINDEX_TYPE,
      BUFSIZE_TYPE     ,
      LENGTH_TYPE      ,
      UNIFORMNAME_TYPE >* newGetActiveUniformName(
        PROGRAM_TYPE      const&program     ,
        UNIFORMINDEX_TYPE const&uniformIndex,
        BUFSIZE_TYPE      const&bufSize     ,
        LENGTH_TYPE       const&length      ,
        UNIFORMNAME_TYPE  const&uniformName ){
        return new GetActiveUniformName<
          PROGRAM_TYPE     ,
          UNIFORMINDEX_TYPE,
          BUFSIZE_TYPE     ,
          LENGTH_TYPE      ,
          UNIFORMNAME_TYPE >(
              program     ,
              uniformIndex,
              bufSize     ,
              length      ,
              uniformName );
    }
    template<
      typename PROGRAM_TYPE      = GLuint  ,
      typename UNIFORMINDEX_TYPE = GLuint  ,
      typename BUFSIZE_TYPE      = GLsizei ,
      typename LENGTH_TYPE       = GLsizei*,
      typename UNIFORMNAME_TYPE  = GLchar* >
    inline std::shared_ptr<GetActiveUniformName<
      PROGRAM_TYPE     ,
      UNIFORMINDEX_TYPE,
      BUFSIZE_TYPE     ,
      LENGTH_TYPE      ,
      UNIFORMNAME_TYPE >> sharedGetActiveUniformName(
        PROGRAM_TYPE      const&program     ,
        UNIFORMINDEX_TYPE const&uniformIndex,
        BUFSIZE_TYPE      const&bufSize     ,
        LENGTH_TYPE       const&length      ,
        UNIFORMNAME_TYPE  const&uniformName ){
        return std::make_shared<GetActiveUniformName<
          PROGRAM_TYPE     ,
          UNIFORMINDEX_TYPE,
          BUFSIZE_TYPE     ,
          LENGTH_TYPE      ,
          UNIFORMNAME_TYPE >>(
              program     ,
              uniformIndex,
              bufSize     ,
              length      ,
              uniformName );
    }

    template<
      typename BARRIERS_TYPE = GLbitfield>
    inline MemoryBarrier<
      BARRIERS_TYPE>* newMemoryBarrier(
        BARRIERS_TYPE const&barriers){
        return new MemoryBarrier<
          BARRIERS_TYPE>(
              barriers);
    }
    template<
      typename BARRIERS_TYPE = GLbitfield>
    inline std::shared_ptr<MemoryBarrier<
      BARRIERS_TYPE>> sharedMemoryBarrier(
        BARRIERS_TYPE const&barriers){
        return std::make_shared<MemoryBarrier<
          BARRIERS_TYPE>>(
              barriers);
    }

    template<
      typename RET_TYPE = GLenum>
    inline GetGraphicsResetStatus<
      RET_TYPE>* newGetGraphicsResetStatus(
        RET_TYPE const&ret){
        return new GetGraphicsResetStatus<
          RET_TYPE>(
              ret);
    }
    template<
      typename RET_TYPE = GLenum>
    inline std::shared_ptr<GetGraphicsResetStatus<
      RET_TYPE>> sharedGetGraphicsResetStatus(
        RET_TYPE const&ret){
        return std::make_shared<GetGraphicsResetStatus<
          RET_TYPE>>(
              ret);
    }

    template<
      typename TARGET_TYPE  = GLenum,
      typename TEXTURE_TYPE = GLuint>
    inline BindTexture<
      TARGET_TYPE ,
      TEXTURE_TYPE>* newBindTexture(
        TARGET_TYPE  const&target ,
        TEXTURE_TYPE const&texture){
        return new BindTexture<
          TARGET_TYPE ,
          TEXTURE_TYPE>(
              target ,
              texture);
    }
    template<
      typename TARGET_TYPE  = GLenum,
      typename TEXTURE_TYPE = GLuint>
    inline std::shared_ptr<BindTexture<
      TARGET_TYPE ,
      TEXTURE_TYPE>> sharedBindTexture(
        TARGET_TYPE  const&target ,
        TEXTURE_TYPE const&texture){
        return std::make_shared<BindTexture<
          TARGET_TYPE ,
          TEXTURE_TYPE>>(
              target ,
              texture);
    }

    template<
      typename RET_TYPE = GLboolean,
      typename CAP_TYPE = GLenum   >
    inline IsEnabled<
      RET_TYPE,
      CAP_TYPE>* newIsEnabled(
        RET_TYPE const&ret,
        CAP_TYPE const&cap){
        return new IsEnabled<
          RET_TYPE,
          CAP_TYPE>(
              ret,
              cap);
    }
    template<
      typename RET_TYPE = GLboolean,
      typename CAP_TYPE = GLenum   >
    inline std::shared_ptr<IsEnabled<
      RET_TYPE,
      CAP_TYPE>> sharedIsEnabled(
        RET_TYPE const&ret,
        CAP_TYPE const&cap){
        return std::make_shared<IsEnabled<
          RET_TYPE,
          CAP_TYPE>>(
              ret,
              cap);
    }

    template<
      typename INDEX_TYPE      = GLuint   ,
      typename TYPE_TYPE       = GLenum   ,
      typename NORMALIZED_TYPE = GLboolean,
      typename VALUE_TYPE      = GLuint   >
    inline VertexAttribP2ui<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >* newVertexAttribP2ui(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return new VertexAttribP2ui<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >(
              index     ,
              type      ,
              normalized,
              value     );
    }
    template<
      typename INDEX_TYPE      = GLuint   ,
      typename TYPE_TYPE       = GLenum   ,
      typename NORMALIZED_TYPE = GLboolean,
      typename VALUE_TYPE      = GLuint   >
    inline std::shared_ptr<VertexAttribP2ui<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >> sharedVertexAttribP2ui(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return std::make_shared<VertexAttribP2ui<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >>(
              index     ,
              type      ,
              normalized,
              value     );
    }

    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTARGET_TYPE  = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint >
    inline FramebufferTexture2D<
      TARGET_TYPE    ,
      ATTACHMENT_TYPE,
      TEXTARGET_TYPE ,
      TEXTURE_TYPE   ,
      LEVEL_TYPE     >* newFramebufferTexture2D(
        TARGET_TYPE     const&target    ,
        ATTACHMENT_TYPE const&attachment,
        TEXTARGET_TYPE  const&textarget ,
        TEXTURE_TYPE    const&texture   ,
        LEVEL_TYPE      const&level     ){
        return new FramebufferTexture2D<
          TARGET_TYPE    ,
          ATTACHMENT_TYPE,
          TEXTARGET_TYPE ,
          TEXTURE_TYPE   ,
          LEVEL_TYPE     >(
              target    ,
              attachment,
              textarget ,
              texture   ,
              level     );
    }
    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTARGET_TYPE  = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint >
    inline std::shared_ptr<FramebufferTexture2D<
      TARGET_TYPE    ,
      ATTACHMENT_TYPE,
      TEXTARGET_TYPE ,
      TEXTURE_TYPE   ,
      LEVEL_TYPE     >> sharedFramebufferTexture2D(
        TARGET_TYPE     const&target    ,
        ATTACHMENT_TYPE const&attachment,
        TEXTARGET_TYPE  const&textarget ,
        TEXTURE_TYPE    const&texture   ,
        LEVEL_TYPE      const&level     ){
        return std::make_shared<FramebufferTexture2D<
          TARGET_TYPE    ,
          ATTACHMENT_TYPE,
          TEXTARGET_TYPE ,
          TEXTURE_TYPE   ,
          LEVEL_TYPE     >>(
              target    ,
              attachment,
              textarget ,
              texture   ,
              level     );
    }

    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename PNAME_TYPE      = GLenum,
      typename PARAMS_TYPE     = GLint*>
    inline GetFramebufferAttachmentParameteriv<
      TARGET_TYPE    ,
      ATTACHMENT_TYPE,
      PNAME_TYPE     ,
      PARAMS_TYPE    >* newGetFramebufferAttachmentParameteriv(
        TARGET_TYPE     const&target    ,
        ATTACHMENT_TYPE const&attachment,
        PNAME_TYPE      const&pname     ,
        PARAMS_TYPE     const&params    ){
        return new GetFramebufferAttachmentParameteriv<
          TARGET_TYPE    ,
          ATTACHMENT_TYPE,
          PNAME_TYPE     ,
          PARAMS_TYPE    >(
              target    ,
              attachment,
              pname     ,
              params    );
    }
    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename PNAME_TYPE      = GLenum,
      typename PARAMS_TYPE     = GLint*>
    inline std::shared_ptr<GetFramebufferAttachmentParameteriv<
      TARGET_TYPE    ,
      ATTACHMENT_TYPE,
      PNAME_TYPE     ,
      PARAMS_TYPE    >> sharedGetFramebufferAttachmentParameteriv(
        TARGET_TYPE     const&target    ,
        ATTACHMENT_TYPE const&attachment,
        PNAME_TYPE      const&pname     ,
        PARAMS_TYPE     const&params    ){
        return std::make_shared<GetFramebufferAttachmentParameteriv<
          TARGET_TYPE    ,
          ATTACHMENT_TYPE,
          PNAME_TYPE     ,
          PARAMS_TYPE    >>(
              target    ,
              attachment,
              pname     ,
              params    );
    }

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLubyte,
      typename Y_TYPE     = GLubyte,
      typename Z_TYPE     = GLubyte,
      typename W_TYPE     = GLubyte>
    inline VertexAttrib4Nub<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >* newVertexAttrib4Nub(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return new VertexAttrib4Nub<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }
    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLubyte,
      typename Y_TYPE     = GLubyte,
      typename Z_TYPE     = GLubyte,
      typename W_TYPE     = GLubyte>
    inline std::shared_ptr<VertexAttrib4Nub<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >> sharedVertexAttrib4Nub(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return std::make_shared<VertexAttrib4Nub<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >>(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }

    template<
      typename RET_TYPE    = void*     ,
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr,
      typename ACCESS_TYPE = GLbitfield>
    inline MapNamedBufferRange<
      RET_TYPE   ,
      BUFFER_TYPE,
      OFFSET_TYPE,
      LENGTH_TYPE,
      ACCESS_TYPE>* newMapNamedBufferRange(
        RET_TYPE    const&ret   ,
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        LENGTH_TYPE const&length,
        ACCESS_TYPE const&access){
        return new MapNamedBufferRange<
          RET_TYPE   ,
          BUFFER_TYPE,
          OFFSET_TYPE,
          LENGTH_TYPE,
          ACCESS_TYPE>(
              ret   ,
              buffer,
              offset,
              length,
              access);
    }
    template<
      typename RET_TYPE    = void*     ,
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr,
      typename ACCESS_TYPE = GLbitfield>
    inline std::shared_ptr<MapNamedBufferRange<
      RET_TYPE   ,
      BUFFER_TYPE,
      OFFSET_TYPE,
      LENGTH_TYPE,
      ACCESS_TYPE>> sharedMapNamedBufferRange(
        RET_TYPE    const&ret   ,
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        LENGTH_TYPE const&length,
        ACCESS_TYPE const&access){
        return std::make_shared<MapNamedBufferRange<
          RET_TYPE   ,
          BUFFER_TYPE,
          OFFSET_TYPE,
          LENGTH_TYPE,
          ACCESS_TYPE>>(
              ret   ,
              buffer,
              offset,
              length,
              access);
    }

    template<
      typename RET_TYPE     = GLint        ,
      typename PROGRAM_TYPE = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    inline GetFragDataLocation<
      RET_TYPE    ,
      PROGRAM_TYPE,
      NAME_TYPE   >* newGetFragDataLocation(
        RET_TYPE     const&ret    ,
        PROGRAM_TYPE const&program,
        NAME_TYPE    const&name   ){
        return new GetFragDataLocation<
          RET_TYPE    ,
          PROGRAM_TYPE,
          NAME_TYPE   >(
              ret    ,
              program,
              name   );
    }
    template<
      typename RET_TYPE     = GLint        ,
      typename PROGRAM_TYPE = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    inline std::shared_ptr<GetFragDataLocation<
      RET_TYPE    ,
      PROGRAM_TYPE,
      NAME_TYPE   >> sharedGetFragDataLocation(
        RET_TYPE     const&ret    ,
        PROGRAM_TYPE const&program,
        NAME_TYPE    const&name   ){
        return std::make_shared<GetFragDataLocation<
          RET_TYPE    ,
          PROGRAM_TYPE,
          NAME_TYPE   >>(
              ret    ,
              program,
              name   );
    }

    template<
      typename TEXTURE_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    inline GetTextureParameterIiv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newGetTextureParameterIiv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new GetTextureParameterIiv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              texture,
              pname  ,
              params );
    }
    template<
      typename TEXTURE_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    inline std::shared_ptr<GetTextureParameterIiv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedGetTextureParameterIiv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<GetTextureParameterIiv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              texture,
              pname  ,
              params );
    }

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLint      ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename PIXELS_TYPE         = const void*>
    inline TexImage1D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      BORDER_TYPE        ,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      PIXELS_TYPE        >* newTexImage1D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        BORDER_TYPE         const&border        ,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        PIXELS_TYPE         const&pixels        ){
        return new TexImage1D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          BORDER_TYPE        ,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          PIXELS_TYPE        >(
              target        ,
              level         ,
              internalformat,
              width         ,
              border        ,
              format        ,
              type          ,
              pixels        );
    }
    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLint      ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename PIXELS_TYPE         = const void*>
    inline std::shared_ptr<TexImage1D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      BORDER_TYPE        ,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      PIXELS_TYPE        >> sharedTexImage1D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        BORDER_TYPE         const&border        ,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        PIXELS_TYPE         const&pixels        ){
        return std::make_shared<TexImage1D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          BORDER_TYPE        ,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          PIXELS_TYPE        >>(
              target        ,
              level         ,
              internalformat,
              width         ,
              border        ,
              format        ,
              type          ,
              pixels        );
    }

    template<
      typename TARGET_TYPE = GLenum      ,
      typename PNAME_TYPE  = GLenum      ,
      typename PARAMS_TYPE = const GLint*>
    inline TexParameteriv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newTexParameteriv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new TexParameteriv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum      ,
      typename PNAME_TYPE  = GLenum      ,
      typename PARAMS_TYPE = const GLint*>
    inline std::shared_ptr<TexParameteriv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedTexParameteriv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<TexParameteriv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename VAOBJ_TYPE          = GLuint,
      typename ATTRIBINDEX_TYPE    = GLuint,
      typename SIZE_TYPE           = GLint ,
      typename TYPE_TYPE           = GLenum,
      typename RELATIVEOFFSET_TYPE = GLuint>
    inline VertexArrayAttribIFormat<
      VAOBJ_TYPE         ,
      ATTRIBINDEX_TYPE   ,
      SIZE_TYPE          ,
      TYPE_TYPE          ,
      RELATIVEOFFSET_TYPE>* newVertexArrayAttribIFormat(
        VAOBJ_TYPE          const&vaobj         ,
        ATTRIBINDEX_TYPE    const&attribindex   ,
        SIZE_TYPE           const&size          ,
        TYPE_TYPE           const&type          ,
        RELATIVEOFFSET_TYPE const&relativeoffset){
        return new VertexArrayAttribIFormat<
          VAOBJ_TYPE         ,
          ATTRIBINDEX_TYPE   ,
          SIZE_TYPE          ,
          TYPE_TYPE          ,
          RELATIVEOFFSET_TYPE>(
              vaobj         ,
              attribindex   ,
              size          ,
              type          ,
              relativeoffset);
    }
    template<
      typename VAOBJ_TYPE          = GLuint,
      typename ATTRIBINDEX_TYPE    = GLuint,
      typename SIZE_TYPE           = GLint ,
      typename TYPE_TYPE           = GLenum,
      typename RELATIVEOFFSET_TYPE = GLuint>
    inline std::shared_ptr<VertexArrayAttribIFormat<
      VAOBJ_TYPE         ,
      ATTRIBINDEX_TYPE   ,
      SIZE_TYPE          ,
      TYPE_TYPE          ,
      RELATIVEOFFSET_TYPE>> sharedVertexArrayAttribIFormat(
        VAOBJ_TYPE          const&vaobj         ,
        ATTRIBINDEX_TYPE    const&attribindex   ,
        SIZE_TYPE           const&size          ,
        TYPE_TYPE           const&type          ,
        RELATIVEOFFSET_TYPE const&relativeoffset){
        return std::make_shared<VertexArrayAttribIFormat<
          VAOBJ_TYPE         ,
          ATTRIBINDEX_TYPE   ,
          SIZE_TYPE          ,
          TYPE_TYPE          ,
          RELATIVEOFFSET_TYPE>>(
              vaobj         ,
              attribindex   ,
              size          ,
              type          ,
              relativeoffset);
    }

    template<
      typename VAOBJ_TYPE        = GLuint  ,
      typename BINDINGINDEX_TYPE = GLuint  ,
      typename BUFFER_TYPE       = GLuint  ,
      typename OFFSET_TYPE       = GLintptr,
      typename STRIDE_TYPE       = GLsizei >
    inline VertexArrayVertexBuffer<
      VAOBJ_TYPE       ,
      BINDINGINDEX_TYPE,
      BUFFER_TYPE      ,
      OFFSET_TYPE      ,
      STRIDE_TYPE      >* newVertexArrayVertexBuffer(
        VAOBJ_TYPE        const&vaobj       ,
        BINDINGINDEX_TYPE const&bindingindex,
        BUFFER_TYPE       const&buffer      ,
        OFFSET_TYPE       const&offset      ,
        STRIDE_TYPE       const&stride      ){
        return new VertexArrayVertexBuffer<
          VAOBJ_TYPE       ,
          BINDINGINDEX_TYPE,
          BUFFER_TYPE      ,
          OFFSET_TYPE      ,
          STRIDE_TYPE      >(
              vaobj       ,
              bindingindex,
              buffer      ,
              offset      ,
              stride      );
    }
    template<
      typename VAOBJ_TYPE        = GLuint  ,
      typename BINDINGINDEX_TYPE = GLuint  ,
      typename BUFFER_TYPE       = GLuint  ,
      typename OFFSET_TYPE       = GLintptr,
      typename STRIDE_TYPE       = GLsizei >
    inline std::shared_ptr<VertexArrayVertexBuffer<
      VAOBJ_TYPE       ,
      BINDINGINDEX_TYPE,
      BUFFER_TYPE      ,
      OFFSET_TYPE      ,
      STRIDE_TYPE      >> sharedVertexArrayVertexBuffer(
        VAOBJ_TYPE        const&vaobj       ,
        BINDINGINDEX_TYPE const&bindingindex,
        BUFFER_TYPE       const&buffer      ,
        OFFSET_TYPE       const&offset      ,
        STRIDE_TYPE       const&stride      ){
        return std::make_shared<VertexArrayVertexBuffer<
          VAOBJ_TYPE       ,
          BINDINGINDEX_TYPE,
          BUFFER_TYPE      ,
          OFFSET_TYPE      ,
          STRIDE_TYPE      >>(
              vaobj       ,
              bindingindex,
              buffer      ,
              offset      ,
              stride      );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename LEVEL_TYPE  = GLint ,
      typename FORMAT_TYPE = GLenum,
      typename TYPE_TYPE   = GLenum,
      typename PIXELS_TYPE = void* >
    inline GetTexImage<
      TARGET_TYPE,
      LEVEL_TYPE ,
      FORMAT_TYPE,
      TYPE_TYPE  ,
      PIXELS_TYPE>* newGetTexImage(
        TARGET_TYPE const&target,
        LEVEL_TYPE  const&level ,
        FORMAT_TYPE const&format,
        TYPE_TYPE   const&type  ,
        PIXELS_TYPE const&pixels){
        return new GetTexImage<
          TARGET_TYPE,
          LEVEL_TYPE ,
          FORMAT_TYPE,
          TYPE_TYPE  ,
          PIXELS_TYPE>(
              target,
              level ,
              format,
              type  ,
              pixels);
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename LEVEL_TYPE  = GLint ,
      typename FORMAT_TYPE = GLenum,
      typename TYPE_TYPE   = GLenum,
      typename PIXELS_TYPE = void* >
    inline std::shared_ptr<GetTexImage<
      TARGET_TYPE,
      LEVEL_TYPE ,
      FORMAT_TYPE,
      TYPE_TYPE  ,
      PIXELS_TYPE>> sharedGetTexImage(
        TARGET_TYPE const&target,
        LEVEL_TYPE  const&level ,
        FORMAT_TYPE const&format,
        TYPE_TYPE   const&type  ,
        PIXELS_TYPE const&pixels){
        return std::make_shared<GetTexImage<
          TARGET_TYPE,
          LEVEL_TYPE ,
          FORMAT_TYPE,
          TYPE_TYPE  ,
          PIXELS_TYPE>>(
              target,
              level ,
              format,
              type  ,
              pixels);
    }

    template<
      typename ID_TYPE     = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLint64*>
    inline GetQueryObjecti64v<
      ID_TYPE    ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetQueryObjecti64v(
        ID_TYPE     const&id    ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetQueryObjecti64v<
          ID_TYPE    ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              id    ,
              pname ,
              params);
    }
    template<
      typename ID_TYPE     = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLint64*>
    inline std::shared_ptr<GetQueryObjecti64v<
      ID_TYPE    ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetQueryObjecti64v(
        ID_TYPE     const&id    ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetQueryObjecti64v<
          ID_TYPE    ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              id    ,
              pname ,
              params);
    }

    template<
      typename N_TYPE            = GLsizei,
      typename FRAMEBUFFERS_TYPE = GLuint*>
    inline GenFramebuffers<
      N_TYPE           ,
      FRAMEBUFFERS_TYPE>* newGenFramebuffers(
        N_TYPE            const&n           ,
        FRAMEBUFFERS_TYPE const&framebuffers){
        return new GenFramebuffers<
          N_TYPE           ,
          FRAMEBUFFERS_TYPE>(
              n           ,
              framebuffers);
    }
    template<
      typename N_TYPE            = GLsizei,
      typename FRAMEBUFFERS_TYPE = GLuint*>
    inline std::shared_ptr<GenFramebuffers<
      N_TYPE           ,
      FRAMEBUFFERS_TYPE>> sharedGenFramebuffers(
        N_TYPE            const&n           ,
        FRAMEBUFFERS_TYPE const&framebuffers){
        return std::make_shared<GenFramebuffers<
          N_TYPE           ,
          FRAMEBUFFERS_TYPE>>(
              n           ,
              framebuffers);
    }

    template<
      typename XFB_TYPE    = GLuint,
      typename INDEX_TYPE  = GLuint,
      typename BUFFER_TYPE = GLuint>
    inline TransformFeedbackBufferBase<
      XFB_TYPE   ,
      INDEX_TYPE ,
      BUFFER_TYPE>* newTransformFeedbackBufferBase(
        XFB_TYPE    const&xfb   ,
        INDEX_TYPE  const&index ,
        BUFFER_TYPE const&buffer){
        return new TransformFeedbackBufferBase<
          XFB_TYPE   ,
          INDEX_TYPE ,
          BUFFER_TYPE>(
              xfb   ,
              index ,
              buffer);
    }
    template<
      typename XFB_TYPE    = GLuint,
      typename INDEX_TYPE  = GLuint,
      typename BUFFER_TYPE = GLuint>
    inline std::shared_ptr<TransformFeedbackBufferBase<
      XFB_TYPE   ,
      INDEX_TYPE ,
      BUFFER_TYPE>> sharedTransformFeedbackBufferBase(
        XFB_TYPE    const&xfb   ,
        INDEX_TYPE  const&index ,
        BUFFER_TYPE const&buffer){
        return std::make_shared<TransformFeedbackBufferBase<
          XFB_TYPE   ,
          INDEX_TYPE ,
          BUFFER_TYPE>>(
              xfb   ,
              index ,
              buffer);
    }

    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename ZOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename DEPTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename DATA_TYPE    = const void*>
    inline ClearTexSubImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      DEPTH_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      DATA_TYPE   >* newClearTexSubImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        DEPTH_TYPE   const&depth  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        DATA_TYPE    const&data   ){
        return new ClearTexSubImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          DEPTH_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          DATA_TYPE   >(
              texture,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              width  ,
              height ,
              depth  ,
              format ,
              type   ,
              data   );
    }
    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename ZOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename DEPTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename DATA_TYPE    = const void*>
    inline std::shared_ptr<ClearTexSubImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      DEPTH_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      DATA_TYPE   >> sharedClearTexSubImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        DEPTH_TYPE   const&depth  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        DATA_TYPE    const&data   ){
        return std::make_shared<ClearTexSubImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          DEPTH_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          DATA_TYPE   >>(
              texture,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              width  ,
              height ,
              depth  ,
              format ,
              type   ,
              data   );
    }

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename MAXCOUNT_TYPE = GLsizei ,
      typename COUNT_TYPE    = GLsizei*,
      typename SHADERS_TYPE  = GLuint* >
    inline GetAttachedShaders<
      PROGRAM_TYPE ,
      MAXCOUNT_TYPE,
      COUNT_TYPE   ,
      SHADERS_TYPE >* newGetAttachedShaders(
        PROGRAM_TYPE  const&program ,
        MAXCOUNT_TYPE const&maxCount,
        COUNT_TYPE    const&count   ,
        SHADERS_TYPE  const&shaders ){
        return new GetAttachedShaders<
          PROGRAM_TYPE ,
          MAXCOUNT_TYPE,
          COUNT_TYPE   ,
          SHADERS_TYPE >(
              program ,
              maxCount,
              count   ,
              shaders );
    }
    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename MAXCOUNT_TYPE = GLsizei ,
      typename COUNT_TYPE    = GLsizei*,
      typename SHADERS_TYPE  = GLuint* >
    inline std::shared_ptr<GetAttachedShaders<
      PROGRAM_TYPE ,
      MAXCOUNT_TYPE,
      COUNT_TYPE   ,
      SHADERS_TYPE >> sharedGetAttachedShaders(
        PROGRAM_TYPE  const&program ,
        MAXCOUNT_TYPE const&maxCount,
        COUNT_TYPE    const&count   ,
        SHADERS_TYPE  const&shaders ){
        return std::make_shared<GetAttachedShaders<
          PROGRAM_TYPE ,
          MAXCOUNT_TYPE,
          COUNT_TYPE   ,
          SHADERS_TYPE >>(
              program ,
              maxCount,
              count   ,
              shaders );
    }

    template<
      typename RET_TYPE          = GLboolean,
      typename RENDERBUFFER_TYPE = GLuint   >
    inline IsRenderbuffer<
      RET_TYPE         ,
      RENDERBUFFER_TYPE>* newIsRenderbuffer(
        RET_TYPE          const&ret         ,
        RENDERBUFFER_TYPE const&renderbuffer){
        return new IsRenderbuffer<
          RET_TYPE         ,
          RENDERBUFFER_TYPE>(
              ret         ,
              renderbuffer);
    }
    template<
      typename RET_TYPE          = GLboolean,
      typename RENDERBUFFER_TYPE = GLuint   >
    inline std::shared_ptr<IsRenderbuffer<
      RET_TYPE         ,
      RENDERBUFFER_TYPE>> sharedIsRenderbuffer(
        RET_TYPE          const&ret         ,
        RENDERBUFFER_TYPE const&renderbuffer){
        return std::make_shared<IsRenderbuffer<
          RET_TYPE         ,
          RENDERBUFFER_TYPE>>(
              ret         ,
              renderbuffer);
    }

    template<
      typename PROGRAM_TYPE  = GLuint       ,
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline ProgramUniform3uiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform3uiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform3uiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint       ,
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline std::shared_ptr<ProgramUniform3uiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform3uiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform3uiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename FIRST_TYPE   = GLuint         ,
      typename COUNT_TYPE   = GLsizei        ,
      typename BUFFERS_TYPE = const GLuint*  ,
      typename OFFSETS_TYPE = const GLintptr*,
      typename STRIDES_TYPE = const GLsizei* >
    inline BindVertexBuffers<
      FIRST_TYPE  ,
      COUNT_TYPE  ,
      BUFFERS_TYPE,
      OFFSETS_TYPE,
      STRIDES_TYPE>* newBindVertexBuffers(
        FIRST_TYPE   const&first  ,
        COUNT_TYPE   const&count  ,
        BUFFERS_TYPE const&buffers,
        OFFSETS_TYPE const&offsets,
        STRIDES_TYPE const&strides){
        return new BindVertexBuffers<
          FIRST_TYPE  ,
          COUNT_TYPE  ,
          BUFFERS_TYPE,
          OFFSETS_TYPE,
          STRIDES_TYPE>(
              first  ,
              count  ,
              buffers,
              offsets,
              strides);
    }
    template<
      typename FIRST_TYPE   = GLuint         ,
      typename COUNT_TYPE   = GLsizei        ,
      typename BUFFERS_TYPE = const GLuint*  ,
      typename OFFSETS_TYPE = const GLintptr*,
      typename STRIDES_TYPE = const GLsizei* >
    inline std::shared_ptr<BindVertexBuffers<
      FIRST_TYPE  ,
      COUNT_TYPE  ,
      BUFFERS_TYPE,
      OFFSETS_TYPE,
      STRIDES_TYPE>> sharedBindVertexBuffers(
        FIRST_TYPE   const&first  ,
        COUNT_TYPE   const&count  ,
        BUFFERS_TYPE const&buffers,
        OFFSETS_TYPE const&offsets,
        STRIDES_TYPE const&strides){
        return std::make_shared<BindVertexBuffers<
          FIRST_TYPE  ,
          COUNT_TYPE  ,
          BUFFERS_TYPE,
          OFFSETS_TYPE,
          STRIDES_TYPE>>(
              first  ,
              count  ,
              buffers,
              offsets,
              strides);
    }

    template<
      typename RET_TYPE    = void*     ,
      typename TARGET_TYPE = GLenum    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr,
      typename ACCESS_TYPE = GLbitfield>
    inline MapBufferRange<
      RET_TYPE   ,
      TARGET_TYPE,
      OFFSET_TYPE,
      LENGTH_TYPE,
      ACCESS_TYPE>* newMapBufferRange(
        RET_TYPE    const&ret   ,
        TARGET_TYPE const&target,
        OFFSET_TYPE const&offset,
        LENGTH_TYPE const&length,
        ACCESS_TYPE const&access){
        return new MapBufferRange<
          RET_TYPE   ,
          TARGET_TYPE,
          OFFSET_TYPE,
          LENGTH_TYPE,
          ACCESS_TYPE>(
              ret   ,
              target,
              offset,
              length,
              access);
    }
    template<
      typename RET_TYPE    = void*     ,
      typename TARGET_TYPE = GLenum    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr,
      typename ACCESS_TYPE = GLbitfield>
    inline std::shared_ptr<MapBufferRange<
      RET_TYPE   ,
      TARGET_TYPE,
      OFFSET_TYPE,
      LENGTH_TYPE,
      ACCESS_TYPE>> sharedMapBufferRange(
        RET_TYPE    const&ret   ,
        TARGET_TYPE const&target,
        OFFSET_TYPE const&offset,
        LENGTH_TYPE const&length,
        ACCESS_TYPE const&access){
        return std::make_shared<MapBufferRange<
          RET_TYPE   ,
          TARGET_TYPE,
          OFFSET_TYPE,
          LENGTH_TYPE,
          ACCESS_TYPE>>(
              ret   ,
              target,
              offset,
              length,
              access);
    }

    template<
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr,
      typename DATA_TYPE   = void*     >
    inline GetNamedBufferSubData<
      BUFFER_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  >* newGetNamedBufferSubData(
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ){
        return new GetNamedBufferSubData<
          BUFFER_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  >(
              buffer,
              offset,
              size  ,
              data  );
    }
    template<
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr,
      typename DATA_TYPE   = void*     >
    inline std::shared_ptr<GetNamedBufferSubData<
      BUFFER_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  >> sharedGetNamedBufferSubData(
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ){
        return std::make_shared<GetNamedBufferSubData<
          BUFFER_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  >>(
              buffer,
              offset,
              size  ,
              data  );
    }

    template<
      typename INDEX_TYPE = GLuint>
    inline DisableVertexAttribArray<
      INDEX_TYPE>* newDisableVertexAttribArray(
        INDEX_TYPE const&index){
        return new DisableVertexAttribArray<
          INDEX_TYPE>(
              index);
    }
    template<
      typename INDEX_TYPE = GLuint>
    inline std::shared_ptr<DisableVertexAttribArray<
      INDEX_TYPE>> sharedDisableVertexAttribArray(
        INDEX_TYPE const&index){
        return std::make_shared<DisableVertexAttribArray<
          INDEX_TYPE>>(
              index);
    }

    template<
      typename PROGRAM_TYPE  = GLuint      ,
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline ProgramUniform2iv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform2iv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform2iv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint      ,
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline std::shared_ptr<ProgramUniform2iv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform2iv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform2iv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetQueryiv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetQueryiv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetQueryiv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetQueryiv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetQueryiv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetQueryiv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename XFB_TYPE   = GLuint,
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint*>
    inline GetTransformFeedbackiv<
      XFB_TYPE  ,
      PNAME_TYPE,
      PARAM_TYPE>* newGetTransformFeedbackiv(
        XFB_TYPE   const&xfb  ,
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return new GetTransformFeedbackiv<
          XFB_TYPE  ,
          PNAME_TYPE,
          PARAM_TYPE>(
              xfb  ,
              pname,
              param);
    }
    template<
      typename XFB_TYPE   = GLuint,
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint*>
    inline std::shared_ptr<GetTransformFeedbackiv<
      XFB_TYPE  ,
      PNAME_TYPE,
      PARAM_TYPE>> sharedGetTransformFeedbackiv(
        XFB_TYPE   const&xfb  ,
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return std::make_shared<GetTransformFeedbackiv<
          XFB_TYPE  ,
          PNAME_TYPE,
          PARAM_TYPE>>(
              xfb  ,
              pname,
              param);
    }

    template<
      typename READFRAMEBUFFER_TYPE = GLuint    ,
      typename DRAWFRAMEBUFFER_TYPE = GLuint    ,
      typename SRCX0_TYPE           = GLint     ,
      typename SRCY0_TYPE           = GLint     ,
      typename SRCX1_TYPE           = GLint     ,
      typename SRCY1_TYPE           = GLint     ,
      typename DSTX0_TYPE           = GLint     ,
      typename DSTY0_TYPE           = GLint     ,
      typename DSTX1_TYPE           = GLint     ,
      typename DSTY1_TYPE           = GLint     ,
      typename MASK_TYPE            = GLbitfield,
      typename FILTER_TYPE          = GLenum    >
    inline BlitNamedFramebuffer<
      READFRAMEBUFFER_TYPE,
      DRAWFRAMEBUFFER_TYPE,
      SRCX0_TYPE          ,
      SRCY0_TYPE          ,
      SRCX1_TYPE          ,
      SRCY1_TYPE          ,
      DSTX0_TYPE          ,
      DSTY0_TYPE          ,
      DSTX1_TYPE          ,
      DSTY1_TYPE          ,
      MASK_TYPE           ,
      FILTER_TYPE         >* newBlitNamedFramebuffer(
        READFRAMEBUFFER_TYPE const&readFramebuffer,
        DRAWFRAMEBUFFER_TYPE const&drawFramebuffer,
        SRCX0_TYPE           const&srcX0          ,
        SRCY0_TYPE           const&srcY0          ,
        SRCX1_TYPE           const&srcX1          ,
        SRCY1_TYPE           const&srcY1          ,
        DSTX0_TYPE           const&dstX0          ,
        DSTY0_TYPE           const&dstY0          ,
        DSTX1_TYPE           const&dstX1          ,
        DSTY1_TYPE           const&dstY1          ,
        MASK_TYPE            const&mask           ,
        FILTER_TYPE          const&filter         ){
        return new BlitNamedFramebuffer<
          READFRAMEBUFFER_TYPE,
          DRAWFRAMEBUFFER_TYPE,
          SRCX0_TYPE          ,
          SRCY0_TYPE          ,
          SRCX1_TYPE          ,
          SRCY1_TYPE          ,
          DSTX0_TYPE          ,
          DSTY0_TYPE          ,
          DSTX1_TYPE          ,
          DSTY1_TYPE          ,
          MASK_TYPE           ,
          FILTER_TYPE         >(
              readFramebuffer,
              drawFramebuffer,
              srcX0          ,
              srcY0          ,
              srcX1          ,
              srcY1          ,
              dstX0          ,
              dstY0          ,
              dstX1          ,
              dstY1          ,
              mask           ,
              filter         );
    }
    template<
      typename READFRAMEBUFFER_TYPE = GLuint    ,
      typename DRAWFRAMEBUFFER_TYPE = GLuint    ,
      typename SRCX0_TYPE           = GLint     ,
      typename SRCY0_TYPE           = GLint     ,
      typename SRCX1_TYPE           = GLint     ,
      typename SRCY1_TYPE           = GLint     ,
      typename DSTX0_TYPE           = GLint     ,
      typename DSTY0_TYPE           = GLint     ,
      typename DSTX1_TYPE           = GLint     ,
      typename DSTY1_TYPE           = GLint     ,
      typename MASK_TYPE            = GLbitfield,
      typename FILTER_TYPE          = GLenum    >
    inline std::shared_ptr<BlitNamedFramebuffer<
      READFRAMEBUFFER_TYPE,
      DRAWFRAMEBUFFER_TYPE,
      SRCX0_TYPE          ,
      SRCY0_TYPE          ,
      SRCX1_TYPE          ,
      SRCY1_TYPE          ,
      DSTX0_TYPE          ,
      DSTY0_TYPE          ,
      DSTX1_TYPE          ,
      DSTY1_TYPE          ,
      MASK_TYPE           ,
      FILTER_TYPE         >> sharedBlitNamedFramebuffer(
        READFRAMEBUFFER_TYPE const&readFramebuffer,
        DRAWFRAMEBUFFER_TYPE const&drawFramebuffer,
        SRCX0_TYPE           const&srcX0          ,
        SRCY0_TYPE           const&srcY0          ,
        SRCX1_TYPE           const&srcX1          ,
        SRCY1_TYPE           const&srcY1          ,
        DSTX0_TYPE           const&dstX0          ,
        DSTY0_TYPE           const&dstY0          ,
        DSTX1_TYPE           const&dstX1          ,
        DSTY1_TYPE           const&dstY1          ,
        MASK_TYPE            const&mask           ,
        FILTER_TYPE          const&filter         ){
        return std::make_shared<BlitNamedFramebuffer<
          READFRAMEBUFFER_TYPE,
          DRAWFRAMEBUFFER_TYPE,
          SRCX0_TYPE          ,
          SRCY0_TYPE          ,
          SRCX1_TYPE          ,
          SRCY1_TYPE          ,
          DSTX0_TYPE          ,
          DSTY0_TYPE          ,
          DSTX1_TYPE          ,
          DSTY1_TYPE          ,
          MASK_TYPE           ,
          FILTER_TYPE         >>(
              readFramebuffer,
              drawFramebuffer,
              srcX0          ,
              srcY0          ,
              srcX1          ,
              srcY1          ,
              dstX0          ,
              dstY0          ,
              dstX1          ,
              dstY1          ,
              mask           ,
              filter         );
    }

    template<
      typename VAOBJ_TYPE          = GLuint,
      typename ATTRIBINDEX_TYPE    = GLuint,
      typename SIZE_TYPE           = GLint ,
      typename TYPE_TYPE           = GLenum,
      typename RELATIVEOFFSET_TYPE = GLuint>
    inline VertexArrayAttribLFormat<
      VAOBJ_TYPE         ,
      ATTRIBINDEX_TYPE   ,
      SIZE_TYPE          ,
      TYPE_TYPE          ,
      RELATIVEOFFSET_TYPE>* newVertexArrayAttribLFormat(
        VAOBJ_TYPE          const&vaobj         ,
        ATTRIBINDEX_TYPE    const&attribindex   ,
        SIZE_TYPE           const&size          ,
        TYPE_TYPE           const&type          ,
        RELATIVEOFFSET_TYPE const&relativeoffset){
        return new VertexArrayAttribLFormat<
          VAOBJ_TYPE         ,
          ATTRIBINDEX_TYPE   ,
          SIZE_TYPE          ,
          TYPE_TYPE          ,
          RELATIVEOFFSET_TYPE>(
              vaobj         ,
              attribindex   ,
              size          ,
              type          ,
              relativeoffset);
    }
    template<
      typename VAOBJ_TYPE          = GLuint,
      typename ATTRIBINDEX_TYPE    = GLuint,
      typename SIZE_TYPE           = GLint ,
      typename TYPE_TYPE           = GLenum,
      typename RELATIVEOFFSET_TYPE = GLuint>
    inline std::shared_ptr<VertexArrayAttribLFormat<
      VAOBJ_TYPE         ,
      ATTRIBINDEX_TYPE   ,
      SIZE_TYPE          ,
      TYPE_TYPE          ,
      RELATIVEOFFSET_TYPE>> sharedVertexArrayAttribLFormat(
        VAOBJ_TYPE          const&vaobj         ,
        ATTRIBINDEX_TYPE    const&attribindex   ,
        SIZE_TYPE           const&size          ,
        TYPE_TYPE           const&type          ,
        RELATIVEOFFSET_TYPE const&relativeoffset){
        return std::make_shared<VertexArrayAttribLFormat<
          VAOBJ_TYPE         ,
          ATTRIBINDEX_TYPE   ,
          SIZE_TYPE          ,
          TYPE_TYPE          ,
          RELATIVEOFFSET_TYPE>>(
              vaobj         ,
              attribindex   ,
              size          ,
              type          ,
              relativeoffset);
    }

    template<
      typename TARGET_TYPE = GLenum ,
      typename N_TYPE      = GLsizei,
      typename IDS_TYPE    = GLuint*>
    inline CreateQueries<
      TARGET_TYPE,
      N_TYPE     ,
      IDS_TYPE   >* newCreateQueries(
        TARGET_TYPE const&target,
        N_TYPE      const&n     ,
        IDS_TYPE    const&ids   ){
        return new CreateQueries<
          TARGET_TYPE,
          N_TYPE     ,
          IDS_TYPE   >(
              target,
              n     ,
              ids   );
    }
    template<
      typename TARGET_TYPE = GLenum ,
      typename N_TYPE      = GLsizei,
      typename IDS_TYPE    = GLuint*>
    inline std::shared_ptr<CreateQueries<
      TARGET_TYPE,
      N_TYPE     ,
      IDS_TYPE   >> sharedCreateQueries(
        TARGET_TYPE const&target,
        N_TYPE      const&n     ,
        IDS_TYPE    const&ids   ){
        return std::make_shared<CreateQueries<
          TARGET_TYPE,
          N_TYPE     ,
          IDS_TYPE   >>(
              target,
              n     ,
              ids   );
    }

    template<
      typename SAMPLER_TYPE = GLuint  ,
      typename PNAME_TYPE   = GLenum  ,
      typename PARAMS_TYPE  = GLfloat*>
    inline GetSamplerParameterfv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newGetSamplerParameterfv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new GetSamplerParameterfv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              sampler,
              pname  ,
              params );
    }
    template<
      typename SAMPLER_TYPE = GLuint  ,
      typename PNAME_TYPE   = GLenum  ,
      typename PARAMS_TYPE  = GLfloat*>
    inline std::shared_ptr<GetSamplerParameterfv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedGetSamplerParameterfv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<GetSamplerParameterfv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              sampler,
              pname  ,
              params );
    }

    template<
      typename PROGRAM_TYPE             = GLuint,
      typename STORAGEBLOCKINDEX_TYPE   = GLuint,
      typename STORAGEBLOCKBINDING_TYPE = GLuint>
    inline ShaderStorageBlockBinding<
      PROGRAM_TYPE            ,
      STORAGEBLOCKINDEX_TYPE  ,
      STORAGEBLOCKBINDING_TYPE>* newShaderStorageBlockBinding(
        PROGRAM_TYPE             const&program            ,
        STORAGEBLOCKINDEX_TYPE   const&storageBlockIndex  ,
        STORAGEBLOCKBINDING_TYPE const&storageBlockBinding){
        return new ShaderStorageBlockBinding<
          PROGRAM_TYPE            ,
          STORAGEBLOCKINDEX_TYPE  ,
          STORAGEBLOCKBINDING_TYPE>(
              program            ,
              storageBlockIndex  ,
              storageBlockBinding);
    }
    template<
      typename PROGRAM_TYPE             = GLuint,
      typename STORAGEBLOCKINDEX_TYPE   = GLuint,
      typename STORAGEBLOCKBINDING_TYPE = GLuint>
    inline std::shared_ptr<ShaderStorageBlockBinding<
      PROGRAM_TYPE            ,
      STORAGEBLOCKINDEX_TYPE  ,
      STORAGEBLOCKBINDING_TYPE>> sharedShaderStorageBlockBinding(
        PROGRAM_TYPE             const&program            ,
        STORAGEBLOCKINDEX_TYPE   const&storageBlockIndex  ,
        STORAGEBLOCKBINDING_TYPE const&storageBlockBinding){
        return std::make_shared<ShaderStorageBlockBinding<
          PROGRAM_TYPE            ,
          STORAGEBLOCKINDEX_TYPE  ,
          STORAGEBLOCKBINDING_TYPE>>(
              program            ,
              storageBlockIndex  ,
              storageBlockBinding);
    }

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline ProgramUniformMatrix4x2dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix4x2dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix4x2dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<ProgramUniformMatrix4x2dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix4x2dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix4x2dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename PROGRAM_TYPE        = GLuint             ,
      typename UNIFORMCOUNT_TYPE   = GLsizei            ,
      typename UNIFORMNAMES_TYPE   = const GLchar*const*,
      typename UNIFORMINDICES_TYPE = GLuint*            >
    inline GetUniformIndices<
      PROGRAM_TYPE       ,
      UNIFORMCOUNT_TYPE  ,
      UNIFORMNAMES_TYPE  ,
      UNIFORMINDICES_TYPE>* newGetUniformIndices(
        PROGRAM_TYPE        const&program       ,
        UNIFORMCOUNT_TYPE   const&uniformCount  ,
        UNIFORMNAMES_TYPE   const&uniformNames  ,
        UNIFORMINDICES_TYPE const&uniformIndices){
        return new GetUniformIndices<
          PROGRAM_TYPE       ,
          UNIFORMCOUNT_TYPE  ,
          UNIFORMNAMES_TYPE  ,
          UNIFORMINDICES_TYPE>(
              program       ,
              uniformCount  ,
              uniformNames  ,
              uniformIndices);
    }
    template<
      typename PROGRAM_TYPE        = GLuint             ,
      typename UNIFORMCOUNT_TYPE   = GLsizei            ,
      typename UNIFORMNAMES_TYPE   = const GLchar*const*,
      typename UNIFORMINDICES_TYPE = GLuint*            >
    inline std::shared_ptr<GetUniformIndices<
      PROGRAM_TYPE       ,
      UNIFORMCOUNT_TYPE  ,
      UNIFORMNAMES_TYPE  ,
      UNIFORMINDICES_TYPE>> sharedGetUniformIndices(
        PROGRAM_TYPE        const&program       ,
        UNIFORMCOUNT_TYPE   const&uniformCount  ,
        UNIFORMNAMES_TYPE   const&uniformNames  ,
        UNIFORMINDICES_TYPE const&uniformIndices){
        return std::make_shared<GetUniformIndices<
          PROGRAM_TYPE       ,
          UNIFORMCOUNT_TYPE  ,
          UNIFORMNAMES_TYPE  ,
          UNIFORMINDICES_TYPE>>(
              program       ,
              uniformCount  ,
              uniformNames  ,
              uniformIndices);
    }

    template<
      typename RET_TYPE    = GLboolean,
      typename SHADER_TYPE = GLuint   >
    inline IsShader<
      RET_TYPE   ,
      SHADER_TYPE>* newIsShader(
        RET_TYPE    const&ret   ,
        SHADER_TYPE const&shader){
        return new IsShader<
          RET_TYPE   ,
          SHADER_TYPE>(
              ret   ,
              shader);
    }
    template<
      typename RET_TYPE    = GLboolean,
      typename SHADER_TYPE = GLuint   >
    inline std::shared_ptr<IsShader<
      RET_TYPE   ,
      SHADER_TYPE>> sharedIsShader(
        RET_TYPE    const&ret   ,
        SHADER_TYPE const&shader){
        return std::make_shared<IsShader<
          RET_TYPE   ,
          SHADER_TYPE>>(
              ret   ,
              shader);
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLubyte*>
    inline VertexAttribI4ubv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribI4ubv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribI4ubv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLubyte*>
    inline std::shared_ptr<VertexAttribI4ubv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribI4ubv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribI4ubv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint,
      typename ID_TYPE     = GLuint>
    inline BeginQueryIndexed<
      TARGET_TYPE,
      INDEX_TYPE ,
      ID_TYPE    >* newBeginQueryIndexed(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        ID_TYPE     const&id    ){
        return new BeginQueryIndexed<
          TARGET_TYPE,
          INDEX_TYPE ,
          ID_TYPE    >(
              target,
              index ,
              id    );
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint,
      typename ID_TYPE     = GLuint>
    inline std::shared_ptr<BeginQueryIndexed<
      TARGET_TYPE,
      INDEX_TYPE ,
      ID_TYPE    >> sharedBeginQueryIndexed(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        ID_TYPE     const&id    ){
        return std::make_shared<BeginQueryIndexed<
          TARGET_TYPE,
          INDEX_TYPE ,
          ID_TYPE    >>(
              target,
              index ,
              id    );
    }

    template<
      typename PNAME_TYPE  = GLenum      ,
      typename PARAMS_TYPE = const GLint*>
    inline PointParameteriv<
      PNAME_TYPE ,
      PARAMS_TYPE>* newPointParameteriv(
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new PointParameteriv<
          PNAME_TYPE ,
          PARAMS_TYPE>(
              pname ,
              params);
    }
    template<
      typename PNAME_TYPE  = GLenum      ,
      typename PARAMS_TYPE = const GLint*>
    inline std::shared_ptr<PointParameteriv<
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedPointParameteriv(
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<PointParameteriv<
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              pname ,
              params);
    }

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline ProgramUniformMatrix2x3fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix2x3fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix2x3fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<ProgramUniformMatrix2x3fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix2x3fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix2x3fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename PROGRAM_TYPE        = GLuint       ,
      typename UNIFORMCOUNT_TYPE   = GLsizei      ,
      typename UNIFORMINDICES_TYPE = const GLuint*,
      typename PNAME_TYPE          = GLenum       ,
      typename PARAMS_TYPE         = GLint*       >
    inline GetActiveUniformsiv<
      PROGRAM_TYPE       ,
      UNIFORMCOUNT_TYPE  ,
      UNIFORMINDICES_TYPE,
      PNAME_TYPE         ,
      PARAMS_TYPE        >* newGetActiveUniformsiv(
        PROGRAM_TYPE        const&program       ,
        UNIFORMCOUNT_TYPE   const&uniformCount  ,
        UNIFORMINDICES_TYPE const&uniformIndices,
        PNAME_TYPE          const&pname         ,
        PARAMS_TYPE         const&params        ){
        return new GetActiveUniformsiv<
          PROGRAM_TYPE       ,
          UNIFORMCOUNT_TYPE  ,
          UNIFORMINDICES_TYPE,
          PNAME_TYPE         ,
          PARAMS_TYPE        >(
              program       ,
              uniformCount  ,
              uniformIndices,
              pname         ,
              params        );
    }
    template<
      typename PROGRAM_TYPE        = GLuint       ,
      typename UNIFORMCOUNT_TYPE   = GLsizei      ,
      typename UNIFORMINDICES_TYPE = const GLuint*,
      typename PNAME_TYPE          = GLenum       ,
      typename PARAMS_TYPE         = GLint*       >
    inline std::shared_ptr<GetActiveUniformsiv<
      PROGRAM_TYPE       ,
      UNIFORMCOUNT_TYPE  ,
      UNIFORMINDICES_TYPE,
      PNAME_TYPE         ,
      PARAMS_TYPE        >> sharedGetActiveUniformsiv(
        PROGRAM_TYPE        const&program       ,
        UNIFORMCOUNT_TYPE   const&uniformCount  ,
        UNIFORMINDICES_TYPE const&uniformIndices,
        PNAME_TYPE          const&pname         ,
        PARAMS_TYPE         const&params        ){
        return std::make_shared<GetActiveUniformsiv<
          PROGRAM_TYPE       ,
          UNIFORMCOUNT_TYPE  ,
          UNIFORMINDICES_TYPE,
          PNAME_TYPE         ,
          PARAMS_TYPE        >>(
              program       ,
              uniformCount  ,
              uniformIndices,
              pname         ,
              params        );
    }

    template<
      typename VAOBJ_TYPE        = GLuint,
      typename ATTRIBINDEX_TYPE  = GLuint,
      typename BINDINGINDEX_TYPE = GLuint>
    inline VertexArrayAttribBinding<
      VAOBJ_TYPE       ,
      ATTRIBINDEX_TYPE ,
      BINDINGINDEX_TYPE>* newVertexArrayAttribBinding(
        VAOBJ_TYPE        const&vaobj       ,
        ATTRIBINDEX_TYPE  const&attribindex ,
        BINDINGINDEX_TYPE const&bindingindex){
        return new VertexArrayAttribBinding<
          VAOBJ_TYPE       ,
          ATTRIBINDEX_TYPE ,
          BINDINGINDEX_TYPE>(
              vaobj       ,
              attribindex ,
              bindingindex);
    }
    template<
      typename VAOBJ_TYPE        = GLuint,
      typename ATTRIBINDEX_TYPE  = GLuint,
      typename BINDINGINDEX_TYPE = GLuint>
    inline std::shared_ptr<VertexArrayAttribBinding<
      VAOBJ_TYPE       ,
      ATTRIBINDEX_TYPE ,
      BINDINGINDEX_TYPE>> sharedVertexArrayAttribBinding(
        VAOBJ_TYPE        const&vaobj       ,
        ATTRIBINDEX_TYPE  const&attribindex ,
        BINDINGINDEX_TYPE const&bindingindex){
        return std::make_shared<VertexArrayAttribBinding<
          VAOBJ_TYPE       ,
          ATTRIBINDEX_TYPE ,
          BINDINGINDEX_TYPE>>(
              vaobj       ,
              attribindex ,
              bindingindex);
    }

    template<
      typename TEXTURE_TYPE        = GLuint ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei>
    inline TextureStorage1D<
      TEXTURE_TYPE       ,
      LEVELS_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         >* newTextureStorage1D(
        TEXTURE_TYPE        const&texture       ,
        LEVELS_TYPE         const&levels        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ){
        return new TextureStorage1D<
          TEXTURE_TYPE       ,
          LEVELS_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         >(
              texture       ,
              levels        ,
              internalformat,
              width         );
    }
    template<
      typename TEXTURE_TYPE        = GLuint ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei>
    inline std::shared_ptr<TextureStorage1D<
      TEXTURE_TYPE       ,
      LEVELS_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         >> sharedTextureStorage1D(
        TEXTURE_TYPE        const&texture       ,
        LEVELS_TYPE         const&levels        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ){
        return std::make_shared<TextureStorage1D<
          TEXTURE_TYPE       ,
          LEVELS_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         >>(
              texture       ,
              levels        ,
              internalformat,
              width         );
    }

    template<
      typename BARRIERS_TYPE = GLbitfield>
    inline MemoryBarrierByRegion<
      BARRIERS_TYPE>* newMemoryBarrierByRegion(
        BARRIERS_TYPE const&barriers){
        return new MemoryBarrierByRegion<
          BARRIERS_TYPE>(
              barriers);
    }
    template<
      typename BARRIERS_TYPE = GLbitfield>
    inline std::shared_ptr<MemoryBarrierByRegion<
      BARRIERS_TYPE>> sharedMemoryBarrierByRegion(
        BARRIERS_TYPE const&barriers){
        return std::make_shared<MemoryBarrierByRegion<
          BARRIERS_TYPE>>(
              barriers);
    }

    template<
      typename BUF_TYPE  = GLuint,
      typename MODE_TYPE = GLenum>
    inline BlendEquationi<
      BUF_TYPE ,
      MODE_TYPE>* newBlendEquationi(
        BUF_TYPE  const&buf ,
        MODE_TYPE const&mode){
        return new BlendEquationi<
          BUF_TYPE ,
          MODE_TYPE>(
              buf ,
              mode);
    }
    template<
      typename BUF_TYPE  = GLuint,
      typename MODE_TYPE = GLenum>
    inline std::shared_ptr<BlendEquationi<
      BUF_TYPE ,
      MODE_TYPE>> sharedBlendEquationi(
        BUF_TYPE  const&buf ,
        MODE_TYPE const&mode){
        return std::make_shared<BlendEquationi<
          BUF_TYPE ,
          MODE_TYPE>>(
              buf ,
              mode);
    }

    template<
      typename RET_TYPE     = GLint        ,
      typename PROGRAM_TYPE = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    inline GetAttribLocation<
      RET_TYPE    ,
      PROGRAM_TYPE,
      NAME_TYPE   >* newGetAttribLocation(
        RET_TYPE     const&ret    ,
        PROGRAM_TYPE const&program,
        NAME_TYPE    const&name   ){
        return new GetAttribLocation<
          RET_TYPE    ,
          PROGRAM_TYPE,
          NAME_TYPE   >(
              ret    ,
              program,
              name   );
    }
    template<
      typename RET_TYPE     = GLint        ,
      typename PROGRAM_TYPE = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    inline std::shared_ptr<GetAttribLocation<
      RET_TYPE    ,
      PROGRAM_TYPE,
      NAME_TYPE   >> sharedGetAttribLocation(
        RET_TYPE     const&ret    ,
        PROGRAM_TYPE const&program,
        NAME_TYPE    const&name   ){
        return std::make_shared<GetAttribLocation<
          RET_TYPE    ,
          PROGRAM_TYPE,
          NAME_TYPE   >>(
              ret    ,
              program,
              name   );
    }

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline VertexAttrib4dv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4dv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline std::shared_ptr<VertexAttrib4dv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4dv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename TEXTURE_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    inline GetTextureParameteriv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newGetTextureParameteriv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new GetTextureParameteriv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              texture,
              pname  ,
              params );
    }
    template<
      typename TEXTURE_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    inline std::shared_ptr<GetTextureParameteriv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedGetTextureParameteriv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<GetTextureParameteriv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              texture,
              pname  ,
              params );
    }

    template<
      typename PROGRAM_TYPE          = GLuint,
      typename PROGRAMINTERFACE_TYPE = GLenum,
      typename PNAME_TYPE            = GLenum,
      typename PARAMS_TYPE           = GLint*>
    inline GetProgramInterfaceiv<
      PROGRAM_TYPE         ,
      PROGRAMINTERFACE_TYPE,
      PNAME_TYPE           ,
      PARAMS_TYPE          >* newGetProgramInterfaceiv(
        PROGRAM_TYPE          const&program         ,
        PROGRAMINTERFACE_TYPE const&programInterface,
        PNAME_TYPE            const&pname           ,
        PARAMS_TYPE           const&params          ){
        return new GetProgramInterfaceiv<
          PROGRAM_TYPE         ,
          PROGRAMINTERFACE_TYPE,
          PNAME_TYPE           ,
          PARAMS_TYPE          >(
              program         ,
              programInterface,
              pname           ,
              params          );
    }
    template<
      typename PROGRAM_TYPE          = GLuint,
      typename PROGRAMINTERFACE_TYPE = GLenum,
      typename PNAME_TYPE            = GLenum,
      typename PARAMS_TYPE           = GLint*>
    inline std::shared_ptr<GetProgramInterfaceiv<
      PROGRAM_TYPE         ,
      PROGRAMINTERFACE_TYPE,
      PNAME_TYPE           ,
      PARAMS_TYPE          >> sharedGetProgramInterfaceiv(
        PROGRAM_TYPE          const&program         ,
        PROGRAMINTERFACE_TYPE const&programInterface,
        PNAME_TYPE            const&pname           ,
        PARAMS_TYPE           const&params          ){
        return std::make_shared<GetProgramInterfaceiv<
          PROGRAM_TYPE         ,
          PROGRAMINTERFACE_TYPE,
          PNAME_TYPE           ,
          PARAMS_TYPE          >>(
              program         ,
              programInterface,
              pname           ,
              params          );
    }

    template<
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline Uniform2dv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform2dv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform2dv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline std::shared_ptr<Uniform2dv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform2dv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform2dv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename RET_TYPE    = void* ,
      typename BUFFER_TYPE = GLuint,
      typename ACCESS_TYPE = GLenum>
    inline MapNamedBuffer<
      RET_TYPE   ,
      BUFFER_TYPE,
      ACCESS_TYPE>* newMapNamedBuffer(
        RET_TYPE    const&ret   ,
        BUFFER_TYPE const&buffer,
        ACCESS_TYPE const&access){
        return new MapNamedBuffer<
          RET_TYPE   ,
          BUFFER_TYPE,
          ACCESS_TYPE>(
              ret   ,
              buffer,
              access);
    }
    template<
      typename RET_TYPE    = void* ,
      typename BUFFER_TYPE = GLuint,
      typename ACCESS_TYPE = GLenum>
    inline std::shared_ptr<MapNamedBuffer<
      RET_TYPE   ,
      BUFFER_TYPE,
      ACCESS_TYPE>> sharedMapNamedBuffer(
        RET_TYPE    const&ret   ,
        BUFFER_TYPE const&buffer,
        ACCESS_TYPE const&access){
        return std::make_shared<MapNamedBuffer<
          RET_TYPE   ,
          BUFFER_TYPE,
          ACCESS_TYPE>>(
              ret   ,
              buffer,
              access);
    }

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble,
      typename Z_TYPE     = GLdouble,
      typename W_TYPE     = GLdouble>
    inline VertexAttrib4d<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >* newVertexAttrib4d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return new VertexAttrib4d<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }
    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble,
      typename Z_TYPE     = GLdouble,
      typename W_TYPE     = GLdouble>
    inline std::shared_ptr<VertexAttrib4d<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >> sharedVertexAttrib4d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return std::make_shared<VertexAttrib4d<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >>(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }

    template<
      typename INDEX_TYPE      = GLuint   ,
      typename TYPE_TYPE       = GLenum   ,
      typename NORMALIZED_TYPE = GLboolean,
      typename VALUE_TYPE      = GLuint   >
    inline VertexAttribP3ui<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >* newVertexAttribP3ui(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return new VertexAttribP3ui<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >(
              index     ,
              type      ,
              normalized,
              value     );
    }
    template<
      typename INDEX_TYPE      = GLuint   ,
      typename TYPE_TYPE       = GLenum   ,
      typename NORMALIZED_TYPE = GLboolean,
      typename VALUE_TYPE      = GLuint   >
    inline std::shared_ptr<VertexAttribP3ui<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >> sharedVertexAttribP3ui(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return std::make_shared<VertexAttribP3ui<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >>(
              index     ,
              type      ,
              normalized,
              value     );
    }

    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTARGET_TYPE  = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint >
    inline FramebufferTexture1D<
      TARGET_TYPE    ,
      ATTACHMENT_TYPE,
      TEXTARGET_TYPE ,
      TEXTURE_TYPE   ,
      LEVEL_TYPE     >* newFramebufferTexture1D(
        TARGET_TYPE     const&target    ,
        ATTACHMENT_TYPE const&attachment,
        TEXTARGET_TYPE  const&textarget ,
        TEXTURE_TYPE    const&texture   ,
        LEVEL_TYPE      const&level     ){
        return new FramebufferTexture1D<
          TARGET_TYPE    ,
          ATTACHMENT_TYPE,
          TEXTARGET_TYPE ,
          TEXTURE_TYPE   ,
          LEVEL_TYPE     >(
              target    ,
              attachment,
              textarget ,
              texture   ,
              level     );
    }
    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTARGET_TYPE  = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint >
    inline std::shared_ptr<FramebufferTexture1D<
      TARGET_TYPE    ,
      ATTACHMENT_TYPE,
      TEXTARGET_TYPE ,
      TEXTURE_TYPE   ,
      LEVEL_TYPE     >> sharedFramebufferTexture1D(
        TARGET_TYPE     const&target    ,
        ATTACHMENT_TYPE const&attachment,
        TEXTARGET_TYPE  const&textarget ,
        TEXTURE_TYPE    const&texture   ,
        LEVEL_TYPE      const&level     ){
        return std::make_shared<FramebufferTexture1D<
          TARGET_TYPE    ,
          ATTACHMENT_TYPE,
          TEXTARGET_TYPE ,
          TEXTURE_TYPE   ,
          LEVEL_TYPE     >>(
              target    ,
              attachment,
              textarget ,
              texture   ,
              level     );
    }

    template<
      typename TEXTURE_TYPE        = GLuint    ,
      typename INTERNALFORMAT_TYPE = GLenum    ,
      typename BUFFER_TYPE         = GLuint    ,
      typename OFFSET_TYPE         = GLintptr  ,
      typename SIZE_TYPE           = GLsizeiptr>
    inline TextureBufferRange<
      TEXTURE_TYPE       ,
      INTERNALFORMAT_TYPE,
      BUFFER_TYPE        ,
      OFFSET_TYPE        ,
      SIZE_TYPE          >* newTextureBufferRange(
        TEXTURE_TYPE        const&texture       ,
        INTERNALFORMAT_TYPE const&internalformat,
        BUFFER_TYPE         const&buffer        ,
        OFFSET_TYPE         const&offset        ,
        SIZE_TYPE           const&size          ){
        return new TextureBufferRange<
          TEXTURE_TYPE       ,
          INTERNALFORMAT_TYPE,
          BUFFER_TYPE        ,
          OFFSET_TYPE        ,
          SIZE_TYPE          >(
              texture       ,
              internalformat,
              buffer        ,
              offset        ,
              size          );
    }
    template<
      typename TEXTURE_TYPE        = GLuint    ,
      typename INTERNALFORMAT_TYPE = GLenum    ,
      typename BUFFER_TYPE         = GLuint    ,
      typename OFFSET_TYPE         = GLintptr  ,
      typename SIZE_TYPE           = GLsizeiptr>
    inline std::shared_ptr<TextureBufferRange<
      TEXTURE_TYPE       ,
      INTERNALFORMAT_TYPE,
      BUFFER_TYPE        ,
      OFFSET_TYPE        ,
      SIZE_TYPE          >> sharedTextureBufferRange(
        TEXTURE_TYPE        const&texture       ,
        INTERNALFORMAT_TYPE const&internalformat,
        BUFFER_TYPE         const&buffer        ,
        OFFSET_TYPE         const&offset        ,
        SIZE_TYPE           const&size          ){
        return std::make_shared<TextureBufferRange<
          TEXTURE_TYPE       ,
          INTERNALFORMAT_TYPE,
          BUFFER_TYPE        ,
          OFFSET_TYPE        ,
          SIZE_TYPE          >>(
              texture       ,
              internalformat,
              buffer        ,
              offset        ,
              size          );
    }

    template<
      typename PROGRAM_TYPE  = GLuint   ,
      typename LOCATION_TYPE = GLint    ,
      typename BUFSIZE_TYPE  = GLsizei  ,
      typename PARAMS_TYPE   = GLdouble*>
    inline GetnUniformdv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      BUFSIZE_TYPE ,
      PARAMS_TYPE  >* newGetnUniformdv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        BUFSIZE_TYPE  const&bufSize ,
        PARAMS_TYPE   const&params  ){
        return new GetnUniformdv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          BUFSIZE_TYPE ,
          PARAMS_TYPE  >(
              program ,
              location,
              bufSize ,
              params  );
    }
    template<
      typename PROGRAM_TYPE  = GLuint   ,
      typename LOCATION_TYPE = GLint    ,
      typename BUFSIZE_TYPE  = GLsizei  ,
      typename PARAMS_TYPE   = GLdouble*>
    inline std::shared_ptr<GetnUniformdv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      BUFSIZE_TYPE ,
      PARAMS_TYPE  >> sharedGetnUniformdv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        BUFSIZE_TYPE  const&bufSize ,
        PARAMS_TYPE   const&params  ){
        return std::make_shared<GetnUniformdv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          BUFSIZE_TYPE ,
          PARAMS_TYPE  >>(
              program ,
              location,
              bufSize ,
              params  );
    }

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint,
      typename V2_TYPE       = GLuint>
    inline ProgramUniform3ui<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >* newProgramUniform3ui(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return new ProgramUniform3ui<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >(
              program ,
              location,
              v0      ,
              v1      ,
              v2      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint,
      typename V2_TYPE       = GLuint>
    inline std::shared_ptr<ProgramUniform3ui<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >> sharedProgramUniform3ui(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return std::make_shared<ProgramUniform3ui<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >>(
              program ,
              location,
              v0      ,
              v1      ,
              v2      );
    }

    template<
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = void**>
    inline GetPointerv<
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetPointerv(
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetPointerv<
          PNAME_TYPE ,
          PARAMS_TYPE>(
              pname ,
              params);
    }
    template<
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = void**>
    inline std::shared_ptr<GetPointerv<
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetPointerv(
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetPointerv<
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              pname ,
              params);
    }

    template<
      typename BINDINGINDEX_TYPE = GLuint,
      typename DIVISOR_TYPE      = GLuint>
    inline VertexBindingDivisor<
      BINDINGINDEX_TYPE,
      DIVISOR_TYPE     >* newVertexBindingDivisor(
        BINDINGINDEX_TYPE const&bindingindex,
        DIVISOR_TYPE      const&divisor     ){
        return new VertexBindingDivisor<
          BINDINGINDEX_TYPE,
          DIVISOR_TYPE     >(
              bindingindex,
              divisor     );
    }
    template<
      typename BINDINGINDEX_TYPE = GLuint,
      typename DIVISOR_TYPE      = GLuint>
    inline std::shared_ptr<VertexBindingDivisor<
      BINDINGINDEX_TYPE,
      DIVISOR_TYPE     >> sharedVertexBindingDivisor(
        BINDINGINDEX_TYPE const&bindingindex,
        DIVISOR_TYPE      const&divisor     ){
        return std::make_shared<VertexBindingDivisor<
          BINDINGINDEX_TYPE,
          DIVISOR_TYPE     >>(
              bindingindex,
              divisor     );
    }

    template<
      typename FACTOR_TYPE = GLfloat,
      typename UNITS_TYPE  = GLfloat>
    inline PolygonOffset<
      FACTOR_TYPE,
      UNITS_TYPE >* newPolygonOffset(
        FACTOR_TYPE const&factor,
        UNITS_TYPE  const&units ){
        return new PolygonOffset<
          FACTOR_TYPE,
          UNITS_TYPE >(
              factor,
              units );
    }
    template<
      typename FACTOR_TYPE = GLfloat,
      typename UNITS_TYPE  = GLfloat>
    inline std::shared_ptr<PolygonOffset<
      FACTOR_TYPE,
      UNITS_TYPE >> sharedPolygonOffset(
        FACTOR_TYPE const&factor,
        UNITS_TYPE  const&units ){
        return std::make_shared<PolygonOffset<
          FACTOR_TYPE,
          UNITS_TYPE >>(
              factor,
              units );
    }

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename PARAMS_TYPE   = GLuint*>
    inline GetUniformuiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      PARAMS_TYPE  >* newGetUniformuiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        PARAMS_TYPE   const&params  ){
        return new GetUniformuiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          PARAMS_TYPE  >(
              program ,
              location,
              params  );
    }
    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename PARAMS_TYPE   = GLuint*>
    inline std::shared_ptr<GetUniformuiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      PARAMS_TYPE  >> sharedGetUniformuiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        PARAMS_TYPE   const&params  ){
        return std::make_shared<GetUniformuiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          PARAMS_TYPE  >>(
              program ,
              location,
              params  );
    }

    template<
      typename CAP_TYPE = GLenum>
    inline Enable<
      CAP_TYPE>* newEnable(
        CAP_TYPE const&cap){
        return new Enable<
          CAP_TYPE>(
              cap);
    }
    template<
      typename CAP_TYPE = GLenum>
    inline std::shared_ptr<Enable<
      CAP_TYPE>> sharedEnable(
        CAP_TYPE const&cap){
        return std::make_shared<Enable<
          CAP_TYPE>>(
              cap);
    }

    template<
      typename INDEX_TYPE  = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetVertexAttribIiv<
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetVertexAttribIiv(
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetVertexAttribIiv<
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              index ,
              pname ,
              params);
    }
    template<
      typename INDEX_TYPE  = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetVertexAttribIiv<
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetVertexAttribIiv(
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetVertexAttribIiv<
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              index ,
              pname ,
              params);
    }

    template<
      typename VAOBJ_TYPE        = GLuint,
      typename BINDINGINDEX_TYPE = GLuint,
      typename DIVISOR_TYPE      = GLuint>
    inline VertexArrayBindingDivisor<
      VAOBJ_TYPE       ,
      BINDINGINDEX_TYPE,
      DIVISOR_TYPE     >* newVertexArrayBindingDivisor(
        VAOBJ_TYPE        const&vaobj       ,
        BINDINGINDEX_TYPE const&bindingindex,
        DIVISOR_TYPE      const&divisor     ){
        return new VertexArrayBindingDivisor<
          VAOBJ_TYPE       ,
          BINDINGINDEX_TYPE,
          DIVISOR_TYPE     >(
              vaobj       ,
              bindingindex,
              divisor     );
    }
    template<
      typename VAOBJ_TYPE        = GLuint,
      typename BINDINGINDEX_TYPE = GLuint,
      typename DIVISOR_TYPE      = GLuint>
    inline std::shared_ptr<VertexArrayBindingDivisor<
      VAOBJ_TYPE       ,
      BINDINGINDEX_TYPE,
      DIVISOR_TYPE     >> sharedVertexArrayBindingDivisor(
        VAOBJ_TYPE        const&vaobj       ,
        BINDINGINDEX_TYPE const&bindingindex,
        DIVISOR_TYPE      const&divisor     ){
        return std::make_shared<VertexArrayBindingDivisor<
          VAOBJ_TYPE       ,
          BINDINGINDEX_TYPE,
          DIVISOR_TYPE     >>(
              vaobj       ,
              bindingindex,
              divisor     );
    }

    template<
      typename BUF_TYPE = GLenum>
    inline DrawBuffer<
      BUF_TYPE>* newDrawBuffer(
        BUF_TYPE const&buf){
        return new DrawBuffer<
          BUF_TYPE>(
              buf);
    }
    template<
      typename BUF_TYPE = GLenum>
    inline std::shared_ptr<DrawBuffer<
      BUF_TYPE>> sharedDrawBuffer(
        BUF_TYPE const&buf){
        return std::make_shared<DrawBuffer<
          BUF_TYPE>>(
              buf);
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint>
    inline EndQueryIndexed<
      TARGET_TYPE,
      INDEX_TYPE >* newEndQueryIndexed(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ){
        return new EndQueryIndexed<
          TARGET_TYPE,
          INDEX_TYPE >(
              target,
              index );
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint>
    inline std::shared_ptr<EndQueryIndexed<
      TARGET_TYPE,
      INDEX_TYPE >> sharedEndQueryIndexed(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ){
        return std::make_shared<EndQueryIndexed<
          TARGET_TYPE,
          INDEX_TYPE >>(
              target,
              index );
    }

    template<
      typename BUFFER_TYPE     = GLenum       ,
      typename DRAWBUFFER_TYPE = GLint        ,
      typename VALUE_TYPE      = const GLuint*>
    inline ClearBufferuiv<
      BUFFER_TYPE    ,
      DRAWBUFFER_TYPE,
      VALUE_TYPE     >* newClearBufferuiv(
        BUFFER_TYPE     const&buffer    ,
        DRAWBUFFER_TYPE const&drawbuffer,
        VALUE_TYPE      const&value     ){
        return new ClearBufferuiv<
          BUFFER_TYPE    ,
          DRAWBUFFER_TYPE,
          VALUE_TYPE     >(
              buffer    ,
              drawbuffer,
              value     );
    }
    template<
      typename BUFFER_TYPE     = GLenum       ,
      typename DRAWBUFFER_TYPE = GLint        ,
      typename VALUE_TYPE      = const GLuint*>
    inline std::shared_ptr<ClearBufferuiv<
      BUFFER_TYPE    ,
      DRAWBUFFER_TYPE,
      VALUE_TYPE     >> sharedClearBufferuiv(
        BUFFER_TYPE     const&buffer    ,
        DRAWBUFFER_TYPE const&drawbuffer,
        VALUE_TYPE      const&value     ){
        return std::make_shared<ClearBufferuiv<
          BUFFER_TYPE    ,
          DRAWBUFFER_TYPE,
          VALUE_TYPE     >>(
              buffer    ,
              drawbuffer,
              value     );
    }

    template<
      typename MODE_TYPE          = GLenum     ,
      typename COUNT_TYPE         = GLsizei    ,
      typename TYPE_TYPE          = GLenum     ,
      typename INDICES_TYPE       = const void*,
      typename INSTANCECOUNT_TYPE = GLsizei    >
    inline DrawElementsInstanced<
      MODE_TYPE         ,
      COUNT_TYPE        ,
      TYPE_TYPE         ,
      INDICES_TYPE      ,
      INSTANCECOUNT_TYPE>* newDrawElementsInstanced(
        MODE_TYPE          const&mode         ,
        COUNT_TYPE         const&count        ,
        TYPE_TYPE          const&type         ,
        INDICES_TYPE       const&indices      ,
        INSTANCECOUNT_TYPE const&instancecount){
        return new DrawElementsInstanced<
          MODE_TYPE         ,
          COUNT_TYPE        ,
          TYPE_TYPE         ,
          INDICES_TYPE      ,
          INSTANCECOUNT_TYPE>(
              mode         ,
              count        ,
              type         ,
              indices      ,
              instancecount);
    }
    template<
      typename MODE_TYPE          = GLenum     ,
      typename COUNT_TYPE         = GLsizei    ,
      typename TYPE_TYPE          = GLenum     ,
      typename INDICES_TYPE       = const void*,
      typename INSTANCECOUNT_TYPE = GLsizei    >
    inline std::shared_ptr<DrawElementsInstanced<
      MODE_TYPE         ,
      COUNT_TYPE        ,
      TYPE_TYPE         ,
      INDICES_TYPE      ,
      INSTANCECOUNT_TYPE>> sharedDrawElementsInstanced(
        MODE_TYPE          const&mode         ,
        COUNT_TYPE         const&count        ,
        TYPE_TYPE          const&type         ,
        INDICES_TYPE       const&indices      ,
        INSTANCECOUNT_TYPE const&instancecount){
        return std::make_shared<DrawElementsInstanced<
          MODE_TYPE         ,
          COUNT_TYPE        ,
          TYPE_TYPE         ,
          INDICES_TYPE      ,
          INSTANCECOUNT_TYPE>>(
              mode         ,
              count        ,
              type         ,
              indices      ,
              instancecount);
    }

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLint >
    inline ProgramUniform1i<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      >* newProgramUniform1i(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return new ProgramUniform1i<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      >(
              program ,
              location,
              v0      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLint >
    inline std::shared_ptr<ProgramUniform1i<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      >> sharedProgramUniform1i(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return std::make_shared<ProgramUniform1i<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      >>(
              program ,
              location,
              v0      );
    }

    template<
      typename PNAME_TYPE = GLenum,
      typename VALUE_TYPE = GLint >
    inline PatchParameteri<
      PNAME_TYPE,
      VALUE_TYPE>* newPatchParameteri(
        PNAME_TYPE const&pname,
        VALUE_TYPE const&value){
        return new PatchParameteri<
          PNAME_TYPE,
          VALUE_TYPE>(
              pname,
              value);
    }
    template<
      typename PNAME_TYPE = GLenum,
      typename VALUE_TYPE = GLint >
    inline std::shared_ptr<PatchParameteri<
      PNAME_TYPE,
      VALUE_TYPE>> sharedPatchParameteri(
        PNAME_TYPE const&pname,
        VALUE_TYPE const&value){
        return std::make_shared<PatchParameteri<
          PNAME_TYPE,
          VALUE_TYPE>>(
              pname,
              value);
    }

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename V0_TYPE       = GLdouble>
    inline ProgramUniform1d<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      >* newProgramUniform1d(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return new ProgramUniform1d<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      >(
              program ,
              location,
              v0      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename V0_TYPE       = GLdouble>
    inline std::shared_ptr<ProgramUniform1d<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      >> sharedProgramUniform1d(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return std::make_shared<ProgramUniform1d<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      >>(
              program ,
              location,
              v0      );
    }

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat>
    inline ProgramUniform1f<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      >* newProgramUniform1f(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return new ProgramUniform1f<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      >(
              program ,
              location,
              v0      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat>
    inline std::shared_ptr<ProgramUniform1f<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      >> sharedProgramUniform1f(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return std::make_shared<ProgramUniform1f<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      >>(
              program ,
              location,
              v0      );
    }

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename PNAME_TYPE       = GLenum,
      typename PARAM_TYPE       = GLint*>
    inline GetNamedFramebufferParameteriv<
      FRAMEBUFFER_TYPE,
      PNAME_TYPE      ,
      PARAM_TYPE      >* newGetNamedFramebufferParameteriv(
        FRAMEBUFFER_TYPE const&framebuffer,
        PNAME_TYPE       const&pname      ,
        PARAM_TYPE       const&param      ){
        return new GetNamedFramebufferParameteriv<
          FRAMEBUFFER_TYPE,
          PNAME_TYPE      ,
          PARAM_TYPE      >(
              framebuffer,
              pname      ,
              param      );
    }
    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename PNAME_TYPE       = GLenum,
      typename PARAM_TYPE       = GLint*>
    inline std::shared_ptr<GetNamedFramebufferParameteriv<
      FRAMEBUFFER_TYPE,
      PNAME_TYPE      ,
      PARAM_TYPE      >> sharedGetNamedFramebufferParameteriv(
        FRAMEBUFFER_TYPE const&framebuffer,
        PNAME_TYPE       const&pname      ,
        PARAM_TYPE       const&param      ){
        return std::make_shared<GetNamedFramebufferParameteriv<
          FRAMEBUFFER_TYPE,
          PNAME_TYPE      ,
          PARAM_TYPE      >>(
              framebuffer,
              pname      ,
              param      );
    }


    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetRenderbufferParameteriv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetRenderbufferParameteriv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetRenderbufferParameteriv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetRenderbufferParameteriv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetRenderbufferParameteriv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetRenderbufferParameteriv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename PROGRAM_TYPE  = GLuint      ,
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline ProgramUniform3iv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform3iv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform3iv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint      ,
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline std::shared_ptr<ProgramUniform3iv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform3iv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform3iv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename RET_TYPE        = GLuint  ,
      typename COUNT_TYPE      = GLuint  ,
      typename BUFSIZE_TYPE    = GLsizei ,
      typename SOURCES_TYPE    = GLenum* ,
      typename TYPES_TYPE      = GLenum* ,
      typename IDS_TYPE        = GLuint* ,
      typename SEVERITIES_TYPE = GLenum* ,
      typename LENGTHS_TYPE    = GLsizei*,
      typename MESSAGELOG_TYPE = GLchar* >
    inline GetDebugMessageLog<
      RET_TYPE       ,
      COUNT_TYPE     ,
      BUFSIZE_TYPE   ,
      SOURCES_TYPE   ,
      TYPES_TYPE     ,
      IDS_TYPE       ,
      SEVERITIES_TYPE,
      LENGTHS_TYPE   ,
      MESSAGELOG_TYPE>* newGetDebugMessageLog(
        RET_TYPE        const&ret       ,
        COUNT_TYPE      const&count     ,
        BUFSIZE_TYPE    const&bufSize   ,
        SOURCES_TYPE    const&sources   ,
        TYPES_TYPE      const&types     ,
        IDS_TYPE        const&ids       ,
        SEVERITIES_TYPE const&severities,
        LENGTHS_TYPE    const&lengths   ,
        MESSAGELOG_TYPE const&messageLog){
        return new GetDebugMessageLog<
          RET_TYPE       ,
          COUNT_TYPE     ,
          BUFSIZE_TYPE   ,
          SOURCES_TYPE   ,
          TYPES_TYPE     ,
          IDS_TYPE       ,
          SEVERITIES_TYPE,
          LENGTHS_TYPE   ,
          MESSAGELOG_TYPE>(
              ret       ,
              count     ,
              bufSize   ,
              sources   ,
              types     ,
              ids       ,
              severities,
              lengths   ,
              messageLog);
    }
    template<
      typename RET_TYPE        = GLuint  ,
      typename COUNT_TYPE      = GLuint  ,
      typename BUFSIZE_TYPE    = GLsizei ,
      typename SOURCES_TYPE    = GLenum* ,
      typename TYPES_TYPE      = GLenum* ,
      typename IDS_TYPE        = GLuint* ,
      typename SEVERITIES_TYPE = GLenum* ,
      typename LENGTHS_TYPE    = GLsizei*,
      typename MESSAGELOG_TYPE = GLchar* >
    inline std::shared_ptr<GetDebugMessageLog<
      RET_TYPE       ,
      COUNT_TYPE     ,
      BUFSIZE_TYPE   ,
      SOURCES_TYPE   ,
      TYPES_TYPE     ,
      IDS_TYPE       ,
      SEVERITIES_TYPE,
      LENGTHS_TYPE   ,
      MESSAGELOG_TYPE>> sharedGetDebugMessageLog(
        RET_TYPE        const&ret       ,
        COUNT_TYPE      const&count     ,
        BUFSIZE_TYPE    const&bufSize   ,
        SOURCES_TYPE    const&sources   ,
        TYPES_TYPE      const&types     ,
        IDS_TYPE        const&ids       ,
        SEVERITIES_TYPE const&severities,
        LENGTHS_TYPE    const&lengths   ,
        MESSAGELOG_TYPE const&messageLog){
        return std::make_shared<GetDebugMessageLog<
          RET_TYPE       ,
          COUNT_TYPE     ,
          BUFSIZE_TYPE   ,
          SOURCES_TYPE   ,
          TYPES_TYPE     ,
          IDS_TYPE       ,
          SEVERITIES_TYPE,
          LENGTHS_TYPE   ,
          MESSAGELOG_TYPE>>(
              ret       ,
              count     ,
              bufSize   ,
              sources   ,
              types     ,
              ids       ,
              severities,
              lengths   ,
              messageLog);
    }

    template<
      typename RENDERBUFFER_TYPE   = GLuint ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    inline NamedRenderbufferStorage<
      RENDERBUFFER_TYPE  ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >* newNamedRenderbufferStorage(
        RENDERBUFFER_TYPE   const&renderbuffer  ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return new NamedRenderbufferStorage<
          RENDERBUFFER_TYPE  ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >(
              renderbuffer  ,
              internalformat,
              width         ,
              height        );
    }
    template<
      typename RENDERBUFFER_TYPE   = GLuint ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    inline std::shared_ptr<NamedRenderbufferStorage<
      RENDERBUFFER_TYPE  ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >> sharedNamedRenderbufferStorage(
        RENDERBUFFER_TYPE   const&renderbuffer  ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return std::make_shared<NamedRenderbufferStorage<
          RENDERBUFFER_TYPE  ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >>(
              renderbuffer  ,
              internalformat,
              width         ,
              height        );
    }

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename ATTACHMENT_TYPE  = GLenum,
      typename PNAME_TYPE       = GLenum,
      typename PARAMS_TYPE      = GLint*>
    inline GetNamedFramebufferAttachmentParameteriv<
      FRAMEBUFFER_TYPE,
      ATTACHMENT_TYPE ,
      PNAME_TYPE      ,
      PARAMS_TYPE     >* newGetNamedFramebufferAttachmentParameteriv(
        FRAMEBUFFER_TYPE const&framebuffer,
        ATTACHMENT_TYPE  const&attachment ,
        PNAME_TYPE       const&pname      ,
        PARAMS_TYPE      const&params     ){
        return new GetNamedFramebufferAttachmentParameteriv<
          FRAMEBUFFER_TYPE,
          ATTACHMENT_TYPE ,
          PNAME_TYPE      ,
          PARAMS_TYPE     >(
              framebuffer,
              attachment ,
              pname      ,
              params     );
    }
    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename ATTACHMENT_TYPE  = GLenum,
      typename PNAME_TYPE       = GLenum,
      typename PARAMS_TYPE      = GLint*>
    inline std::shared_ptr<GetNamedFramebufferAttachmentParameteriv<
      FRAMEBUFFER_TYPE,
      ATTACHMENT_TYPE ,
      PNAME_TYPE      ,
      PARAMS_TYPE     >> sharedGetNamedFramebufferAttachmentParameteriv(
        FRAMEBUFFER_TYPE const&framebuffer,
        ATTACHMENT_TYPE  const&attachment ,
        PNAME_TYPE       const&pname      ,
        PARAMS_TYPE      const&params     ){
        return std::make_shared<GetNamedFramebufferAttachmentParameteriv<
          FRAMEBUFFER_TYPE,
          ATTACHMENT_TYPE ,
          PNAME_TYPE      ,
          PARAMS_TYPE     >>(
              framebuffer,
              attachment ,
              pname      ,
              params     );
    }

    template<
      typename INDEX_TYPE   = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename POINTER_TYPE = void**>
    inline GetVertexAttribPointerv<
      INDEX_TYPE  ,
      PNAME_TYPE  ,
      POINTER_TYPE>* newGetVertexAttribPointerv(
        INDEX_TYPE   const&index  ,
        PNAME_TYPE   const&pname  ,
        POINTER_TYPE const&pointer){
        return new GetVertexAttribPointerv<
          INDEX_TYPE  ,
          PNAME_TYPE  ,
          POINTER_TYPE>(
              index  ,
              pname  ,
              pointer);
    }
    template<
      typename INDEX_TYPE   = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename POINTER_TYPE = void**>
    inline std::shared_ptr<GetVertexAttribPointerv<
      INDEX_TYPE  ,
      PNAME_TYPE  ,
      POINTER_TYPE>> sharedGetVertexAttribPointerv(
        INDEX_TYPE   const&index  ,
        PNAME_TYPE   const&pname  ,
        POINTER_TYPE const&pointer){
        return std::make_shared<GetVertexAttribPointerv<
          INDEX_TYPE  ,
          PNAME_TYPE  ,
          POINTER_TYPE>>(
              index  ,
              pname  ,
              pointer);
    }

    template<
      typename RET_TYPE       = GLsync    ,
      typename CONDITION_TYPE = GLenum    ,
      typename FLAGS_TYPE     = GLbitfield>
    inline FenceSync<
      RET_TYPE      ,
      CONDITION_TYPE,
      FLAGS_TYPE    >* newFenceSync(
        RET_TYPE       const&ret      ,
        CONDITION_TYPE const&condition,
        FLAGS_TYPE     const&flags    ){
        return new FenceSync<
          RET_TYPE      ,
          CONDITION_TYPE,
          FLAGS_TYPE    >(
              ret      ,
              condition,
              flags    );
    }
    template<
      typename RET_TYPE       = GLsync    ,
      typename CONDITION_TYPE = GLenum    ,
      typename FLAGS_TYPE     = GLbitfield>
    inline std::shared_ptr<FenceSync<
      RET_TYPE      ,
      CONDITION_TYPE,
      FLAGS_TYPE    >> sharedFenceSync(
        RET_TYPE       const&ret      ,
        CONDITION_TYPE const&condition,
        FLAGS_TYPE     const&flags    ){
        return std::make_shared<FenceSync<
          RET_TYPE      ,
          CONDITION_TYPE,
          FLAGS_TYPE    >>(
              ret      ,
              condition,
              flags    );
    }

    template<
      typename N_TYPE      = GLsizei      ,
      typename ARRAYS_TYPE = const GLuint*>
    inline DeleteVertexArrays<
      N_TYPE     ,
      ARRAYS_TYPE>* newDeleteVertexArrays(
        N_TYPE      const&n     ,
        ARRAYS_TYPE const&arrays){
        return new DeleteVertexArrays<
          N_TYPE     ,
          ARRAYS_TYPE>(
              n     ,
              arrays);
    }
    template<
      typename N_TYPE      = GLsizei      ,
      typename ARRAYS_TYPE = const GLuint*>
    inline std::shared_ptr<DeleteVertexArrays<
      N_TYPE     ,
      ARRAYS_TYPE>> sharedDeleteVertexArrays(
        N_TYPE      const&n     ,
        ARRAYS_TYPE const&arrays){
        return std::make_shared<DeleteVertexArrays<
          N_TYPE     ,
          ARRAYS_TYPE>>(
              n     ,
              arrays);
    }

    template<
      typename MODE_TYPE          = GLenum     ,
      typename COUNT_TYPE         = GLsizei    ,
      typename TYPE_TYPE          = GLenum     ,
      typename INDICES_TYPE       = const void*,
      typename INSTANCECOUNT_TYPE = GLsizei    ,
      typename BASEVERTEX_TYPE    = GLint      ,
      typename BASEINSTANCE_TYPE  = GLuint     >
    inline DrawElementsInstancedBaseVertexBaseInstance<
      MODE_TYPE         ,
      COUNT_TYPE        ,
      TYPE_TYPE         ,
      INDICES_TYPE      ,
      INSTANCECOUNT_TYPE,
      BASEVERTEX_TYPE   ,
      BASEINSTANCE_TYPE >* newDrawElementsInstancedBaseVertexBaseInstance(
        MODE_TYPE          const&mode         ,
        COUNT_TYPE         const&count        ,
        TYPE_TYPE          const&type         ,
        INDICES_TYPE       const&indices      ,
        INSTANCECOUNT_TYPE const&instancecount,
        BASEVERTEX_TYPE    const&basevertex   ,
        BASEINSTANCE_TYPE  const&baseinstance ){
        return new DrawElementsInstancedBaseVertexBaseInstance<
          MODE_TYPE         ,
          COUNT_TYPE        ,
          TYPE_TYPE         ,
          INDICES_TYPE      ,
          INSTANCECOUNT_TYPE,
          BASEVERTEX_TYPE   ,
          BASEINSTANCE_TYPE >(
              mode         ,
              count        ,
              type         ,
              indices      ,
              instancecount,
              basevertex   ,
              baseinstance );
    }
    template<
      typename MODE_TYPE          = GLenum     ,
      typename COUNT_TYPE         = GLsizei    ,
      typename TYPE_TYPE          = GLenum     ,
      typename INDICES_TYPE       = const void*,
      typename INSTANCECOUNT_TYPE = GLsizei    ,
      typename BASEVERTEX_TYPE    = GLint      ,
      typename BASEINSTANCE_TYPE  = GLuint     >
    inline std::shared_ptr<DrawElementsInstancedBaseVertexBaseInstance<
      MODE_TYPE         ,
      COUNT_TYPE        ,
      TYPE_TYPE         ,
      INDICES_TYPE      ,
      INSTANCECOUNT_TYPE,
      BASEVERTEX_TYPE   ,
      BASEINSTANCE_TYPE >> sharedDrawElementsInstancedBaseVertexBaseInstance(
        MODE_TYPE          const&mode         ,
        COUNT_TYPE         const&count        ,
        TYPE_TYPE          const&type         ,
        INDICES_TYPE       const&indices      ,
        INSTANCECOUNT_TYPE const&instancecount,
        BASEVERTEX_TYPE    const&basevertex   ,
        BASEINSTANCE_TYPE  const&baseinstance ){
        return std::make_shared<DrawElementsInstancedBaseVertexBaseInstance<
          MODE_TYPE         ,
          COUNT_TYPE        ,
          TYPE_TYPE         ,
          INDICES_TYPE      ,
          INSTANCECOUNT_TYPE,
          BASEVERTEX_TYPE   ,
          BASEINSTANCE_TYPE >>(
              mode         ,
              count        ,
              type         ,
              indices      ,
              instancecount,
              basevertex   ,
              baseinstance );
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    inline VertexAttrib3sv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib3sv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib3sv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    inline std::shared_ptr<VertexAttrib3sv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib3sv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib3sv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLshort,
      typename Y_TYPE     = GLshort,
      typename Z_TYPE     = GLshort,
      typename W_TYPE     = GLshort>
    inline VertexAttrib4s<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >* newVertexAttrib4s(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return new VertexAttrib4s<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }
    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLshort,
      typename Y_TYPE     = GLshort,
      typename Z_TYPE     = GLshort,
      typename W_TYPE     = GLshort>
    inline std::shared_ptr<VertexAttrib4s<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >> sharedVertexAttrib4s(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return std::make_shared<VertexAttrib4s<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >>(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }

    template<
      typename PIPELINE_TYPE = GLuint>
    inline ValidateProgramPipeline<
      PIPELINE_TYPE>* newValidateProgramPipeline(
        PIPELINE_TYPE const&pipeline){
        return new ValidateProgramPipeline<
          PIPELINE_TYPE>(
              pipeline);
    }
    template<
      typename PIPELINE_TYPE = GLuint>
    inline std::shared_ptr<ValidateProgramPipeline<
      PIPELINE_TYPE>> sharedValidateProgramPipeline(
        PIPELINE_TYPE const&pipeline){
        return std::make_shared<ValidateProgramPipeline<
          PIPELINE_TYPE>>(
              pipeline);
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename LEVEL_TYPE  = GLint ,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetTexLevelParameteriv<
      TARGET_TYPE,
      LEVEL_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetTexLevelParameteriv(
        TARGET_TYPE const&target,
        LEVEL_TYPE  const&level ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetTexLevelParameteriv<
          TARGET_TYPE,
          LEVEL_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              level ,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename LEVEL_TYPE  = GLint ,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetTexLevelParameteriv<
      TARGET_TYPE,
      LEVEL_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetTexLevelParameteriv(
        TARGET_TYPE const&target,
        LEVEL_TYPE  const&level ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetTexLevelParameteriv<
          TARGET_TYPE,
          LEVEL_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              level ,
              pname ,
              params);
    }

    template<
      typename FIRST_TYPE = GLuint      ,
      typename COUNT_TYPE = GLsizei     ,
      typename V_TYPE     = const GLint*>
    inline ScissorArrayv<
      FIRST_TYPE,
      COUNT_TYPE,
      V_TYPE    >* newScissorArrayv(
        FIRST_TYPE const&first,
        COUNT_TYPE const&count,
        V_TYPE     const&v    ){
        return new ScissorArrayv<
          FIRST_TYPE,
          COUNT_TYPE,
          V_TYPE    >(
              first,
              count,
              v    );
    }
    template<
      typename FIRST_TYPE = GLuint      ,
      typename COUNT_TYPE = GLsizei     ,
      typename V_TYPE     = const GLint*>
    inline std::shared_ptr<ScissorArrayv<
      FIRST_TYPE,
      COUNT_TYPE,
      V_TYPE    >> sharedScissorArrayv(
        FIRST_TYPE const&first,
        COUNT_TYPE const&count,
        V_TYPE     const&v    ){
        return std::make_shared<ScissorArrayv<
          FIRST_TYPE,
          COUNT_TYPE,
          V_TYPE    >>(
              first,
              count,
              v    );
    }

    template<
      typename TARGET_TYPE               = GLenum   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename DEPTH_TYPE                = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    inline TexStorage3DMultisample<
      TARGET_TYPE              ,
      SAMPLES_TYPE             ,
      INTERNALFORMAT_TYPE      ,
      WIDTH_TYPE               ,
      HEIGHT_TYPE              ,
      DEPTH_TYPE               ,
      FIXEDSAMPLELOCATIONS_TYPE>* newTexStorage3DMultisample(
        TARGET_TYPE               const&target              ,
        SAMPLES_TYPE              const&samples             ,
        INTERNALFORMAT_TYPE       const&internalformat      ,
        WIDTH_TYPE                const&width               ,
        HEIGHT_TYPE               const&height              ,
        DEPTH_TYPE                const&depth               ,
        FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
        return new TexStorage3DMultisample<
          TARGET_TYPE              ,
          SAMPLES_TYPE             ,
          INTERNALFORMAT_TYPE      ,
          WIDTH_TYPE               ,
          HEIGHT_TYPE              ,
          DEPTH_TYPE               ,
          FIXEDSAMPLELOCATIONS_TYPE>(
              target              ,
              samples             ,
              internalformat      ,
              width               ,
              height              ,
              depth               ,
              fixedsamplelocations);
    }
    template<
      typename TARGET_TYPE               = GLenum   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename DEPTH_TYPE                = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    inline std::shared_ptr<TexStorage3DMultisample<
      TARGET_TYPE              ,
      SAMPLES_TYPE             ,
      INTERNALFORMAT_TYPE      ,
      WIDTH_TYPE               ,
      HEIGHT_TYPE              ,
      DEPTH_TYPE               ,
      FIXEDSAMPLELOCATIONS_TYPE>> sharedTexStorage3DMultisample(
        TARGET_TYPE               const&target              ,
        SAMPLES_TYPE              const&samples             ,
        INTERNALFORMAT_TYPE       const&internalformat      ,
        WIDTH_TYPE                const&width               ,
        HEIGHT_TYPE               const&height              ,
        DEPTH_TYPE                const&depth               ,
        FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
        return std::make_shared<TexStorage3DMultisample<
          TARGET_TYPE              ,
          SAMPLES_TYPE             ,
          INTERNALFORMAT_TYPE      ,
          WIDTH_TYPE               ,
          HEIGHT_TYPE              ,
          DEPTH_TYPE               ,
          FIXEDSAMPLELOCATIONS_TYPE>>(
              target              ,
              samples             ,
              internalformat      ,
              width               ,
              height              ,
              depth               ,
              fixedsamplelocations);
    }

    template<
      typename FACE_TYPE = GLenum,
      typename FUNC_TYPE = GLenum,
      typename REF_TYPE  = GLint ,
      typename MASK_TYPE = GLuint>
    inline StencilFuncSeparate<
      FACE_TYPE,
      FUNC_TYPE,
      REF_TYPE ,
      MASK_TYPE>* newStencilFuncSeparate(
        FACE_TYPE const&face,
        FUNC_TYPE const&func,
        REF_TYPE  const&ref ,
        MASK_TYPE const&mask){
        return new StencilFuncSeparate<
          FACE_TYPE,
          FUNC_TYPE,
          REF_TYPE ,
          MASK_TYPE>(
              face,
              func,
              ref ,
              mask);
    }
    template<
      typename FACE_TYPE = GLenum,
      typename FUNC_TYPE = GLenum,
      typename REF_TYPE  = GLint ,
      typename MASK_TYPE = GLuint>
    inline std::shared_ptr<StencilFuncSeparate<
      FACE_TYPE,
      FUNC_TYPE,
      REF_TYPE ,
      MASK_TYPE>> sharedStencilFuncSeparate(
        FACE_TYPE const&face,
        FUNC_TYPE const&func,
        REF_TYPE  const&ref ,
        MASK_TYPE const&mask){
        return std::make_shared<StencilFuncSeparate<
          FACE_TYPE,
          FUNC_TYPE,
          REF_TYPE ,
          MASK_TYPE>>(
              face,
              func,
              ref ,
              mask);
    }

    template<
      typename VAOBJ_TYPE = GLuint,
      typename INDEX_TYPE = GLuint>
    inline DisableVertexArrayAttrib<
      VAOBJ_TYPE,
      INDEX_TYPE>* newDisableVertexArrayAttrib(
        VAOBJ_TYPE const&vaobj,
        INDEX_TYPE const&index){
        return new DisableVertexArrayAttrib<
          VAOBJ_TYPE,
          INDEX_TYPE>(
              vaobj,
              index);
    }
    template<
      typename VAOBJ_TYPE = GLuint,
      typename INDEX_TYPE = GLuint>
    inline std::shared_ptr<DisableVertexArrayAttrib<
      VAOBJ_TYPE,
      INDEX_TYPE>> sharedDisableVertexArrayAttrib(
        VAOBJ_TYPE const&vaobj,
        INDEX_TYPE const&index){
        return std::make_shared<DisableVertexArrayAttrib<
          VAOBJ_TYPE,
          INDEX_TYPE>>(
              vaobj,
              index);
    }

    template<
      typename COUNT_TYPE    = GLsizei,
      typename SAMPLERS_TYPE = GLuint*>
    inline GenSamplers<
      COUNT_TYPE   ,
      SAMPLERS_TYPE>* newGenSamplers(
        COUNT_TYPE    const&count   ,
        SAMPLERS_TYPE const&samplers){
        return new GenSamplers<
          COUNT_TYPE   ,
          SAMPLERS_TYPE>(
              count   ,
              samplers);
    }
    template<
      typename COUNT_TYPE    = GLsizei,
      typename SAMPLERS_TYPE = GLuint*>
    inline std::shared_ptr<GenSamplers<
      COUNT_TYPE   ,
      SAMPLERS_TYPE>> sharedGenSamplers(
        COUNT_TYPE    const&count   ,
        SAMPLERS_TYPE const&samplers){
        return std::make_shared<GenSamplers<
          COUNT_TYPE   ,
          SAMPLERS_TYPE>>(
              count   ,
              samplers);
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename CLAMP_TYPE  = GLenum>
    inline ClampColor<
      TARGET_TYPE,
      CLAMP_TYPE >* newClampColor(
        TARGET_TYPE const&target,
        CLAMP_TYPE  const&clamp ){
        return new ClampColor<
          TARGET_TYPE,
          CLAMP_TYPE >(
              target,
              clamp );
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename CLAMP_TYPE  = GLenum>
    inline std::shared_ptr<ClampColor<
      TARGET_TYPE,
      CLAMP_TYPE >> sharedClampColor(
        TARGET_TYPE const&target,
        CLAMP_TYPE  const&clamp ){
        return std::make_shared<ClampColor<
          TARGET_TYPE,
          CLAMP_TYPE >>(
              target,
              clamp );
    }

    template<
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline Uniform4iv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform4iv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform4iv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline std::shared_ptr<Uniform4iv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform4iv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform4iv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename S_TYPE = GLint>
    inline ClearStencil<
      S_TYPE>* newClearStencil(
        S_TYPE const&s){
        return new ClearStencil<
          S_TYPE>(
              s);
    }
    template<
      typename S_TYPE = GLint>
    inline std::shared_ptr<ClearStencil<
      S_TYPE>> sharedClearStencil(
        S_TYPE const&s){
        return std::make_shared<ClearStencil<
          S_TYPE>>(
              s);
    }

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    inline VertexAttribI4uiv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribI4uiv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribI4uiv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    inline std::shared_ptr<VertexAttribI4uiv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribI4uiv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribI4uiv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename RENDERBUFFER_TYPE = GLuint,
      typename PNAME_TYPE        = GLenum,
      typename PARAMS_TYPE       = GLint*>
    inline GetNamedRenderbufferParameteriv<
      RENDERBUFFER_TYPE,
      PNAME_TYPE       ,
      PARAMS_TYPE      >* newGetNamedRenderbufferParameteriv(
        RENDERBUFFER_TYPE const&renderbuffer,
        PNAME_TYPE        const&pname       ,
        PARAMS_TYPE       const&params      ){
        return new GetNamedRenderbufferParameteriv<
          RENDERBUFFER_TYPE,
          PNAME_TYPE       ,
          PARAMS_TYPE      >(
              renderbuffer,
              pname       ,
              params      );
    }
    template<
      typename RENDERBUFFER_TYPE = GLuint,
      typename PNAME_TYPE        = GLenum,
      typename PARAMS_TYPE       = GLint*>
    inline std::shared_ptr<GetNamedRenderbufferParameteriv<
      RENDERBUFFER_TYPE,
      PNAME_TYPE       ,
      PARAMS_TYPE      >> sharedGetNamedRenderbufferParameteriv(
        RENDERBUFFER_TYPE const&renderbuffer,
        PNAME_TYPE        const&pname       ,
        PARAMS_TYPE       const&params      ){
        return std::make_shared<GetNamedRenderbufferParameteriv<
          RENDERBUFFER_TYPE,
          PNAME_TYPE       ,
          PARAMS_TYPE      >>(
              renderbuffer,
              pname       ,
              params      );
    }

    template<
      typename MODE_TYPE          = GLenum ,
      typename ID_TYPE            = GLuint ,
      typename INSTANCECOUNT_TYPE = GLsizei>
    inline DrawTransformFeedbackInstanced<
      MODE_TYPE         ,
      ID_TYPE           ,
      INSTANCECOUNT_TYPE>* newDrawTransformFeedbackInstanced(
        MODE_TYPE          const&mode         ,
        ID_TYPE            const&id           ,
        INSTANCECOUNT_TYPE const&instancecount){
        return new DrawTransformFeedbackInstanced<
          MODE_TYPE         ,
          ID_TYPE           ,
          INSTANCECOUNT_TYPE>(
              mode         ,
              id           ,
              instancecount);
    }
    template<
      typename MODE_TYPE          = GLenum ,
      typename ID_TYPE            = GLuint ,
      typename INSTANCECOUNT_TYPE = GLsizei>
    inline std::shared_ptr<DrawTransformFeedbackInstanced<
      MODE_TYPE         ,
      ID_TYPE           ,
      INSTANCECOUNT_TYPE>> sharedDrawTransformFeedbackInstanced(
        MODE_TYPE          const&mode         ,
        ID_TYPE            const&id           ,
        INSTANCECOUNT_TYPE const&instancecount){
        return std::make_shared<DrawTransformFeedbackInstanced<
          MODE_TYPE         ,
          ID_TYPE           ,
          INSTANCECOUNT_TYPE>>(
              mode         ,
              id           ,
              instancecount);
    }

    template<
      typename N_TYPE        = GLsizei,
      typename TEXTURES_TYPE = GLuint*>
    inline GenTextures<
      N_TYPE       ,
      TEXTURES_TYPE>* newGenTextures(
        N_TYPE        const&n       ,
        TEXTURES_TYPE const&textures){
        return new GenTextures<
          N_TYPE       ,
          TEXTURES_TYPE>(
              n       ,
              textures);
    }
    template<
      typename N_TYPE        = GLsizei,
      typename TEXTURES_TYPE = GLuint*>
    inline std::shared_ptr<GenTextures<
      N_TYPE       ,
      TEXTURES_TYPE>> sharedGenTextures(
        N_TYPE        const&n       ,
        TEXTURES_TYPE const&textures){
        return std::make_shared<GenTextures<
          N_TYPE       ,
          TEXTURES_TYPE>>(
              n       ,
              textures);
    }

    template<
      typename TEXTURE_TYPE              = GLuint   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    inline TextureStorage2DMultisample<
      TEXTURE_TYPE             ,
      SAMPLES_TYPE             ,
      INTERNALFORMAT_TYPE      ,
      WIDTH_TYPE               ,
      HEIGHT_TYPE              ,
      FIXEDSAMPLELOCATIONS_TYPE>* newTextureStorage2DMultisample(
        TEXTURE_TYPE              const&texture             ,
        SAMPLES_TYPE              const&samples             ,
        INTERNALFORMAT_TYPE       const&internalformat      ,
        WIDTH_TYPE                const&width               ,
        HEIGHT_TYPE               const&height              ,
        FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
        return new TextureStorage2DMultisample<
          TEXTURE_TYPE             ,
          SAMPLES_TYPE             ,
          INTERNALFORMAT_TYPE      ,
          WIDTH_TYPE               ,
          HEIGHT_TYPE              ,
          FIXEDSAMPLELOCATIONS_TYPE>(
              texture             ,
              samples             ,
              internalformat      ,
              width               ,
              height              ,
              fixedsamplelocations);
    }
    template<
      typename TEXTURE_TYPE              = GLuint   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    inline std::shared_ptr<TextureStorage2DMultisample<
      TEXTURE_TYPE             ,
      SAMPLES_TYPE             ,
      INTERNALFORMAT_TYPE      ,
      WIDTH_TYPE               ,
      HEIGHT_TYPE              ,
      FIXEDSAMPLELOCATIONS_TYPE>> sharedTextureStorage2DMultisample(
        TEXTURE_TYPE              const&texture             ,
        SAMPLES_TYPE              const&samples             ,
        INTERNALFORMAT_TYPE       const&internalformat      ,
        WIDTH_TYPE                const&width               ,
        HEIGHT_TYPE               const&height              ,
        FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
        return std::make_shared<TextureStorage2DMultisample<
          TEXTURE_TYPE             ,
          SAMPLES_TYPE             ,
          INTERNALFORMAT_TYPE      ,
          WIDTH_TYPE               ,
          HEIGHT_TYPE              ,
          FIXEDSAMPLELOCATIONS_TYPE>>(
              texture             ,
              samples             ,
              internalformat      ,
              width               ,
              height              ,
              fixedsamplelocations);
    }

    template<
      typename MODE_TYPE = GLenum,
      typename ID_TYPE   = GLuint>
    inline DrawTransformFeedback<
      MODE_TYPE,
      ID_TYPE  >* newDrawTransformFeedback(
        MODE_TYPE const&mode,
        ID_TYPE   const&id  ){
        return new DrawTransformFeedback<
          MODE_TYPE,
          ID_TYPE  >(
              mode,
              id  );
    }
    template<
      typename MODE_TYPE = GLenum,
      typename ID_TYPE   = GLuint>
    inline std::shared_ptr<DrawTransformFeedback<
      MODE_TYPE,
      ID_TYPE  >> sharedDrawTransformFeedback(
        MODE_TYPE const&mode,
        ID_TYPE   const&id  ){
        return std::make_shared<DrawTransformFeedback<
          MODE_TYPE,
          ID_TYPE  >>(
              mode,
              id  );
    }

    template<
      typename PNAME_TYPE = GLenum   ,
      typename DATA_TYPE  = GLdouble*>
    inline GetDoublev<
      PNAME_TYPE,
      DATA_TYPE >* newGetDoublev(
        PNAME_TYPE const&pname,
        DATA_TYPE  const&data ){
        return new GetDoublev<
          PNAME_TYPE,
          DATA_TYPE >(
              pname,
              data );
    }
    template<
      typename PNAME_TYPE = GLenum   ,
      typename DATA_TYPE  = GLdouble*>
    inline std::shared_ptr<GetDoublev<
      PNAME_TYPE,
      DATA_TYPE >> sharedGetDoublev(
        PNAME_TYPE const&pname,
        DATA_TYPE  const&data ){
        return std::make_shared<GetDoublev<
          PNAME_TYPE,
          DATA_TYPE >>(
              pname,
              data );
    }

    template<
      typename TARGET_TYPE = GLenum ,
      typename PNAME_TYPE  = GLenum ,
      typename PARAMS_TYPE = GLuint*>
    inline GetTexParameterIuiv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetTexParameterIuiv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetTexParameterIuiv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum ,
      typename PNAME_TYPE  = GLenum ,
      typename PARAMS_TYPE = GLuint*>
    inline std::shared_ptr<GetTexParameterIuiv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetTexParameterIuiv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetTexParameterIuiv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename XFB_TYPE   = GLuint,
      typename PNAME_TYPE = GLenum,
      typename INDEX_TYPE = GLuint,
      typename PARAM_TYPE = GLint*>
    inline GetTransformFeedbacki_v<
      XFB_TYPE  ,
      PNAME_TYPE,
      INDEX_TYPE,
      PARAM_TYPE>* newGetTransformFeedbacki_v(
        XFB_TYPE   const&xfb  ,
        PNAME_TYPE const&pname,
        INDEX_TYPE const&index,
        PARAM_TYPE const&param){
        return new GetTransformFeedbacki_v<
          XFB_TYPE  ,
          PNAME_TYPE,
          INDEX_TYPE,
          PARAM_TYPE>(
              xfb  ,
              pname,
              index,
              param);
    }
    template<
      typename XFB_TYPE   = GLuint,
      typename PNAME_TYPE = GLenum,
      typename INDEX_TYPE = GLuint,
      typename PARAM_TYPE = GLint*>
    inline std::shared_ptr<GetTransformFeedbacki_v<
      XFB_TYPE  ,
      PNAME_TYPE,
      INDEX_TYPE,
      PARAM_TYPE>> sharedGetTransformFeedbacki_v(
        XFB_TYPE   const&xfb  ,
        PNAME_TYPE const&pname,
        INDEX_TYPE const&index,
        PARAM_TYPE const&param){
        return std::make_shared<GetTransformFeedbacki_v<
          XFB_TYPE  ,
          PNAME_TYPE,
          INDEX_TYPE,
          PARAM_TYPE>>(
              xfb  ,
              pname,
              index,
              param);
    }

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLbyte*>
    inline VertexAttrib4Nbv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4Nbv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4Nbv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLbyte*>
    inline std::shared_ptr<VertexAttrib4Nbv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4Nbv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4Nbv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei>
    inline TexStorage1D<
      TARGET_TYPE        ,
      LEVELS_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         >* newTexStorage1D(
        TARGET_TYPE         const&target        ,
        LEVELS_TYPE         const&levels        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ){
        return new TexStorage1D<
          TARGET_TYPE        ,
          LEVELS_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         >(
              target        ,
              levels        ,
              internalformat,
              width         );
    }
    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei>
    inline std::shared_ptr<TexStorage1D<
      TARGET_TYPE        ,
      LEVELS_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         >> sharedTexStorage1D(
        TARGET_TYPE         const&target        ,
        LEVELS_TYPE         const&levels        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ){
        return std::make_shared<TexStorage1D<
          TARGET_TYPE        ,
          LEVELS_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         >>(
              target        ,
              levels        ,
              internalformat,
              width         );
    }

    template<
      typename RET_TYPE  = GLboolean,
      typename SYNC_TYPE = GLsync   >
    inline IsSync<
      RET_TYPE ,
      SYNC_TYPE>* newIsSync(
        RET_TYPE  const&ret ,
        SYNC_TYPE const&sync){
        return new IsSync<
          RET_TYPE ,
          SYNC_TYPE>(
              ret ,
              sync);
    }
    template<
      typename RET_TYPE  = GLboolean,
      typename SYNC_TYPE = GLsync   >
    inline std::shared_ptr<IsSync<
      RET_TYPE ,
      SYNC_TYPE>> sharedIsSync(
        RET_TYPE  const&ret ,
        SYNC_TYPE const&sync){
        return std::make_shared<IsSync<
          RET_TYPE ,
          SYNC_TYPE>>(
              ret ,
              sync);
    }

    template<
      typename RET_TYPE = GLuint>
    inline CreateProgram<
      RET_TYPE>* newCreateProgram(
        RET_TYPE const&ret){
        return new CreateProgram<
          RET_TYPE>(
              ret);
    }
    template<
      typename RET_TYPE = GLuint>
    inline std::shared_ptr<CreateProgram<
      RET_TYPE>> sharedCreateProgram(
        RET_TYPE const&ret){
        return std::make_shared<CreateProgram<
          RET_TYPE>>(
              ret);
    }

    template<
      typename PROGRAM_TYPE           = GLuint  ,
      typename UNIFORMBLOCKINDEX_TYPE = GLuint  ,
      typename BUFSIZE_TYPE           = GLsizei ,
      typename LENGTH_TYPE            = GLsizei*,
      typename UNIFORMBLOCKNAME_TYPE  = GLchar* >
    inline GetActiveUniformBlockName<
      PROGRAM_TYPE          ,
      UNIFORMBLOCKINDEX_TYPE,
      BUFSIZE_TYPE          ,
      LENGTH_TYPE           ,
      UNIFORMBLOCKNAME_TYPE >* newGetActiveUniformBlockName(
        PROGRAM_TYPE           const&program          ,
        UNIFORMBLOCKINDEX_TYPE const&uniformBlockIndex,
        BUFSIZE_TYPE           const&bufSize          ,
        LENGTH_TYPE            const&length           ,
        UNIFORMBLOCKNAME_TYPE  const&uniformBlockName ){
        return new GetActiveUniformBlockName<
          PROGRAM_TYPE          ,
          UNIFORMBLOCKINDEX_TYPE,
          BUFSIZE_TYPE          ,
          LENGTH_TYPE           ,
          UNIFORMBLOCKNAME_TYPE >(
              program          ,
              uniformBlockIndex,
              bufSize          ,
              length           ,
              uniformBlockName );
    }
    template<
      typename PROGRAM_TYPE           = GLuint  ,
      typename UNIFORMBLOCKINDEX_TYPE = GLuint  ,
      typename BUFSIZE_TYPE           = GLsizei ,
      typename LENGTH_TYPE            = GLsizei*,
      typename UNIFORMBLOCKNAME_TYPE  = GLchar* >
    inline std::shared_ptr<GetActiveUniformBlockName<
      PROGRAM_TYPE          ,
      UNIFORMBLOCKINDEX_TYPE,
      BUFSIZE_TYPE          ,
      LENGTH_TYPE           ,
      UNIFORMBLOCKNAME_TYPE >> sharedGetActiveUniformBlockName(
        PROGRAM_TYPE           const&program          ,
        UNIFORMBLOCKINDEX_TYPE const&uniformBlockIndex,
        BUFSIZE_TYPE           const&bufSize          ,
        LENGTH_TYPE            const&length           ,
        UNIFORMBLOCKNAME_TYPE  const&uniformBlockName ){
        return std::make_shared<GetActiveUniformBlockName<
          PROGRAM_TYPE          ,
          UNIFORMBLOCKINDEX_TYPE,
          BUFSIZE_TYPE          ,
          LENGTH_TYPE           ,
          UNIFORMBLOCKNAME_TYPE >>(
              program          ,
              uniformBlockIndex,
              bufSize          ,
              length           ,
              uniformBlockName );
    }

    template<
      typename LOCATION_TYPE = GLint,
      typename V0_TYPE       = GLint,
      typename V1_TYPE       = GLint>
    inline Uniform2i<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >* newUniform2i(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return new Uniform2i<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >(
              location,
              v0      ,
              v1      );
    }
    template<
      typename LOCATION_TYPE = GLint,
      typename V0_TYPE       = GLint,
      typename V1_TYPE       = GLint>
    inline std::shared_ptr<Uniform2i<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >> sharedUniform2i(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return std::make_shared<Uniform2i<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >>(
              location,
              v0      ,
              v1      );
    }

    template<
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat>
    inline Uniform2f<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >* newUniform2f(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return new Uniform2f<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >(
              location,
              v0      ,
              v1      );
    }
    template<
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat>
    inline std::shared_ptr<Uniform2f<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >> sharedUniform2f(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return std::make_shared<Uniform2f<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >>(
              location,
              v0      ,
              v1      );
    }

    template<
      typename LOCATION_TYPE = GLint   ,
      typename X_TYPE        = GLdouble,
      typename Y_TYPE        = GLdouble>
    inline Uniform2d<
      LOCATION_TYPE,
      X_TYPE       ,
      Y_TYPE       >* newUniform2d(
        LOCATION_TYPE const&location,
        X_TYPE        const&x       ,
        Y_TYPE        const&y       ){
        return new Uniform2d<
          LOCATION_TYPE,
          X_TYPE       ,
          Y_TYPE       >(
              location,
              x       ,
              y       );
    }
    template<
      typename LOCATION_TYPE = GLint   ,
      typename X_TYPE        = GLdouble,
      typename Y_TYPE        = GLdouble>
    inline std::shared_ptr<Uniform2d<
      LOCATION_TYPE,
      X_TYPE       ,
      Y_TYPE       >> sharedUniform2d(
        LOCATION_TYPE const&location,
        X_TYPE        const&x       ,
        Y_TYPE        const&y       ){
        return std::make_shared<Uniform2d<
          LOCATION_TYPE,
          X_TYPE       ,
          Y_TYPE       >>(
              location,
              x       ,
              y       );
    }

    template<
      typename SHADER_TYPE = GLuint             ,
      typename COUNT_TYPE  = GLsizei            ,
      typename STRING_TYPE = const GLchar*const*,
      typename LENGTH_TYPE = const GLint*       >
    inline ShaderSource<
      SHADER_TYPE,
      COUNT_TYPE ,
      STRING_TYPE,
      LENGTH_TYPE>* newShaderSource(
        SHADER_TYPE const&shader,
        COUNT_TYPE  const&count ,
        STRING_TYPE const&string,
        LENGTH_TYPE const&length){
        return new ShaderSource<
          SHADER_TYPE,
          COUNT_TYPE ,
          STRING_TYPE,
          LENGTH_TYPE>(
              shader,
              count ,
              string,
              length);
    }
    template<
      typename SHADER_TYPE = GLuint             ,
      typename COUNT_TYPE  = GLsizei            ,
      typename STRING_TYPE = const GLchar*const*,
      typename LENGTH_TYPE = const GLint*       >
    inline std::shared_ptr<ShaderSource<
      SHADER_TYPE,
      COUNT_TYPE ,
      STRING_TYPE,
      LENGTH_TYPE>> sharedShaderSource(
        SHADER_TYPE const&shader,
        COUNT_TYPE  const&count ,
        STRING_TYPE const&string,
        LENGTH_TYPE const&length){
        return std::make_shared<ShaderSource<
          SHADER_TYPE,
          COUNT_TYPE ,
          STRING_TYPE,
          LENGTH_TYPE>>(
              shader,
              count ,
              string,
              length);
    }

    template<
      typename PROGRAM_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    inline GetProgramiv<
      PROGRAM_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newGetProgramiv(
        PROGRAM_TYPE const&program,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new GetProgramiv<
          PROGRAM_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              program,
              pname  ,
              params );
    }
    template<
      typename PROGRAM_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    inline std::shared_ptr<GetProgramiv<
      PROGRAM_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedGetProgramiv(
        PROGRAM_TYPE const&program,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<GetProgramiv<
          PROGRAM_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              program,
              pname  ,
              params );
    }

    template<
      typename INDEX_TYPE      = GLuint     ,
      typename SIZE_TYPE       = GLint      ,
      typename TYPE_TYPE       = GLenum     ,
      typename NORMALIZED_TYPE = GLboolean  ,
      typename STRIDE_TYPE     = GLsizei    ,
      typename POINTER_TYPE    = const void*>
    inline VertexAttribPointer<
      INDEX_TYPE     ,
      SIZE_TYPE      ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      STRIDE_TYPE    ,
      POINTER_TYPE   >* newVertexAttribPointer(
        INDEX_TYPE      const&index     ,
        SIZE_TYPE       const&size      ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        STRIDE_TYPE     const&stride    ,
        POINTER_TYPE    const&pointer   ){
        return new VertexAttribPointer<
          INDEX_TYPE     ,
          SIZE_TYPE      ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          STRIDE_TYPE    ,
          POINTER_TYPE   >(
              index     ,
              size      ,
              type      ,
              normalized,
              stride    ,
              pointer   );
    }
    template<
      typename INDEX_TYPE      = GLuint     ,
      typename SIZE_TYPE       = GLint      ,
      typename TYPE_TYPE       = GLenum     ,
      typename NORMALIZED_TYPE = GLboolean  ,
      typename STRIDE_TYPE     = GLsizei    ,
      typename POINTER_TYPE    = const void*>
    inline std::shared_ptr<VertexAttribPointer<
      INDEX_TYPE     ,
      SIZE_TYPE      ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      STRIDE_TYPE    ,
      POINTER_TYPE   >> sharedVertexAttribPointer(
        INDEX_TYPE      const&index     ,
        SIZE_TYPE       const&size      ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        STRIDE_TYPE     const&stride    ,
        POINTER_TYPE    const&pointer   ){
        return std::make_shared<VertexAttribPointer<
          INDEX_TYPE     ,
          SIZE_TYPE      ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          STRIDE_TYPE    ,
          POINTER_TYPE   >>(
              index     ,
              size      ,
              type      ,
              normalized,
              stride    ,
              pointer   );
    }

    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint ,
      typename LAYER_TYPE      = GLint >
    inline FramebufferTextureLayer<
      TARGET_TYPE    ,
      ATTACHMENT_TYPE,
      TEXTURE_TYPE   ,
      LEVEL_TYPE     ,
      LAYER_TYPE     >* newFramebufferTextureLayer(
        TARGET_TYPE     const&target    ,
        ATTACHMENT_TYPE const&attachment,
        TEXTURE_TYPE    const&texture   ,
        LEVEL_TYPE      const&level     ,
        LAYER_TYPE      const&layer     ){
        return new FramebufferTextureLayer<
          TARGET_TYPE    ,
          ATTACHMENT_TYPE,
          TEXTURE_TYPE   ,
          LEVEL_TYPE     ,
          LAYER_TYPE     >(
              target    ,
              attachment,
              texture   ,
              level     ,
              layer     );
    }
    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint ,
      typename LAYER_TYPE      = GLint >
    inline std::shared_ptr<FramebufferTextureLayer<
      TARGET_TYPE    ,
      ATTACHMENT_TYPE,
      TEXTURE_TYPE   ,
      LEVEL_TYPE     ,
      LAYER_TYPE     >> sharedFramebufferTextureLayer(
        TARGET_TYPE     const&target    ,
        ATTACHMENT_TYPE const&attachment,
        TEXTURE_TYPE    const&texture   ,
        LEVEL_TYPE      const&level     ,
        LAYER_TYPE      const&layer     ){
        return std::make_shared<FramebufferTextureLayer<
          TARGET_TYPE    ,
          ATTACHMENT_TYPE,
          TEXTURE_TYPE   ,
          LEVEL_TYPE     ,
          LAYER_TYPE     >>(
              target    ,
              attachment,
              texture   ,
              level     ,
              layer     );
    }

    template<
      typename PROGRAM_TYPE  = GLuint        ,
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline ProgramUniform4fv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform4fv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform4fv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint        ,
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline std::shared_ptr<ProgramUniform4fv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform4fv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform4fv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename PTR_TYPE     = const void*,
      typename BUFSIZE_TYPE = GLsizei    ,
      typename LENGTH_TYPE  = GLsizei*   ,
      typename LABEL_TYPE   = GLchar*    >
    inline GetObjectPtrLabel<
      PTR_TYPE    ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      LABEL_TYPE  >* newGetObjectPtrLabel(
        PTR_TYPE     const&ptr    ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        LABEL_TYPE   const&label  ){
        return new GetObjectPtrLabel<
          PTR_TYPE    ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          LABEL_TYPE  >(
              ptr    ,
              bufSize,
              length ,
              label  );
    }
    template<
      typename PTR_TYPE     = const void*,
      typename BUFSIZE_TYPE = GLsizei    ,
      typename LENGTH_TYPE  = GLsizei*   ,
      typename LABEL_TYPE   = GLchar*    >
    inline std::shared_ptr<GetObjectPtrLabel<
      PTR_TYPE    ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      LABEL_TYPE  >> sharedGetObjectPtrLabel(
        PTR_TYPE     const&ptr    ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        LABEL_TYPE   const&label  ){
        return std::make_shared<GetObjectPtrLabel<
          PTR_TYPE    ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          LABEL_TYPE  >>(
              ptr    ,
              bufSize,
              length ,
              label  );
    }

    template<
      typename TEXTURE_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAM_TYPE   = GLint >
    inline TextureParameteri<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >* newTextureParameteri(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return new TextureParameteri<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >(
              texture,
              pname  ,
              param  );
    }
    template<
      typename TEXTURE_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAM_TYPE   = GLint >
    inline std::shared_ptr<TextureParameteri<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >> sharedTextureParameteri(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return std::make_shared<TextureParameteri<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >>(
              texture,
              pname  ,
              param  );
    }

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename PNAME_TYPE   = GLenum ,
      typename PARAM_TYPE   = GLfloat>
    inline TextureParameterf<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >* newTextureParameterf(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return new TextureParameterf<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >(
              texture,
              pname  ,
              param  );
    }
    template<
      typename TEXTURE_TYPE = GLuint ,
      typename PNAME_TYPE   = GLenum ,
      typename PARAM_TYPE   = GLfloat>
    inline std::shared_ptr<TextureParameterf<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >> sharedTextureParameterf(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return std::make_shared<TextureParameterf<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >>(
              texture,
              pname  ,
              param  );
    }

    template<
      typename TARGET_TYPE = GLenum    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr>
    inline FlushMappedBufferRange<
      TARGET_TYPE,
      OFFSET_TYPE,
      LENGTH_TYPE>* newFlushMappedBufferRange(
        TARGET_TYPE const&target,
        OFFSET_TYPE const&offset,
        LENGTH_TYPE const&length){
        return new FlushMappedBufferRange<
          TARGET_TYPE,
          OFFSET_TYPE,
          LENGTH_TYPE>(
              target,
              offset,
              length);
    }
    template<
      typename TARGET_TYPE = GLenum    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr>
    inline std::shared_ptr<FlushMappedBufferRange<
      TARGET_TYPE,
      OFFSET_TYPE,
      LENGTH_TYPE>> sharedFlushMappedBufferRange(
        TARGET_TYPE const&target,
        OFFSET_TYPE const&offset,
        LENGTH_TYPE const&length){
        return std::make_shared<FlushMappedBufferRange<
          TARGET_TYPE,
          OFFSET_TYPE,
          LENGTH_TYPE>>(
              target,
              offset,
              length);
    }

    template<
      typename PROGRAM_TYPE  = GLuint        ,
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline ProgramUniform2fv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform2fv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform2fv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint        ,
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline std::shared_ptr<ProgramUniform2fv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform2fv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform2fv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline UniformMatrix2x3dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix2x3dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix2x3dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<UniformMatrix2x3dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix2x3dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix2x3dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble,
      typename Z_TYPE     = GLdouble>
    inline VertexAttribL3d<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    >* newVertexAttribL3d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ){
        return new VertexAttribL3d<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    >(
              index,
              x    ,
              y    ,
              z    );
    }
    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble,
      typename Z_TYPE     = GLdouble>
    inline std::shared_ptr<VertexAttribL3d<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    >> sharedVertexAttribL3d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ){
        return std::make_shared<VertexAttribL3d<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    >>(
              index,
              x    ,
              y    ,
              z    );
    }

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline ProgramUniformMatrix2x4dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix2x4dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix2x4dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<ProgramUniformMatrix2x4dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix2x4dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix2x4dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename LOCATION_TYPE = GLint   ,
      typename X_TYPE        = GLdouble>
    inline Uniform1d<
      LOCATION_TYPE,
      X_TYPE       >* newUniform1d(
        LOCATION_TYPE const&location,
        X_TYPE        const&x       ){
        return new Uniform1d<
          LOCATION_TYPE,
          X_TYPE       >(
              location,
              x       );
    }
    template<
      typename LOCATION_TYPE = GLint   ,
      typename X_TYPE        = GLdouble>
    inline std::shared_ptr<Uniform1d<
      LOCATION_TYPE,
      X_TYPE       >> sharedUniform1d(
        LOCATION_TYPE const&location,
        X_TYPE        const&x       ){
        return std::make_shared<Uniform1d<
          LOCATION_TYPE,
          X_TYPE       >>(
              location,
              x       );
    }

    template<
      typename N_TYPE   = GLsizei,
      typename IDS_TYPE = GLuint*>
    inline GenQueries<
      N_TYPE  ,
      IDS_TYPE>* newGenQueries(
        N_TYPE   const&n  ,
        IDS_TYPE const&ids){
        return new GenQueries<
          N_TYPE  ,
          IDS_TYPE>(
              n  ,
              ids);
    }
    template<
      typename N_TYPE   = GLsizei,
      typename IDS_TYPE = GLuint*>
    inline std::shared_ptr<GenQueries<
      N_TYPE  ,
      IDS_TYPE>> sharedGenQueries(
        N_TYPE   const&n  ,
        IDS_TYPE const&ids){
        return std::make_shared<GenQueries<
          N_TYPE  ,
          IDS_TYPE>>(
              n  ,
              ids);
    }

    template<
      typename INDEX_TYPE      = GLuint   ,
      typename TYPE_TYPE       = GLenum   ,
      typename NORMALIZED_TYPE = GLboolean,
      typename VALUE_TYPE      = GLuint   >
    inline VertexAttribP1ui<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >* newVertexAttribP1ui(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return new VertexAttribP1ui<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >(
              index     ,
              type      ,
              normalized,
              value     );
    }
    template<
      typename INDEX_TYPE      = GLuint   ,
      typename TYPE_TYPE       = GLenum   ,
      typename NORMALIZED_TYPE = GLboolean,
      typename VALUE_TYPE      = GLuint   >
    inline std::shared_ptr<VertexAttribP1ui<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >> sharedVertexAttribP1ui(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return std::make_shared<VertexAttribP1ui<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >>(
              index     ,
              type      ,
              normalized,
              value     );
    }

    template<
      typename TARGET_TYPE  = GLenum     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename ZOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename DEPTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    inline TexSubImage3D<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      DEPTH_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      PIXELS_TYPE >* newTexSubImage3D(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        DEPTH_TYPE   const&depth  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        PIXELS_TYPE  const&pixels ){
        return new TexSubImage3D<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          DEPTH_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          PIXELS_TYPE >(
              target ,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              width  ,
              height ,
              depth  ,
              format ,
              type   ,
              pixels );
    }
    template<
      typename TARGET_TYPE  = GLenum     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename ZOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename DEPTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    inline std::shared_ptr<TexSubImage3D<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      DEPTH_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      PIXELS_TYPE >> sharedTexSubImage3D(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        DEPTH_TYPE   const&depth  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        PIXELS_TYPE  const&pixels ){
        return std::make_shared<TexSubImage3D<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          DEPTH_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          PIXELS_TYPE >>(
              target ,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              width  ,
              height ,
              depth  ,
              format ,
              type   ,
              pixels );
    }

    template<
      typename TARGET_TYPE = GLenum  ,
      typename INDEX_TYPE  = GLuint  ,
      typename DATA_TYPE   = GLint64*>
    inline GetInteger64i_v<
      TARGET_TYPE,
      INDEX_TYPE ,
      DATA_TYPE  >* newGetInteger64i_v(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        DATA_TYPE   const&data  ){
        return new GetInteger64i_v<
          TARGET_TYPE,
          INDEX_TYPE ,
          DATA_TYPE  >(
              target,
              index ,
              data  );
    }
    template<
      typename TARGET_TYPE = GLenum  ,
      typename INDEX_TYPE  = GLuint  ,
      typename DATA_TYPE   = GLint64*>
    inline std::shared_ptr<GetInteger64i_v<
      TARGET_TYPE,
      INDEX_TYPE ,
      DATA_TYPE  >> sharedGetInteger64i_v(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        DATA_TYPE   const&data  ){
        return std::make_shared<GetInteger64i_v<
          TARGET_TYPE,
          INDEX_TYPE ,
          DATA_TYPE  >>(
              target,
              index ,
              data  );
    }

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint>
    inline ProgramUniform1ui<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      >* newProgramUniform1ui(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return new ProgramUniform1ui<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      >(
              program ,
              location,
              v0      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint>
    inline std::shared_ptr<ProgramUniform1ui<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      >> sharedProgramUniform1ui(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return std::make_shared<ProgramUniform1ui<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      >>(
              program ,
              location,
              v0      );
    }

    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVEL_TYPE          = GLint  ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename X_TYPE              = GLint  ,
      typename Y_TYPE              = GLint  ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei,
      typename BORDER_TYPE         = GLint  >
    inline CopyTexImage2D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      X_TYPE             ,
      Y_TYPE             ,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      BORDER_TYPE        >* newCopyTexImage2D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        X_TYPE              const&x             ,
        Y_TYPE              const&y             ,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        BORDER_TYPE         const&border        ){
        return new CopyTexImage2D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          X_TYPE             ,
          Y_TYPE             ,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          BORDER_TYPE        >(
              target        ,
              level         ,
              internalformat,
              x             ,
              y             ,
              width         ,
              height        ,
              border        );
    }
    template<
      typename TARGET_TYPE         = GLenum ,
      typename LEVEL_TYPE          = GLint  ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename X_TYPE              = GLint  ,
      typename Y_TYPE              = GLint  ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei,
      typename BORDER_TYPE         = GLint  >
    inline std::shared_ptr<CopyTexImage2D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      X_TYPE             ,
      Y_TYPE             ,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      BORDER_TYPE        >> sharedCopyTexImage2D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        X_TYPE              const&x             ,
        Y_TYPE              const&y             ,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        BORDER_TYPE         const&border        ){
        return std::make_shared<CopyTexImage2D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          X_TYPE             ,
          Y_TYPE             ,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          BORDER_TYPE        >>(
              target        ,
              level         ,
              internalformat,
              x             ,
              y             ,
              width         ,
              height        ,
              border        );
    }

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei,
      typename DEPTH_TYPE   = GLsizei,
      typename FORMAT_TYPE  = GLenum ,
      typename TYPE_TYPE    = GLenum ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    inline GetTextureSubImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      DEPTH_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      BUFSIZE_TYPE,
      PIXELS_TYPE >* newGetTextureSubImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        DEPTH_TYPE   const&depth  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        BUFSIZE_TYPE const&bufSize,
        PIXELS_TYPE  const&pixels ){
        return new GetTextureSubImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          DEPTH_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          BUFSIZE_TYPE,
          PIXELS_TYPE >(
              texture,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              width  ,
              height ,
              depth  ,
              format ,
              type   ,
              bufSize,
              pixels );
    }
    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei,
      typename DEPTH_TYPE   = GLsizei,
      typename FORMAT_TYPE  = GLenum ,
      typename TYPE_TYPE    = GLenum ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    inline std::shared_ptr<GetTextureSubImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      DEPTH_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      BUFSIZE_TYPE,
      PIXELS_TYPE >> sharedGetTextureSubImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        DEPTH_TYPE   const&depth  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        BUFSIZE_TYPE const&bufSize,
        PIXELS_TYPE  const&pixels ){
        return std::make_shared<GetTextureSubImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          DEPTH_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          BUFSIZE_TYPE,
          PIXELS_TYPE >>(
              texture,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              width  ,
              height ,
              depth  ,
              format ,
              type   ,
              bufSize,
              pixels );
    }

    template<
      typename SRCX0_TYPE  = GLint     ,
      typename SRCY0_TYPE  = GLint     ,
      typename SRCX1_TYPE  = GLint     ,
      typename SRCY1_TYPE  = GLint     ,
      typename DSTX0_TYPE  = GLint     ,
      typename DSTY0_TYPE  = GLint     ,
      typename DSTX1_TYPE  = GLint     ,
      typename DSTY1_TYPE  = GLint     ,
      typename MASK_TYPE   = GLbitfield,
      typename FILTER_TYPE = GLenum    >
    inline BlitFramebuffer<
      SRCX0_TYPE ,
      SRCY0_TYPE ,
      SRCX1_TYPE ,
      SRCY1_TYPE ,
      DSTX0_TYPE ,
      DSTY0_TYPE ,
      DSTX1_TYPE ,
      DSTY1_TYPE ,
      MASK_TYPE  ,
      FILTER_TYPE>* newBlitFramebuffer(
        SRCX0_TYPE  const&srcX0 ,
        SRCY0_TYPE  const&srcY0 ,
        SRCX1_TYPE  const&srcX1 ,
        SRCY1_TYPE  const&srcY1 ,
        DSTX0_TYPE  const&dstX0 ,
        DSTY0_TYPE  const&dstY0 ,
        DSTX1_TYPE  const&dstX1 ,
        DSTY1_TYPE  const&dstY1 ,
        MASK_TYPE   const&mask  ,
        FILTER_TYPE const&filter){
        return new BlitFramebuffer<
          SRCX0_TYPE ,
          SRCY0_TYPE ,
          SRCX1_TYPE ,
          SRCY1_TYPE ,
          DSTX0_TYPE ,
          DSTY0_TYPE ,
          DSTX1_TYPE ,
          DSTY1_TYPE ,
          MASK_TYPE  ,
          FILTER_TYPE>(
              srcX0 ,
              srcY0 ,
              srcX1 ,
              srcY1 ,
              dstX0 ,
              dstY0 ,
              dstX1 ,
              dstY1 ,
              mask  ,
              filter);
    }
    template<
      typename SRCX0_TYPE  = GLint     ,
      typename SRCY0_TYPE  = GLint     ,
      typename SRCX1_TYPE  = GLint     ,
      typename SRCY1_TYPE  = GLint     ,
      typename DSTX0_TYPE  = GLint     ,
      typename DSTY0_TYPE  = GLint     ,
      typename DSTX1_TYPE  = GLint     ,
      typename DSTY1_TYPE  = GLint     ,
      typename MASK_TYPE   = GLbitfield,
      typename FILTER_TYPE = GLenum    >
    inline std::shared_ptr<BlitFramebuffer<
      SRCX0_TYPE ,
      SRCY0_TYPE ,
      SRCX1_TYPE ,
      SRCY1_TYPE ,
      DSTX0_TYPE ,
      DSTY0_TYPE ,
      DSTX1_TYPE ,
      DSTY1_TYPE ,
      MASK_TYPE  ,
      FILTER_TYPE>> sharedBlitFramebuffer(
        SRCX0_TYPE  const&srcX0 ,
        SRCY0_TYPE  const&srcY0 ,
        SRCX1_TYPE  const&srcX1 ,
        SRCY1_TYPE  const&srcY1 ,
        DSTX0_TYPE  const&dstX0 ,
        DSTY0_TYPE  const&dstY0 ,
        DSTX1_TYPE  const&dstX1 ,
        DSTY1_TYPE  const&dstY1 ,
        MASK_TYPE   const&mask  ,
        FILTER_TYPE const&filter){
        return std::make_shared<BlitFramebuffer<
          SRCX0_TYPE ,
          SRCY0_TYPE ,
          SRCX1_TYPE ,
          SRCY1_TYPE ,
          DSTX0_TYPE ,
          DSTY0_TYPE ,
          DSTX1_TYPE ,
          DSTY1_TYPE ,
          MASK_TYPE  ,
          FILTER_TYPE>>(
              srcX0 ,
              srcY0 ,
              srcX1 ,
              srcY1 ,
              dstX0 ,
              dstY0 ,
              dstX1 ,
              dstY1 ,
              mask  ,
              filter);
    }

    template<
      typename RET_TYPE    = GLboolean,
      typename TARGET_TYPE = GLenum   ,
      typename INDEX_TYPE  = GLuint   >
    inline IsEnabledi<
      RET_TYPE   ,
      TARGET_TYPE,
      INDEX_TYPE >* newIsEnabledi(
        RET_TYPE    const&ret   ,
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ){
        return new IsEnabledi<
          RET_TYPE   ,
          TARGET_TYPE,
          INDEX_TYPE >(
              ret   ,
              target,
              index );
    }
    template<
      typename RET_TYPE    = GLboolean,
      typename TARGET_TYPE = GLenum   ,
      typename INDEX_TYPE  = GLuint   >
    inline std::shared_ptr<IsEnabledi<
      RET_TYPE   ,
      TARGET_TYPE,
      INDEX_TYPE >> sharedIsEnabledi(
        RET_TYPE    const&ret   ,
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ){
        return std::make_shared<IsEnabledi<
          RET_TYPE   ,
          TARGET_TYPE,
          INDEX_TYPE >>(
              ret   ,
              target,
              index );
    }

    template<
      typename TEXTURE_TYPE = GLuint  ,
      typename PNAME_TYPE   = GLenum  ,
      typename PARAMS_TYPE  = GLfloat*>
    inline GetTextureParameterfv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newGetTextureParameterfv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new GetTextureParameterfv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              texture,
              pname  ,
              params );
    }
    template<
      typename TEXTURE_TYPE = GLuint  ,
      typename PNAME_TYPE   = GLenum  ,
      typename PARAMS_TYPE  = GLfloat*>
    inline std::shared_ptr<GetTextureParameterfv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedGetTextureParameterfv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<GetTextureParameterfv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              texture,
              pname  ,
              params );
    }

    template<
      typename PROGRAM_TYPE     = GLuint       ,
      typename COLORNUMBER_TYPE = GLuint       ,
      typename INDEX_TYPE       = GLuint       ,
      typename NAME_TYPE        = const GLchar*>
    inline BindFragDataLocationIndexed<
      PROGRAM_TYPE    ,
      COLORNUMBER_TYPE,
      INDEX_TYPE      ,
      NAME_TYPE       >* newBindFragDataLocationIndexed(
        PROGRAM_TYPE     const&program    ,
        COLORNUMBER_TYPE const&colorNumber,
        INDEX_TYPE       const&index      ,
        NAME_TYPE        const&name       ){
        return new BindFragDataLocationIndexed<
          PROGRAM_TYPE    ,
          COLORNUMBER_TYPE,
          INDEX_TYPE      ,
          NAME_TYPE       >(
              program    ,
              colorNumber,
              index      ,
              name       );
    }
    template<
      typename PROGRAM_TYPE     = GLuint       ,
      typename COLORNUMBER_TYPE = GLuint       ,
      typename INDEX_TYPE       = GLuint       ,
      typename NAME_TYPE        = const GLchar*>
    inline std::shared_ptr<BindFragDataLocationIndexed<
      PROGRAM_TYPE    ,
      COLORNUMBER_TYPE,
      INDEX_TYPE      ,
      NAME_TYPE       >> sharedBindFragDataLocationIndexed(
        PROGRAM_TYPE     const&program    ,
        COLORNUMBER_TYPE const&colorNumber,
        INDEX_TYPE       const&index      ,
        NAME_TYPE        const&name       ){
        return std::make_shared<BindFragDataLocationIndexed<
          PROGRAM_TYPE    ,
          COLORNUMBER_TYPE,
          INDEX_TYPE      ,
          NAME_TYPE       >>(
              program    ,
              colorNumber,
              index      ,
              name       );
    }

    template<
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline Uniform2iv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform2iv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform2iv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline std::shared_ptr<Uniform2iv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform2iv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform2iv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    inline VertexAttrib1fv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib1fv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib1fv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    inline std::shared_ptr<VertexAttrib1fv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib1fv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib1fv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline Uniform4uiv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform4uiv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform4uiv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline std::shared_ptr<Uniform4uiv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform4uiv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform4uiv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename ZOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename DEPTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    inline TextureSubImage3D<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      DEPTH_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      PIXELS_TYPE >* newTextureSubImage3D(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        DEPTH_TYPE   const&depth  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        PIXELS_TYPE  const&pixels ){
        return new TextureSubImage3D<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          DEPTH_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          PIXELS_TYPE >(
              texture,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              width  ,
              height ,
              depth  ,
              format ,
              type   ,
              pixels );
    }
    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename ZOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename DEPTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    inline std::shared_ptr<TextureSubImage3D<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      DEPTH_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      PIXELS_TYPE >> sharedTextureSubImage3D(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        DEPTH_TYPE   const&depth  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        PIXELS_TYPE  const&pixels ){
        return std::make_shared<TextureSubImage3D<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          DEPTH_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          PIXELS_TYPE >>(
              texture,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              width  ,
              height ,
              depth  ,
              format ,
              type   ,
              pixels );
    }

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline VertexAttribL1dv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribL1dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribL1dv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline std::shared_ptr<VertexAttribL1dv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribL1dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribL1dv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename SHADER_TYPE = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetShaderiv<
      SHADER_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetShaderiv(
        SHADER_TYPE const&shader,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetShaderiv<
          SHADER_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              shader,
              pname ,
              params);
    }
    template<
      typename SHADER_TYPE = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetShaderiv<
      SHADER_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetShaderiv(
        SHADER_TYPE const&shader,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetShaderiv<
          SHADER_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              shader,
              pname ,
              params);
    }

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline ProgramUniformMatrix3fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix3fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix3fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<ProgramUniformMatrix3fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix3fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix3fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename PTR_TYPE    = const void*  ,
      typename LENGTH_TYPE = GLsizei      ,
      typename LABEL_TYPE  = const GLchar*>
    inline ObjectPtrLabel<
      PTR_TYPE   ,
      LENGTH_TYPE,
      LABEL_TYPE >* newObjectPtrLabel(
        PTR_TYPE    const&ptr   ,
        LENGTH_TYPE const&length,
        LABEL_TYPE  const&label ){
        return new ObjectPtrLabel<
          PTR_TYPE   ,
          LENGTH_TYPE,
          LABEL_TYPE >(
              ptr   ,
              length,
              label );
    }
    template<
      typename PTR_TYPE    = const void*  ,
      typename LENGTH_TYPE = GLsizei      ,
      typename LABEL_TYPE  = const GLchar*>
    inline std::shared_ptr<ObjectPtrLabel<
      PTR_TYPE   ,
      LENGTH_TYPE,
      LABEL_TYPE >> sharedObjectPtrLabel(
        PTR_TYPE    const&ptr   ,
        LENGTH_TYPE const&length,
        LABEL_TYPE  const&label ){
        return std::make_shared<ObjectPtrLabel<
          PTR_TYPE   ,
          LENGTH_TYPE,
          LABEL_TYPE >>(
              ptr   ,
              length,
              label );
    }

    template<
      typename TARGET_TYPE         = GLenum       ,
      typename NUMATTACHMENTS_TYPE = GLsizei      ,
      typename ATTACHMENTS_TYPE    = const GLenum*>
    inline InvalidateFramebuffer<
      TARGET_TYPE        ,
      NUMATTACHMENTS_TYPE,
      ATTACHMENTS_TYPE   >* newInvalidateFramebuffer(
        TARGET_TYPE         const&target        ,
        NUMATTACHMENTS_TYPE const&numAttachments,
        ATTACHMENTS_TYPE    const&attachments   ){
        return new InvalidateFramebuffer<
          TARGET_TYPE        ,
          NUMATTACHMENTS_TYPE,
          ATTACHMENTS_TYPE   >(
              target        ,
              numAttachments,
              attachments   );
    }
    template<
      typename TARGET_TYPE         = GLenum       ,
      typename NUMATTACHMENTS_TYPE = GLsizei      ,
      typename ATTACHMENTS_TYPE    = const GLenum*>
    inline std::shared_ptr<InvalidateFramebuffer<
      TARGET_TYPE        ,
      NUMATTACHMENTS_TYPE,
      ATTACHMENTS_TYPE   >> sharedInvalidateFramebuffer(
        TARGET_TYPE         const&target        ,
        NUMATTACHMENTS_TYPE const&numAttachments,
        ATTACHMENTS_TYPE    const&attachments   ){
        return std::make_shared<InvalidateFramebuffer<
          TARGET_TYPE        ,
          NUMATTACHMENTS_TYPE,
          ATTACHMENTS_TYPE   >>(
              target        ,
              numAttachments,
              attachments   );
    }

    template<
      typename FIRST_TYPE    = GLuint       ,
      typename COUNT_TYPE    = GLsizei      ,
      typename TEXTURES_TYPE = const GLuint*>
    inline BindTextures<
      FIRST_TYPE   ,
      COUNT_TYPE   ,
      TEXTURES_TYPE>* newBindTextures(
        FIRST_TYPE    const&first   ,
        COUNT_TYPE    const&count   ,
        TEXTURES_TYPE const&textures){
        return new BindTextures<
          FIRST_TYPE   ,
          COUNT_TYPE   ,
          TEXTURES_TYPE>(
              first   ,
              count   ,
              textures);
    }
    template<
      typename FIRST_TYPE    = GLuint       ,
      typename COUNT_TYPE    = GLsizei      ,
      typename TEXTURES_TYPE = const GLuint*>
    inline std::shared_ptr<BindTextures<
      FIRST_TYPE   ,
      COUNT_TYPE   ,
      TEXTURES_TYPE>> sharedBindTextures(
        FIRST_TYPE    const&first   ,
        COUNT_TYPE    const&count   ,
        TEXTURES_TYPE const&textures){
        return std::make_shared<BindTextures<
          FIRST_TYPE   ,
          COUNT_TYPE   ,
          TEXTURES_TYPE>>(
              first   ,
              count   ,
              textures);
    }

    template<
      typename PROGRAM_TYPE = GLuint       ,
      typename COLOR_TYPE   = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    inline BindFragDataLocation<
      PROGRAM_TYPE,
      COLOR_TYPE  ,
      NAME_TYPE   >* newBindFragDataLocation(
        PROGRAM_TYPE const&program,
        COLOR_TYPE   const&color  ,
        NAME_TYPE    const&name   ){
        return new BindFragDataLocation<
          PROGRAM_TYPE,
          COLOR_TYPE  ,
          NAME_TYPE   >(
              program,
              color  ,
              name   );
    }
    template<
      typename PROGRAM_TYPE = GLuint       ,
      typename COLOR_TYPE   = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    inline std::shared_ptr<BindFragDataLocation<
      PROGRAM_TYPE,
      COLOR_TYPE  ,
      NAME_TYPE   >> sharedBindFragDataLocation(
        PROGRAM_TYPE const&program,
        COLOR_TYPE   const&color  ,
        NAME_TYPE    const&name   ){
        return std::make_shared<BindFragDataLocation<
          PROGRAM_TYPE,
          COLOR_TYPE  ,
          NAME_TYPE   >>(
              program,
              color  ,
              name   );
    }

    template<
      typename BUFFER_TYPE = GLuint     ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*,
      typename FLAGS_TYPE  = GLbitfield >
    inline NamedBufferStorage<
      BUFFER_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  ,
      FLAGS_TYPE >* newNamedBufferStorage(
        BUFFER_TYPE const&buffer,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ,
        FLAGS_TYPE  const&flags ){
        return new NamedBufferStorage<
          BUFFER_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  ,
          FLAGS_TYPE >(
              buffer,
              size  ,
              data  ,
              flags );
    }
    template<
      typename BUFFER_TYPE = GLuint     ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*,
      typename FLAGS_TYPE  = GLbitfield >
    inline std::shared_ptr<NamedBufferStorage<
      BUFFER_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  ,
      FLAGS_TYPE >> sharedNamedBufferStorage(
        BUFFER_TYPE const&buffer,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ,
        FLAGS_TYPE  const&flags ){
        return std::make_shared<NamedBufferStorage<
          BUFFER_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  ,
          FLAGS_TYPE >>(
              buffer,
              size  ,
              data  ,
              flags );
    }

    template<
      typename TARGET_TYPE   = GLenum ,
      typename N_TYPE        = GLsizei,
      typename TEXTURES_TYPE = GLuint*>
    inline CreateTextures<
      TARGET_TYPE  ,
      N_TYPE       ,
      TEXTURES_TYPE>* newCreateTextures(
        TARGET_TYPE   const&target  ,
        N_TYPE        const&n       ,
        TEXTURES_TYPE const&textures){
        return new CreateTextures<
          TARGET_TYPE  ,
          N_TYPE       ,
          TEXTURES_TYPE>(
              target  ,
              n       ,
              textures);
    }
    template<
      typename TARGET_TYPE   = GLenum ,
      typename N_TYPE        = GLsizei,
      typename TEXTURES_TYPE = GLuint*>
    inline std::shared_ptr<CreateTextures<
      TARGET_TYPE  ,
      N_TYPE       ,
      TEXTURES_TYPE>> sharedCreateTextures(
        TARGET_TYPE   const&target  ,
        N_TYPE        const&n       ,
        TEXTURES_TYPE const&textures){
        return std::make_shared<CreateTextures<
          TARGET_TYPE  ,
          N_TYPE       ,
          TEXTURES_TYPE>>(
              target  ,
              n       ,
              textures);
    }

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename PARAMS_TYPE   = GLfloat*>
    inline GetUniformfv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      PARAMS_TYPE  >* newGetUniformfv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        PARAMS_TYPE   const&params  ){
        return new GetUniformfv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          PARAMS_TYPE  >(
              program ,
              location,
              params  );
    }
    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename PARAMS_TYPE   = GLfloat*>
    inline std::shared_ptr<GetUniformfv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      PARAMS_TYPE  >> sharedGetUniformfv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        PARAMS_TYPE   const&params  ){
        return std::make_shared<GetUniformfv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          PARAMS_TYPE  >>(
              program ,
              location,
              params  );
    }

    template<
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline Uniform1dv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform1dv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform1dv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline std::shared_ptr<Uniform1dv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform1dv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform1dv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename HEIGHT_TYPE         = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename IMAGESIZE_TYPE      = GLsizei    ,
      typename DATA_TYPE           = const void*>
    inline CompressedTexImage2D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      BORDER_TYPE        ,
      IMAGESIZE_TYPE     ,
      DATA_TYPE          >* newCompressedTexImage2D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        BORDER_TYPE         const&border        ,
        IMAGESIZE_TYPE      const&imageSize     ,
        DATA_TYPE           const&data          ){
        return new CompressedTexImage2D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          BORDER_TYPE        ,
          IMAGESIZE_TYPE     ,
          DATA_TYPE          >(
              target        ,
              level         ,
              internalformat,
              width         ,
              height        ,
              border        ,
              imageSize     ,
              data          );
    }
    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename HEIGHT_TYPE         = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename IMAGESIZE_TYPE      = GLsizei    ,
      typename DATA_TYPE           = const void*>
    inline std::shared_ptr<CompressedTexImage2D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      BORDER_TYPE        ,
      IMAGESIZE_TYPE     ,
      DATA_TYPE          >> sharedCompressedTexImage2D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        BORDER_TYPE         const&border        ,
        IMAGESIZE_TYPE      const&imageSize     ,
        DATA_TYPE           const&data          ){
        return std::make_shared<CompressedTexImage2D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          BORDER_TYPE        ,
          IMAGESIZE_TYPE     ,
          DATA_TYPE          >>(
              target        ,
              level         ,
              internalformat,
              width         ,
              height        ,
              border        ,
              imageSize     ,
              data          );
    }

    template<
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline Uniform4dv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform4dv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform4dv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline std::shared_ptr<Uniform4dv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform4dv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform4dv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename PROGRAM_TYPE  = GLuint         ,
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline ProgramUniform3dv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform3dv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform3dv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint         ,
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline std::shared_ptr<ProgramUniform3dv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform3dv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform3dv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename CAP_TYPE = GLenum>
    inline Disable<
      CAP_TYPE>* newDisable(
        CAP_TYPE const&cap){
        return new Disable<
          CAP_TYPE>(
              cap);
    }
    template<
      typename CAP_TYPE = GLenum>
    inline std::shared_ptr<Disable<
      CAP_TYPE>> sharedDisable(
        CAP_TYPE const&cap){
        return std::make_shared<Disable<
          CAP_TYPE>>(
              cap);
    }

    template<
      typename BUFFER_TYPE = GLuint>
    inline InvalidateBufferData<
      BUFFER_TYPE>* newInvalidateBufferData(
        BUFFER_TYPE const&buffer){
        return new InvalidateBufferData<
          BUFFER_TYPE>(
              buffer);
    }
    template<
      typename BUFFER_TYPE = GLuint>
    inline std::shared_ptr<InvalidateBufferData<
      BUFFER_TYPE>> sharedInvalidateBufferData(
        BUFFER_TYPE const&buffer){
        return std::make_shared<InvalidateBufferData<
          BUFFER_TYPE>>(
              buffer);
    }

    template<
      typename TEXTURE_TYPE   = GLuint     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    inline CompressedTextureSubImage1D<
      TEXTURE_TYPE  ,
      LEVEL_TYPE    ,
      XOFFSET_TYPE  ,
      WIDTH_TYPE    ,
      FORMAT_TYPE   ,
      IMAGESIZE_TYPE,
      DATA_TYPE     >* newCompressedTextureSubImage1D(
        TEXTURE_TYPE   const&texture  ,
        LEVEL_TYPE     const&level    ,
        XOFFSET_TYPE   const&xoffset  ,
        WIDTH_TYPE     const&width    ,
        FORMAT_TYPE    const&format   ,
        IMAGESIZE_TYPE const&imageSize,
        DATA_TYPE      const&data     ){
        return new CompressedTextureSubImage1D<
          TEXTURE_TYPE  ,
          LEVEL_TYPE    ,
          XOFFSET_TYPE  ,
          WIDTH_TYPE    ,
          FORMAT_TYPE   ,
          IMAGESIZE_TYPE,
          DATA_TYPE     >(
              texture  ,
              level    ,
              xoffset  ,
              width    ,
              format   ,
              imageSize,
              data     );
    }
    template<
      typename TEXTURE_TYPE   = GLuint     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    inline std::shared_ptr<CompressedTextureSubImage1D<
      TEXTURE_TYPE  ,
      LEVEL_TYPE    ,
      XOFFSET_TYPE  ,
      WIDTH_TYPE    ,
      FORMAT_TYPE   ,
      IMAGESIZE_TYPE,
      DATA_TYPE     >> sharedCompressedTextureSubImage1D(
        TEXTURE_TYPE   const&texture  ,
        LEVEL_TYPE     const&level    ,
        XOFFSET_TYPE   const&xoffset  ,
        WIDTH_TYPE     const&width    ,
        FORMAT_TYPE    const&format   ,
        IMAGESIZE_TYPE const&imageSize,
        DATA_TYPE      const&data     ){
        return std::make_shared<CompressedTextureSubImage1D<
          TEXTURE_TYPE  ,
          LEVEL_TYPE    ,
          XOFFSET_TYPE  ,
          WIDTH_TYPE    ,
          FORMAT_TYPE   ,
          IMAGESIZE_TYPE,
          DATA_TYPE     >>(
              texture  ,
              level    ,
              xoffset  ,
              width    ,
              format   ,
              imageSize,
              data     );
    }

    template<
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline Uniform3fv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform3fv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform3fv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline std::shared_ptr<Uniform3fv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform3fv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform3fv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename ID_TYPE     = GLuint>
    inline BeginQuery<
      TARGET_TYPE,
      ID_TYPE    >* newBeginQuery(
        TARGET_TYPE const&target,
        ID_TYPE     const&id    ){
        return new BeginQuery<
          TARGET_TYPE,
          ID_TYPE    >(
              target,
              id    );
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename ID_TYPE     = GLuint>
    inline std::shared_ptr<BeginQuery<
      TARGET_TYPE,
      ID_TYPE    >> sharedBeginQuery(
        TARGET_TYPE const&target,
        ID_TYPE     const&id    ){
        return std::make_shared<BeginQuery<
          TARGET_TYPE,
          ID_TYPE    >>(
              target,
              id    );
    }

    template<
      typename NEAR__TYPE = GLdouble,
      typename FAR__TYPE  = GLdouble>
    inline DepthRange<
      NEAR__TYPE,
      FAR__TYPE >* newDepthRange(
        NEAR__TYPE const&near_,
        FAR__TYPE  const&far_ ){
        return new DepthRange<
          NEAR__TYPE,
          FAR__TYPE >(
              near_,
              far_ );
    }
    template<
      typename NEAR__TYPE = GLdouble,
      typename FAR__TYPE  = GLdouble>
    inline std::shared_ptr<DepthRange<
      NEAR__TYPE,
      FAR__TYPE >> sharedDepthRange(
        NEAR__TYPE const&near_,
        FAR__TYPE  const&far_ ){
        return std::make_shared<DepthRange<
          NEAR__TYPE,
          FAR__TYPE >>(
              near_,
              far_ );
    }

    template<
      typename TARGET_TYPE         = GLenum       ,
      typename NUMATTACHMENTS_TYPE = GLsizei      ,
      typename ATTACHMENTS_TYPE    = const GLenum*,
      typename X_TYPE              = GLint        ,
      typename Y_TYPE              = GLint        ,
      typename WIDTH_TYPE          = GLsizei      ,
      typename HEIGHT_TYPE         = GLsizei      >
    inline InvalidateSubFramebuffer<
      TARGET_TYPE        ,
      NUMATTACHMENTS_TYPE,
      ATTACHMENTS_TYPE   ,
      X_TYPE             ,
      Y_TYPE             ,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >* newInvalidateSubFramebuffer(
        TARGET_TYPE         const&target        ,
        NUMATTACHMENTS_TYPE const&numAttachments,
        ATTACHMENTS_TYPE    const&attachments   ,
        X_TYPE              const&x             ,
        Y_TYPE              const&y             ,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return new InvalidateSubFramebuffer<
          TARGET_TYPE        ,
          NUMATTACHMENTS_TYPE,
          ATTACHMENTS_TYPE   ,
          X_TYPE             ,
          Y_TYPE             ,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >(
              target        ,
              numAttachments,
              attachments   ,
              x             ,
              y             ,
              width         ,
              height        );
    }
    template<
      typename TARGET_TYPE         = GLenum       ,
      typename NUMATTACHMENTS_TYPE = GLsizei      ,
      typename ATTACHMENTS_TYPE    = const GLenum*,
      typename X_TYPE              = GLint        ,
      typename Y_TYPE              = GLint        ,
      typename WIDTH_TYPE          = GLsizei      ,
      typename HEIGHT_TYPE         = GLsizei      >
    inline std::shared_ptr<InvalidateSubFramebuffer<
      TARGET_TYPE        ,
      NUMATTACHMENTS_TYPE,
      ATTACHMENTS_TYPE   ,
      X_TYPE             ,
      Y_TYPE             ,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >> sharedInvalidateSubFramebuffer(
        TARGET_TYPE         const&target        ,
        NUMATTACHMENTS_TYPE const&numAttachments,
        ATTACHMENTS_TYPE    const&attachments   ,
        X_TYPE              const&x             ,
        Y_TYPE              const&y             ,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return std::make_shared<InvalidateSubFramebuffer<
          TARGET_TYPE        ,
          NUMATTACHMENTS_TYPE,
          ATTACHMENTS_TYPE   ,
          X_TYPE             ,
          Y_TYPE             ,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >>(
              target        ,
              numAttachments,
              attachments   ,
              x             ,
              y             ,
              width         ,
              height        );
    }

    template<
      typename RET_TYPE    = void* ,
      typename TARGET_TYPE = GLenum,
      typename ACCESS_TYPE = GLenum>
    inline MapBuffer<
      RET_TYPE   ,
      TARGET_TYPE,
      ACCESS_TYPE>* newMapBuffer(
        RET_TYPE    const&ret   ,
        TARGET_TYPE const&target,
        ACCESS_TYPE const&access){
        return new MapBuffer<
          RET_TYPE   ,
          TARGET_TYPE,
          ACCESS_TYPE>(
              ret   ,
              target,
              access);
    }
    template<
      typename RET_TYPE    = void* ,
      typename TARGET_TYPE = GLenum,
      typename ACCESS_TYPE = GLenum>
    inline std::shared_ptr<MapBuffer<
      RET_TYPE   ,
      TARGET_TYPE,
      ACCESS_TYPE>> sharedMapBuffer(
        RET_TYPE    const&ret   ,
        TARGET_TYPE const&target,
        ACCESS_TYPE const&access){
        return std::make_shared<MapBuffer<
          RET_TYPE   ,
          TARGET_TYPE,
          ACCESS_TYPE>>(
              ret   ,
              target,
              access);
    }

    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename DATA_TYPE    = const void*>
    inline ClearTexImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      DATA_TYPE   >* newClearTexImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        DATA_TYPE    const&data   ){
        return new ClearTexImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          DATA_TYPE   >(
              texture,
              level  ,
              format ,
              type   ,
              data   );
    }
    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename DATA_TYPE    = const void*>
    inline std::shared_ptr<ClearTexImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      DATA_TYPE   >> sharedClearTexImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        DATA_TYPE    const&data   ){
        return std::make_shared<ClearTexImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          DATA_TYPE   >>(
              texture,
              level  ,
              format ,
              type   ,
              data   );
    }

    template<
      typename ATTRIBINDEX_TYPE    = GLuint,
      typename SIZE_TYPE           = GLint ,
      typename TYPE_TYPE           = GLenum,
      typename RELATIVEOFFSET_TYPE = GLuint>
    inline VertexAttribLFormat<
      ATTRIBINDEX_TYPE   ,
      SIZE_TYPE          ,
      TYPE_TYPE          ,
      RELATIVEOFFSET_TYPE>* newVertexAttribLFormat(
        ATTRIBINDEX_TYPE    const&attribindex   ,
        SIZE_TYPE           const&size          ,
        TYPE_TYPE           const&type          ,
        RELATIVEOFFSET_TYPE const&relativeoffset){
        return new VertexAttribLFormat<
          ATTRIBINDEX_TYPE   ,
          SIZE_TYPE          ,
          TYPE_TYPE          ,
          RELATIVEOFFSET_TYPE>(
              attribindex   ,
              size          ,
              type          ,
              relativeoffset);
    }
    template<
      typename ATTRIBINDEX_TYPE    = GLuint,
      typename SIZE_TYPE           = GLint ,
      typename TYPE_TYPE           = GLenum,
      typename RELATIVEOFFSET_TYPE = GLuint>
    inline std::shared_ptr<VertexAttribLFormat<
      ATTRIBINDEX_TYPE   ,
      SIZE_TYPE          ,
      TYPE_TYPE          ,
      RELATIVEOFFSET_TYPE>> sharedVertexAttribLFormat(
        ATTRIBINDEX_TYPE    const&attribindex   ,
        SIZE_TYPE           const&size          ,
        TYPE_TYPE           const&type          ,
        RELATIVEOFFSET_TYPE const&relativeoffset){
        return std::make_shared<VertexAttribLFormat<
          ATTRIBINDEX_TYPE   ,
          SIZE_TYPE          ,
          TYPE_TYPE          ,
          RELATIVEOFFSET_TYPE>>(
              attribindex   ,
              size          ,
              type          ,
              relativeoffset);
    }

    template<
      typename SOURCE_TYPE  = GLenum       ,
      typename ID_TYPE      = GLuint       ,
      typename LENGTH_TYPE  = GLsizei      ,
      typename MESSAGE_TYPE = const GLchar*>
    inline PushDebugGroup<
      SOURCE_TYPE ,
      ID_TYPE     ,
      LENGTH_TYPE ,
      MESSAGE_TYPE>* newPushDebugGroup(
        SOURCE_TYPE  const&source ,
        ID_TYPE      const&id     ,
        LENGTH_TYPE  const&length ,
        MESSAGE_TYPE const&message){
        return new PushDebugGroup<
          SOURCE_TYPE ,
          ID_TYPE     ,
          LENGTH_TYPE ,
          MESSAGE_TYPE>(
              source ,
              id     ,
              length ,
              message);
    }
    template<
      typename SOURCE_TYPE  = GLenum       ,
      typename ID_TYPE      = GLuint       ,
      typename LENGTH_TYPE  = GLsizei      ,
      typename MESSAGE_TYPE = const GLchar*>
    inline std::shared_ptr<PushDebugGroup<
      SOURCE_TYPE ,
      ID_TYPE     ,
      LENGTH_TYPE ,
      MESSAGE_TYPE>> sharedPushDebugGroup(
        SOURCE_TYPE  const&source ,
        ID_TYPE      const&id     ,
        LENGTH_TYPE  const&length ,
        MESSAGE_TYPE const&message){
        return std::make_shared<PushDebugGroup<
          SOURCE_TYPE ,
          ID_TYPE     ,
          LENGTH_TYPE ,
          MESSAGE_TYPE>>(
              source ,
              id     ,
              length ,
              message);
    }

    template<
      typename SYNC_TYPE = GLsync>
    inline DeleteSync<
      SYNC_TYPE>* newDeleteSync(
        SYNC_TYPE const&sync){
        return new DeleteSync<
          SYNC_TYPE>(
              sync);
    }
    template<
      typename SYNC_TYPE = GLsync>
    inline std::shared_ptr<DeleteSync<
      SYNC_TYPE>> sharedDeleteSync(
        SYNC_TYPE const&sync){
        return std::make_shared<DeleteSync<
          SYNC_TYPE>>(
              sync);
    }

    template<
      typename TARGET_TYPE  = GLenum ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei>
    inline CopyTexSubImage3D<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  ,
      HEIGHT_TYPE >* newCopyTexSubImage3D(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ){
        return new CopyTexSubImage3D<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  ,
          HEIGHT_TYPE >(
              target ,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              x      ,
              y      ,
              width  ,
              height );
    }
    template<
      typename TARGET_TYPE  = GLenum ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei>
    inline std::shared_ptr<CopyTexSubImage3D<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  ,
      HEIGHT_TYPE >> sharedCopyTexSubImage3D(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ){
        return std::make_shared<CopyTexSubImage3D<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  ,
          HEIGHT_TYPE >>(
              target ,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              x      ,
              y      ,
              width  ,
              height );
    }

    template<
      typename XFB_TYPE   = GLuint  ,
      typename PNAME_TYPE = GLenum  ,
      typename INDEX_TYPE = GLuint  ,
      typename PARAM_TYPE = GLint64*>
    inline GetTransformFeedbacki64_v<
      XFB_TYPE  ,
      PNAME_TYPE,
      INDEX_TYPE,
      PARAM_TYPE>* newGetTransformFeedbacki64_v(
        XFB_TYPE   const&xfb  ,
        PNAME_TYPE const&pname,
        INDEX_TYPE const&index,
        PARAM_TYPE const&param){
        return new GetTransformFeedbacki64_v<
          XFB_TYPE  ,
          PNAME_TYPE,
          INDEX_TYPE,
          PARAM_TYPE>(
              xfb  ,
              pname,
              index,
              param);
    }
    template<
      typename XFB_TYPE   = GLuint  ,
      typename PNAME_TYPE = GLenum  ,
      typename INDEX_TYPE = GLuint  ,
      typename PARAM_TYPE = GLint64*>
    inline std::shared_ptr<GetTransformFeedbacki64_v<
      XFB_TYPE  ,
      PNAME_TYPE,
      INDEX_TYPE,
      PARAM_TYPE>> sharedGetTransformFeedbacki64_v(
        XFB_TYPE   const&xfb  ,
        PNAME_TYPE const&pname,
        INDEX_TYPE const&index,
        PARAM_TYPE const&param){
        return std::make_shared<GetTransformFeedbacki64_v<
          XFB_TYPE  ,
          PNAME_TYPE,
          INDEX_TYPE,
          PARAM_TYPE>>(
              xfb  ,
              pname,
              index,
              param);
    }

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline UniformMatrix4dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix4dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix4dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<UniformMatrix4dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix4dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix4dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename INDEX_TYPE  = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetVertexAttribiv<
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetVertexAttribiv(
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetVertexAttribiv<
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              index ,
              pname ,
              params);
    }
    template<
      typename INDEX_TYPE  = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetVertexAttribiv<
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetVertexAttribiv(
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetVertexAttribiv<
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              index ,
              pname ,
              params);
    }

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline UniformMatrix4x2dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix4x2dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix4x2dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<UniformMatrix4x2dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix4x2dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix4x2dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename MODE_TYPE      = GLenum           ,
      typename COUNT_TYPE     = const GLsizei*   ,
      typename TYPE_TYPE      = GLenum           ,
      typename INDICES_TYPE   = const void*const*,
      typename DRAWCOUNT_TYPE = GLsizei          >
    inline MultiDrawElements<
      MODE_TYPE     ,
      COUNT_TYPE    ,
      TYPE_TYPE     ,
      INDICES_TYPE  ,
      DRAWCOUNT_TYPE>* newMultiDrawElements(
        MODE_TYPE      const&mode     ,
        COUNT_TYPE     const&count    ,
        TYPE_TYPE      const&type     ,
        INDICES_TYPE   const&indices  ,
        DRAWCOUNT_TYPE const&drawcount){
        return new MultiDrawElements<
          MODE_TYPE     ,
          COUNT_TYPE    ,
          TYPE_TYPE     ,
          INDICES_TYPE  ,
          DRAWCOUNT_TYPE>(
              mode     ,
              count    ,
              type     ,
              indices  ,
              drawcount);
    }
    template<
      typename MODE_TYPE      = GLenum           ,
      typename COUNT_TYPE     = const GLsizei*   ,
      typename TYPE_TYPE      = GLenum           ,
      typename INDICES_TYPE   = const void*const*,
      typename DRAWCOUNT_TYPE = GLsizei          >
    inline std::shared_ptr<MultiDrawElements<
      MODE_TYPE     ,
      COUNT_TYPE    ,
      TYPE_TYPE     ,
      INDICES_TYPE  ,
      DRAWCOUNT_TYPE>> sharedMultiDrawElements(
        MODE_TYPE      const&mode     ,
        COUNT_TYPE     const&count    ,
        TYPE_TYPE      const&type     ,
        INDICES_TYPE   const&indices  ,
        DRAWCOUNT_TYPE const&drawcount){
        return std::make_shared<MultiDrawElements<
          MODE_TYPE     ,
          COUNT_TYPE    ,
          TYPE_TYPE     ,
          INDICES_TYPE  ,
          DRAWCOUNT_TYPE>>(
              mode     ,
              count    ,
              type     ,
              indices  ,
              drawcount);
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    inline VertexAttrib3fv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib3fv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib3fv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    inline std::shared_ptr<VertexAttrib3fv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib3fv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib3fv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline Uniform3iv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform3iv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform3iv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline std::shared_ptr<Uniform3iv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform3iv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform3iv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename FACE_TYPE = GLenum,
      typename MODE_TYPE = GLenum>
    inline PolygonMode<
      FACE_TYPE,
      MODE_TYPE>* newPolygonMode(
        FACE_TYPE const&face,
        MODE_TYPE const&mode){
        return new PolygonMode<
          FACE_TYPE,
          MODE_TYPE>(
              face,
              mode);
    }
    template<
      typename FACE_TYPE = GLenum,
      typename MODE_TYPE = GLenum>
    inline std::shared_ptr<PolygonMode<
      FACE_TYPE,
      MODE_TYPE>> sharedPolygonMode(
        FACE_TYPE const&face,
        MODE_TYPE const&mode){
        return std::make_shared<PolygonMode<
          FACE_TYPE,
          MODE_TYPE>>(
              face,
              mode);
    }

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline ProgramUniformMatrix4dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix4dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix4dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<ProgramUniformMatrix4dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix4dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix4dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename PROGRAM_TYPE           = GLuint,
      typename UNIFORMBLOCKINDEX_TYPE = GLuint,
      typename PNAME_TYPE             = GLenum,
      typename PARAMS_TYPE            = GLint*>
    inline GetActiveUniformBlockiv<
      PROGRAM_TYPE          ,
      UNIFORMBLOCKINDEX_TYPE,
      PNAME_TYPE            ,
      PARAMS_TYPE           >* newGetActiveUniformBlockiv(
        PROGRAM_TYPE           const&program          ,
        UNIFORMBLOCKINDEX_TYPE const&uniformBlockIndex,
        PNAME_TYPE             const&pname            ,
        PARAMS_TYPE            const&params           ){
        return new GetActiveUniformBlockiv<
          PROGRAM_TYPE          ,
          UNIFORMBLOCKINDEX_TYPE,
          PNAME_TYPE            ,
          PARAMS_TYPE           >(
              program          ,
              uniformBlockIndex,
              pname            ,
              params           );
    }
    template<
      typename PROGRAM_TYPE           = GLuint,
      typename UNIFORMBLOCKINDEX_TYPE = GLuint,
      typename PNAME_TYPE             = GLenum,
      typename PARAMS_TYPE            = GLint*>
    inline std::shared_ptr<GetActiveUniformBlockiv<
      PROGRAM_TYPE          ,
      UNIFORMBLOCKINDEX_TYPE,
      PNAME_TYPE            ,
      PARAMS_TYPE           >> sharedGetActiveUniformBlockiv(
        PROGRAM_TYPE           const&program          ,
        UNIFORMBLOCKINDEX_TYPE const&uniformBlockIndex,
        PNAME_TYPE             const&pname            ,
        PARAMS_TYPE            const&params           ){
        return std::make_shared<GetActiveUniformBlockiv<
          PROGRAM_TYPE          ,
          UNIFORMBLOCKINDEX_TYPE,
          PNAME_TYPE            ,
          PARAMS_TYPE           >>(
              program          ,
              uniformBlockIndex,
              pname            ,
              params           );
    }

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename SRC_TYPE         = GLenum>
    inline NamedFramebufferReadBuffer<
      FRAMEBUFFER_TYPE,
      SRC_TYPE        >* newNamedFramebufferReadBuffer(
        FRAMEBUFFER_TYPE const&framebuffer,
        SRC_TYPE         const&src        ){
        return new NamedFramebufferReadBuffer<
          FRAMEBUFFER_TYPE,
          SRC_TYPE        >(
              framebuffer,
              src        );
    }
    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename SRC_TYPE         = GLenum>
    inline std::shared_ptr<NamedFramebufferReadBuffer<
      FRAMEBUFFER_TYPE,
      SRC_TYPE        >> sharedNamedFramebufferReadBuffer(
        FRAMEBUFFER_TYPE const&framebuffer,
        SRC_TYPE         const&src        ){
        return std::make_shared<NamedFramebufferReadBuffer<
          FRAMEBUFFER_TYPE,
          SRC_TYPE        >>(
              framebuffer,
              src        );
    }

    template<
      typename PROGRAM_TYPE  = GLuint      ,
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline ProgramUniform4iv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform4iv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform4iv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint      ,
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline std::shared_ptr<ProgramUniform4iv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform4iv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform4iv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline UniformMatrix2fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix2fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix2fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<UniformMatrix2fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix2fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix2fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename PROGRAM_TYPE = GLuint>
    inline UseProgram<
      PROGRAM_TYPE>* newUseProgram(
        PROGRAM_TYPE const&program){
        return new UseProgram<
          PROGRAM_TYPE>(
              program);
    }
    template<
      typename PROGRAM_TYPE = GLuint>
    inline std::shared_ptr<UseProgram<
      PROGRAM_TYPE>> sharedUseProgram(
        PROGRAM_TYPE const&program){
        return std::make_shared<UseProgram<
          PROGRAM_TYPE>>(
              program);
    }

    template<
      typename PROGRAM_TYPE = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename INFOLOG_TYPE = GLchar* >
    inline GetProgramInfoLog<
      PROGRAM_TYPE,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      INFOLOG_TYPE>* newGetProgramInfoLog(
        PROGRAM_TYPE const&program,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        INFOLOG_TYPE const&infoLog){
        return new GetProgramInfoLog<
          PROGRAM_TYPE,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          INFOLOG_TYPE>(
              program,
              bufSize,
              length ,
              infoLog);
    }
    template<
      typename PROGRAM_TYPE = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename INFOLOG_TYPE = GLchar* >
    inline std::shared_ptr<GetProgramInfoLog<
      PROGRAM_TYPE,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      INFOLOG_TYPE>> sharedGetProgramInfoLog(
        PROGRAM_TYPE const&program,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        INFOLOG_TYPE const&infoLog){
        return std::make_shared<GetProgramInfoLog<
          PROGRAM_TYPE,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          INFOLOG_TYPE>>(
              program,
              bufSize,
              length ,
              infoLog);
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename ID_TYPE     = GLuint>
    inline BindTransformFeedback<
      TARGET_TYPE,
      ID_TYPE    >* newBindTransformFeedback(
        TARGET_TYPE const&target,
        ID_TYPE     const&id    ){
        return new BindTransformFeedback<
          TARGET_TYPE,
          ID_TYPE    >(
              target,
              id    );
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename ID_TYPE     = GLuint>
    inline std::shared_ptr<BindTransformFeedback<
      TARGET_TYPE,
      ID_TYPE    >> sharedBindTransformFeedback(
        TARGET_TYPE const&target,
        ID_TYPE     const&id    ){
        return std::make_shared<BindTransformFeedback<
          TARGET_TYPE,
          ID_TYPE    >>(
              target,
              id    );
    }

    template<
      typename ARRAY_TYPE = GLuint>
    inline BindVertexArray<
      ARRAY_TYPE>* newBindVertexArray(
        ARRAY_TYPE const&array){
        return new BindVertexArray<
          ARRAY_TYPE>(
              array);
    }
    template<
      typename ARRAY_TYPE = GLuint>
    inline std::shared_ptr<BindVertexArray<
      ARRAY_TYPE>> sharedBindVertexArray(
        ARRAY_TYPE const&array){
        return std::make_shared<BindVertexArray<
          ARRAY_TYPE>>(
              array);
    }

    template<
      typename N_TYPE       = GLsizei      ,
      typename BUFFERS_TYPE = const GLuint*>
    inline DeleteBuffers<
      N_TYPE      ,
      BUFFERS_TYPE>* newDeleteBuffers(
        N_TYPE       const&n      ,
        BUFFERS_TYPE const&buffers){
        return new DeleteBuffers<
          N_TYPE      ,
          BUFFERS_TYPE>(
              n      ,
              buffers);
    }
    template<
      typename N_TYPE       = GLsizei      ,
      typename BUFFERS_TYPE = const GLuint*>
    inline std::shared_ptr<DeleteBuffers<
      N_TYPE      ,
      BUFFERS_TYPE>> sharedDeleteBuffers(
        N_TYPE       const&n      ,
        BUFFERS_TYPE const&buffers){
        return std::make_shared<DeleteBuffers<
          N_TYPE      ,
          BUFFERS_TYPE>>(
              n      ,
              buffers);
    }

    template<
      typename TEXTURE_TYPE = GLuint>
    inline GenerateTextureMipmap<
      TEXTURE_TYPE>* newGenerateTextureMipmap(
        TEXTURE_TYPE const&texture){
        return new GenerateTextureMipmap<
          TEXTURE_TYPE>(
              texture);
    }
    template<
      typename TEXTURE_TYPE = GLuint>
    inline std::shared_ptr<GenerateTextureMipmap<
      TEXTURE_TYPE>> sharedGenerateTextureMipmap(
        TEXTURE_TYPE const&texture){
        return std::make_shared<GenerateTextureMipmap<
          TEXTURE_TYPE>>(
              texture);
    }

    template<
      typename SAMPLER_TYPE = GLuint      ,
      typename PNAME_TYPE   = GLenum      ,
      typename PARAM_TYPE   = const GLint*>
    inline SamplerParameterIiv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >* newSamplerParameterIiv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return new SamplerParameterIiv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >(
              sampler,
              pname  ,
              param  );
    }
    template<
      typename SAMPLER_TYPE = GLuint      ,
      typename PNAME_TYPE   = GLenum      ,
      typename PARAM_TYPE   = const GLint*>
    inline std::shared_ptr<SamplerParameterIiv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >> sharedSamplerParameterIiv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return std::make_shared<SamplerParameterIiv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >>(
              sampler,
              pname  ,
              param  );
    }

    template<
      typename MODE_TYPE       = GLenum           ,
      typename COUNT_TYPE      = const GLsizei*   ,
      typename TYPE_TYPE       = GLenum           ,
      typename INDICES_TYPE    = const void*const*,
      typename DRAWCOUNT_TYPE  = GLsizei          ,
      typename BASEVERTEX_TYPE = const GLint*     >
    inline MultiDrawElementsBaseVertex<
      MODE_TYPE      ,
      COUNT_TYPE     ,
      TYPE_TYPE      ,
      INDICES_TYPE   ,
      DRAWCOUNT_TYPE ,
      BASEVERTEX_TYPE>* newMultiDrawElementsBaseVertex(
        MODE_TYPE       const&mode      ,
        COUNT_TYPE      const&count     ,
        TYPE_TYPE       const&type      ,
        INDICES_TYPE    const&indices   ,
        DRAWCOUNT_TYPE  const&drawcount ,
        BASEVERTEX_TYPE const&basevertex){
        return new MultiDrawElementsBaseVertex<
          MODE_TYPE      ,
          COUNT_TYPE     ,
          TYPE_TYPE      ,
          INDICES_TYPE   ,
          DRAWCOUNT_TYPE ,
          BASEVERTEX_TYPE>(
              mode      ,
              count     ,
              type      ,
              indices   ,
              drawcount ,
              basevertex);
    }
    template<
      typename MODE_TYPE       = GLenum           ,
      typename COUNT_TYPE      = const GLsizei*   ,
      typename TYPE_TYPE       = GLenum           ,
      typename INDICES_TYPE    = const void*const*,
      typename DRAWCOUNT_TYPE  = GLsizei          ,
      typename BASEVERTEX_TYPE = const GLint*     >
    inline std::shared_ptr<MultiDrawElementsBaseVertex<
      MODE_TYPE      ,
      COUNT_TYPE     ,
      TYPE_TYPE      ,
      INDICES_TYPE   ,
      DRAWCOUNT_TYPE ,
      BASEVERTEX_TYPE>> sharedMultiDrawElementsBaseVertex(
        MODE_TYPE       const&mode      ,
        COUNT_TYPE      const&count     ,
        TYPE_TYPE       const&type      ,
        INDICES_TYPE    const&indices   ,
        DRAWCOUNT_TYPE  const&drawcount ,
        BASEVERTEX_TYPE const&basevertex){
        return std::make_shared<MultiDrawElementsBaseVertex<
          MODE_TYPE      ,
          COUNT_TYPE     ,
          TYPE_TYPE      ,
          INDICES_TYPE   ,
          DRAWCOUNT_TYPE ,
          BASEVERTEX_TYPE>>(
              mode      ,
              count     ,
              type      ,
              indices   ,
              drawcount ,
              basevertex);
    }

    template<
      typename BUFFER_TYPE = GLuint     ,
      typename OFFSET_TYPE = GLintptr   ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*>
    inline NamedBufferSubData<
      BUFFER_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  >* newNamedBufferSubData(
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ){
        return new NamedBufferSubData<
          BUFFER_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  >(
              buffer,
              offset,
              size  ,
              data  );
    }
    template<
      typename BUFFER_TYPE = GLuint     ,
      typename OFFSET_TYPE = GLintptr   ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*>
    inline std::shared_ptr<NamedBufferSubData<
      BUFFER_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  >> sharedNamedBufferSubData(
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ){
        return std::make_shared<NamedBufferSubData<
          BUFFER_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  >>(
              buffer,
              offset,
              size  ,
              data  );
    }

    template<
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline Uniform2uiv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform2uiv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform2uiv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline std::shared_ptr<Uniform2uiv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform2uiv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform2uiv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename TARGET_TYPE    = GLenum     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    inline CompressedTexSubImage1D<
      TARGET_TYPE   ,
      LEVEL_TYPE    ,
      XOFFSET_TYPE  ,
      WIDTH_TYPE    ,
      FORMAT_TYPE   ,
      IMAGESIZE_TYPE,
      DATA_TYPE     >* newCompressedTexSubImage1D(
        TARGET_TYPE    const&target   ,
        LEVEL_TYPE     const&level    ,
        XOFFSET_TYPE   const&xoffset  ,
        WIDTH_TYPE     const&width    ,
        FORMAT_TYPE    const&format   ,
        IMAGESIZE_TYPE const&imageSize,
        DATA_TYPE      const&data     ){
        return new CompressedTexSubImage1D<
          TARGET_TYPE   ,
          LEVEL_TYPE    ,
          XOFFSET_TYPE  ,
          WIDTH_TYPE    ,
          FORMAT_TYPE   ,
          IMAGESIZE_TYPE,
          DATA_TYPE     >(
              target   ,
              level    ,
              xoffset  ,
              width    ,
              format   ,
              imageSize,
              data     );
    }
    template<
      typename TARGET_TYPE    = GLenum     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    inline std::shared_ptr<CompressedTexSubImage1D<
      TARGET_TYPE   ,
      LEVEL_TYPE    ,
      XOFFSET_TYPE  ,
      WIDTH_TYPE    ,
      FORMAT_TYPE   ,
      IMAGESIZE_TYPE,
      DATA_TYPE     >> sharedCompressedTexSubImage1D(
        TARGET_TYPE    const&target   ,
        LEVEL_TYPE     const&level    ,
        XOFFSET_TYPE   const&xoffset  ,
        WIDTH_TYPE     const&width    ,
        FORMAT_TYPE    const&format   ,
        IMAGESIZE_TYPE const&imageSize,
        DATA_TYPE      const&data     ){
        return std::make_shared<CompressedTexSubImage1D<
          TARGET_TYPE   ,
          LEVEL_TYPE    ,
          XOFFSET_TYPE  ,
          WIDTH_TYPE    ,
          FORMAT_TYPE   ,
          IMAGESIZE_TYPE,
          DATA_TYPE     >>(
              target   ,
              level    ,
              xoffset  ,
              width    ,
              format   ,
              imageSize,
              data     );
    }


    template<
      typename INDEX_TYPE = GLuint  ,
      typename N_TYPE     = GLdouble,
      typename F_TYPE     = GLdouble>
    inline DepthRangeIndexed<
      INDEX_TYPE,
      N_TYPE    ,
      F_TYPE    >* newDepthRangeIndexed(
        INDEX_TYPE const&index,
        N_TYPE     const&n    ,
        F_TYPE     const&f    ){
        return new DepthRangeIndexed<
          INDEX_TYPE,
          N_TYPE    ,
          F_TYPE    >(
              index,
              n    ,
              f    );
    }
    template<
      typename INDEX_TYPE = GLuint  ,
      typename N_TYPE     = GLdouble,
      typename F_TYPE     = GLdouble>
    inline std::shared_ptr<DepthRangeIndexed<
      INDEX_TYPE,
      N_TYPE    ,
      F_TYPE    >> sharedDepthRangeIndexed(
        INDEX_TYPE const&index,
        N_TYPE     const&n    ,
        F_TYPE     const&f    ){
        return std::make_shared<DepthRangeIndexed<
          INDEX_TYPE,
          N_TYPE    ,
          F_TYPE    >>(
              index,
              n    ,
              f    );
    }

    template<
      typename SHADER_TYPE = GLuint>
    inline DeleteShader<
      SHADER_TYPE>* newDeleteShader(
        SHADER_TYPE const&shader){
        return new DeleteShader<
          SHADER_TYPE>(
              shader);
    }
    template<
      typename SHADER_TYPE = GLuint>
    inline std::shared_ptr<DeleteShader<
      SHADER_TYPE>> sharedDeleteShader(
        SHADER_TYPE const&shader){
        return std::make_shared<DeleteShader<
          SHADER_TYPE>>(
              shader);
    }

    template<
      typename TARGET_TYPE         = GLenum  ,
      typename INTERNALFORMAT_TYPE = GLenum  ,
      typename PNAME_TYPE          = GLenum  ,
      typename BUFSIZE_TYPE        = GLsizei ,
      typename PARAMS_TYPE         = GLint64*>
    inline GetInternalformati64v<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      PNAME_TYPE         ,
      BUFSIZE_TYPE       ,
      PARAMS_TYPE        >* newGetInternalformati64v(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        PNAME_TYPE          const&pname         ,
        BUFSIZE_TYPE        const&bufSize       ,
        PARAMS_TYPE         const&params        ){
        return new GetInternalformati64v<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          PNAME_TYPE         ,
          BUFSIZE_TYPE       ,
          PARAMS_TYPE        >(
              target        ,
              internalformat,
              pname         ,
              bufSize       ,
              params        );
    }
    template<
      typename TARGET_TYPE         = GLenum  ,
      typename INTERNALFORMAT_TYPE = GLenum  ,
      typename PNAME_TYPE          = GLenum  ,
      typename BUFSIZE_TYPE        = GLsizei ,
      typename PARAMS_TYPE         = GLint64*>
    inline std::shared_ptr<GetInternalformati64v<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      PNAME_TYPE         ,
      BUFSIZE_TYPE       ,
      PARAMS_TYPE        >> sharedGetInternalformati64v(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        PNAME_TYPE          const&pname         ,
        BUFSIZE_TYPE        const&bufSize       ,
        PARAMS_TYPE         const&params        ){
        return std::make_shared<GetInternalformati64v<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          PNAME_TYPE         ,
          BUFSIZE_TYPE       ,
          PARAMS_TYPE        >>(
              target        ,
              internalformat,
              pname         ,
              bufSize       ,
              params        );
    }

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei>
    inline CopyTextureSubImage1D<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  >* newCopyTextureSubImage1D(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ){
        return new CopyTextureSubImage1D<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  >(
              texture,
              level  ,
              xoffset,
              x      ,
              y      ,
              width  );
    }
    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei>
    inline std::shared_ptr<CopyTextureSubImage1D<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  >> sharedCopyTextureSubImage1D(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ){
        return std::make_shared<CopyTextureSubImage1D<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  >>(
              texture,
              level  ,
              xoffset,
              x      ,
              y      ,
              width  );
    }

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename HEIGHT_TYPE         = GLsizei    ,
      typename DEPTH_TYPE          = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename IMAGESIZE_TYPE      = GLsizei    ,
      typename DATA_TYPE           = const void*>
    inline CompressedTexImage3D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      DEPTH_TYPE         ,
      BORDER_TYPE        ,
      IMAGESIZE_TYPE     ,
      DATA_TYPE          >* newCompressedTexImage3D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        DEPTH_TYPE          const&depth         ,
        BORDER_TYPE         const&border        ,
        IMAGESIZE_TYPE      const&imageSize     ,
        DATA_TYPE           const&data          ){
        return new CompressedTexImage3D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          DEPTH_TYPE         ,
          BORDER_TYPE        ,
          IMAGESIZE_TYPE     ,
          DATA_TYPE          >(
              target        ,
              level         ,
              internalformat,
              width         ,
              height        ,
              depth         ,
              border        ,
              imageSize     ,
              data          );
    }
    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename HEIGHT_TYPE         = GLsizei    ,
      typename DEPTH_TYPE          = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename IMAGESIZE_TYPE      = GLsizei    ,
      typename DATA_TYPE           = const void*>
    inline std::shared_ptr<CompressedTexImage3D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      DEPTH_TYPE         ,
      BORDER_TYPE        ,
      IMAGESIZE_TYPE     ,
      DATA_TYPE          >> sharedCompressedTexImage3D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        DEPTH_TYPE          const&depth         ,
        BORDER_TYPE         const&border        ,
        IMAGESIZE_TYPE      const&imageSize     ,
        DATA_TYPE           const&data          ){
        return std::make_shared<CompressedTexImage3D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          DEPTH_TYPE         ,
          BORDER_TYPE        ,
          IMAGESIZE_TYPE     ,
          DATA_TYPE          >>(
              target        ,
              level         ,
              internalformat,
              width         ,
              height        ,
              depth         ,
              border        ,
              imageSize     ,
              data          );
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    inline VertexAttrib4Nsv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4Nsv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4Nsv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    inline std::shared_ptr<VertexAttrib4Nsv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4Nsv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4Nsv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename RET_TYPE              = GLint        ,
      typename PROGRAM_TYPE          = GLuint       ,
      typename PROGRAMINTERFACE_TYPE = GLenum       ,
      typename NAME_TYPE             = const GLchar*>
    inline GetProgramResourceLocationIndex<
      RET_TYPE             ,
      PROGRAM_TYPE         ,
      PROGRAMINTERFACE_TYPE,
      NAME_TYPE            >* newGetProgramResourceLocationIndex(
        RET_TYPE              const&ret             ,
        PROGRAM_TYPE          const&program         ,
        PROGRAMINTERFACE_TYPE const&programInterface,
        NAME_TYPE             const&name            ){
        return new GetProgramResourceLocationIndex<
          RET_TYPE             ,
          PROGRAM_TYPE         ,
          PROGRAMINTERFACE_TYPE,
          NAME_TYPE            >(
              ret             ,
              program         ,
              programInterface,
              name            );
    }
    template<
      typename RET_TYPE              = GLint        ,
      typename PROGRAM_TYPE          = GLuint       ,
      typename PROGRAMINTERFACE_TYPE = GLenum       ,
      typename NAME_TYPE             = const GLchar*>
    inline std::shared_ptr<GetProgramResourceLocationIndex<
      RET_TYPE             ,
      PROGRAM_TYPE         ,
      PROGRAMINTERFACE_TYPE,
      NAME_TYPE            >> sharedGetProgramResourceLocationIndex(
        RET_TYPE              const&ret             ,
        PROGRAM_TYPE          const&program         ,
        PROGRAMINTERFACE_TYPE const&programInterface,
        NAME_TYPE             const&name            ){
        return std::make_shared<GetProgramResourceLocationIndex<
          RET_TYPE             ,
          PROGRAM_TYPE         ,
          PROGRAMINTERFACE_TYPE,
          NAME_TYPE            >>(
              ret             ,
              program         ,
              programInterface,
              name            );
    }

    template<
      typename TEXTURE_TYPE = GLuint       ,
      typename PNAME_TYPE   = GLenum       ,
      typename PARAMS_TYPE  = const GLuint*>
    inline TextureParameterIuiv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newTextureParameterIuiv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new TextureParameterIuiv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              texture,
              pname  ,
              params );
    }
    template<
      typename TEXTURE_TYPE = GLuint       ,
      typename PNAME_TYPE   = GLenum       ,
      typename PARAMS_TYPE  = const GLuint*>
    inline std::shared_ptr<TextureParameterIuiv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedTextureParameterIuiv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<TextureParameterIuiv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              texture,
              pname  ,
              params );
    }

    template<
      typename X_TYPE      = GLint  ,
      typename Y_TYPE      = GLint  ,
      typename WIDTH_TYPE  = GLsizei,
      typename HEIGHT_TYPE = GLsizei>
    inline Viewport<
      X_TYPE     ,
      Y_TYPE     ,
      WIDTH_TYPE ,
      HEIGHT_TYPE>* newViewport(
        X_TYPE      const&x     ,
        Y_TYPE      const&y     ,
        WIDTH_TYPE  const&width ,
        HEIGHT_TYPE const&height){
        return new Viewport<
          X_TYPE     ,
          Y_TYPE     ,
          WIDTH_TYPE ,
          HEIGHT_TYPE>(
              x     ,
              y     ,
              width ,
              height);
    }
    template<
      typename X_TYPE      = GLint  ,
      typename Y_TYPE      = GLint  ,
      typename WIDTH_TYPE  = GLsizei,
      typename HEIGHT_TYPE = GLsizei>
    inline std::shared_ptr<Viewport<
      X_TYPE     ,
      Y_TYPE     ,
      WIDTH_TYPE ,
      HEIGHT_TYPE>> sharedViewport(
        X_TYPE      const&x     ,
        Y_TYPE      const&y     ,
        WIDTH_TYPE  const&width ,
        HEIGHT_TYPE const&height){
        return std::make_shared<Viewport<
          X_TYPE     ,
          Y_TYPE     ,
          WIDTH_TYPE ,
          HEIGHT_TYPE>>(
              x     ,
              y     ,
              width ,
              height);
    }

    template<
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline Uniform1uiv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform1uiv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform1uiv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline std::shared_ptr<Uniform1uiv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform1uiv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform1uiv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename PROGRAM_TYPE    = GLuint             ,
      typename COUNT_TYPE      = GLsizei            ,
      typename VARYINGS_TYPE   = const GLchar*const*,
      typename BUFFERMODE_TYPE = GLenum             >
    inline TransformFeedbackVaryings<
      PROGRAM_TYPE   ,
      COUNT_TYPE     ,
      VARYINGS_TYPE  ,
      BUFFERMODE_TYPE>* newTransformFeedbackVaryings(
        PROGRAM_TYPE    const&program   ,
        COUNT_TYPE      const&count     ,
        VARYINGS_TYPE   const&varyings  ,
        BUFFERMODE_TYPE const&bufferMode){
        return new TransformFeedbackVaryings<
          PROGRAM_TYPE   ,
          COUNT_TYPE     ,
          VARYINGS_TYPE  ,
          BUFFERMODE_TYPE>(
              program   ,
              count     ,
              varyings  ,
              bufferMode);
    }
    template<
      typename PROGRAM_TYPE    = GLuint             ,
      typename COUNT_TYPE      = GLsizei            ,
      typename VARYINGS_TYPE   = const GLchar*const*,
      typename BUFFERMODE_TYPE = GLenum             >
    inline std::shared_ptr<TransformFeedbackVaryings<
      PROGRAM_TYPE   ,
      COUNT_TYPE     ,
      VARYINGS_TYPE  ,
      BUFFERMODE_TYPE>> sharedTransformFeedbackVaryings(
        PROGRAM_TYPE    const&program   ,
        COUNT_TYPE      const&count     ,
        VARYINGS_TYPE   const&varyings  ,
        BUFFERMODE_TYPE const&bufferMode){
        return std::make_shared<TransformFeedbackVaryings<
          PROGRAM_TYPE   ,
          COUNT_TYPE     ,
          VARYINGS_TYPE  ,
          BUFFERMODE_TYPE>>(
              program   ,
              count     ,
              varyings  ,
              bufferMode);
    }

    template<
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint>
    inline Uniform2ui<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >* newUniform2ui(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return new Uniform2ui<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >(
              location,
              v0      ,
              v1      );
    }
    template<
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint>
    inline std::shared_ptr<Uniform2ui<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >> sharedUniform2ui(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return std::make_shared<Uniform2ui<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >>(
              location,
              v0      ,
              v1      );
    }

    template<
      typename CALLBACK_TYPE  = GLDEBUGPROC,
      typename USERPARAM_TYPE = const void*>
    inline DebugMessageCallback<
      CALLBACK_TYPE ,
      USERPARAM_TYPE>* newDebugMessageCallback(
        CALLBACK_TYPE  const&callback ,
        USERPARAM_TYPE const&userParam){
        return new DebugMessageCallback<
          CALLBACK_TYPE ,
          USERPARAM_TYPE>(
              callback ,
              userParam);
    }
    template<
      typename CALLBACK_TYPE  = GLDEBUGPROC,
      typename USERPARAM_TYPE = const void*>
    inline std::shared_ptr<DebugMessageCallback<
      CALLBACK_TYPE ,
      USERPARAM_TYPE>> sharedDebugMessageCallback(
        CALLBACK_TYPE  const&callback ,
        USERPARAM_TYPE const&userParam){
        return std::make_shared<DebugMessageCallback<
          CALLBACK_TYPE ,
          USERPARAM_TYPE>>(
              callback ,
              userParam);
    }

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLint ,
      typename Y_TYPE     = GLint ,
      typename Z_TYPE     = GLint >
    inline VertexAttribI3i<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    >* newVertexAttribI3i(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ){
        return new VertexAttribI3i<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    >(
              index,
              x    ,
              y    ,
              z    );
    }
    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLint ,
      typename Y_TYPE     = GLint ,
      typename Z_TYPE     = GLint >
    inline std::shared_ptr<VertexAttribI3i<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    >> sharedVertexAttribI3i(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ){
        return std::make_shared<VertexAttribI3i<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    >>(
              index,
              x    ,
              y    ,
              z    );
    }

    template<
      typename TEXTURE_TYPE = GLuint,
      typename LEVEL_TYPE   = GLint >
    inline InvalidateTexImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  >* newInvalidateTexImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ){
        return new InvalidateTexImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  >(
              texture,
              level  );
    }
    template<
      typename TEXTURE_TYPE = GLuint,
      typename LEVEL_TYPE   = GLint >
    inline std::shared_ptr<InvalidateTexImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  >> sharedInvalidateTexImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ){
        return std::make_shared<InvalidateTexImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  >>(
              texture,
              level  );
    }

    template<
      typename ATTRIBINDEX_TYPE    = GLuint   ,
      typename SIZE_TYPE           = GLint    ,
      typename TYPE_TYPE           = GLenum   ,
      typename NORMALIZED_TYPE     = GLboolean,
      typename RELATIVEOFFSET_TYPE = GLuint   >
    inline VertexAttribFormat<
      ATTRIBINDEX_TYPE   ,
      SIZE_TYPE          ,
      TYPE_TYPE          ,
      NORMALIZED_TYPE    ,
      RELATIVEOFFSET_TYPE>* newVertexAttribFormat(
        ATTRIBINDEX_TYPE    const&attribindex   ,
        SIZE_TYPE           const&size          ,
        TYPE_TYPE           const&type          ,
        NORMALIZED_TYPE     const&normalized    ,
        RELATIVEOFFSET_TYPE const&relativeoffset){
        return new VertexAttribFormat<
          ATTRIBINDEX_TYPE   ,
          SIZE_TYPE          ,
          TYPE_TYPE          ,
          NORMALIZED_TYPE    ,
          RELATIVEOFFSET_TYPE>(
              attribindex   ,
              size          ,
              type          ,
              normalized    ,
              relativeoffset);
    }
    template<
      typename ATTRIBINDEX_TYPE    = GLuint   ,
      typename SIZE_TYPE           = GLint    ,
      typename TYPE_TYPE           = GLenum   ,
      typename NORMALIZED_TYPE     = GLboolean,
      typename RELATIVEOFFSET_TYPE = GLuint   >
    inline std::shared_ptr<VertexAttribFormat<
      ATTRIBINDEX_TYPE   ,
      SIZE_TYPE          ,
      TYPE_TYPE          ,
      NORMALIZED_TYPE    ,
      RELATIVEOFFSET_TYPE>> sharedVertexAttribFormat(
        ATTRIBINDEX_TYPE    const&attribindex   ,
        SIZE_TYPE           const&size          ,
        TYPE_TYPE           const&type          ,
        NORMALIZED_TYPE     const&normalized    ,
        RELATIVEOFFSET_TYPE const&relativeoffset){
        return std::make_shared<VertexAttribFormat<
          ATTRIBINDEX_TYPE   ,
          SIZE_TYPE          ,
          TYPE_TYPE          ,
          NORMALIZED_TYPE    ,
          RELATIVEOFFSET_TYPE>>(
              attribindex   ,
              size          ,
              type          ,
              normalized    ,
              relativeoffset);
    }

    template<
      typename TARGET_TYPE               = GLenum   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    inline TexStorage2DMultisample<
      TARGET_TYPE              ,
      SAMPLES_TYPE             ,
      INTERNALFORMAT_TYPE      ,
      WIDTH_TYPE               ,
      HEIGHT_TYPE              ,
      FIXEDSAMPLELOCATIONS_TYPE>* newTexStorage2DMultisample(
        TARGET_TYPE               const&target              ,
        SAMPLES_TYPE              const&samples             ,
        INTERNALFORMAT_TYPE       const&internalformat      ,
        WIDTH_TYPE                const&width               ,
        HEIGHT_TYPE               const&height              ,
        FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
        return new TexStorage2DMultisample<
          TARGET_TYPE              ,
          SAMPLES_TYPE             ,
          INTERNALFORMAT_TYPE      ,
          WIDTH_TYPE               ,
          HEIGHT_TYPE              ,
          FIXEDSAMPLELOCATIONS_TYPE>(
              target              ,
              samples             ,
              internalformat      ,
              width               ,
              height              ,
              fixedsamplelocations);
    }
    template<
      typename TARGET_TYPE               = GLenum   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    inline std::shared_ptr<TexStorage2DMultisample<
      TARGET_TYPE              ,
      SAMPLES_TYPE             ,
      INTERNALFORMAT_TYPE      ,
      WIDTH_TYPE               ,
      HEIGHT_TYPE              ,
      FIXEDSAMPLELOCATIONS_TYPE>> sharedTexStorage2DMultisample(
        TARGET_TYPE               const&target              ,
        SAMPLES_TYPE              const&samples             ,
        INTERNALFORMAT_TYPE       const&internalformat      ,
        WIDTH_TYPE                const&width               ,
        HEIGHT_TYPE               const&height              ,
        FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
        return std::make_shared<TexStorage2DMultisample<
          TARGET_TYPE              ,
          SAMPLES_TYPE             ,
          INTERNALFORMAT_TYPE      ,
          WIDTH_TYPE               ,
          HEIGHT_TYPE              ,
          FIXEDSAMPLELOCATIONS_TYPE>>(
              target              ,
              samples             ,
              internalformat      ,
              width               ,
              height              ,
              fixedsamplelocations);
    }

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLushort*>
    inline VertexAttribI4usv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribI4usv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribI4usv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLushort*>
    inline std::shared_ptr<VertexAttribI4usv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribI4usv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribI4usv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename TARGET_TYPE = GLenum ,
      typename PNAME_TYPE  = GLenum ,
      typename PARAM_TYPE  = GLfloat>
    inline TexParameterf<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAM_TYPE >* newTexParameterf(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAM_TYPE  const&param ){
        return new TexParameterf<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAM_TYPE >(
              target,
              pname ,
              param );
    }
    template<
      typename TARGET_TYPE = GLenum ,
      typename PNAME_TYPE  = GLenum ,
      typename PARAM_TYPE  = GLfloat>
    inline std::shared_ptr<TexParameterf<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAM_TYPE >> sharedTexParameterf(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAM_TYPE  const&param ){
        return std::make_shared<TexParameterf<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAM_TYPE >>(
              target,
              pname ,
              param );
    }

    template<
      typename ATTRIBINDEX_TYPE  = GLuint,
      typename BINDINGINDEX_TYPE = GLuint>
    inline VertexAttribBinding<
      ATTRIBINDEX_TYPE ,
      BINDINGINDEX_TYPE>* newVertexAttribBinding(
        ATTRIBINDEX_TYPE  const&attribindex ,
        BINDINGINDEX_TYPE const&bindingindex){
        return new VertexAttribBinding<
          ATTRIBINDEX_TYPE ,
          BINDINGINDEX_TYPE>(
              attribindex ,
              bindingindex);
    }
    template<
      typename ATTRIBINDEX_TYPE  = GLuint,
      typename BINDINGINDEX_TYPE = GLuint>
    inline std::shared_ptr<VertexAttribBinding<
      ATTRIBINDEX_TYPE ,
      BINDINGINDEX_TYPE>> sharedVertexAttribBinding(
        ATTRIBINDEX_TYPE  const&attribindex ,
        BINDINGINDEX_TYPE const&bindingindex){
        return std::make_shared<VertexAttribBinding<
          ATTRIBINDEX_TYPE ,
          BINDINGINDEX_TYPE>>(
              attribindex ,
              bindingindex);
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAM_TYPE  = GLint >
    inline TexParameteri<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAM_TYPE >* newTexParameteri(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAM_TYPE  const&param ){
        return new TexParameteri<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAM_TYPE >(
              target,
              pname ,
              param );
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAM_TYPE  = GLint >
    inline std::shared_ptr<TexParameteri<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAM_TYPE >> sharedTexParameteri(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAM_TYPE  const&param ){
        return std::make_shared<TexParameteri<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAM_TYPE >>(
              target,
              pname ,
              param );
    }

    template<
      typename PROGRAM_TYPE    = GLuint,
      typename SHADERTYPE_TYPE = GLenum,
      typename INDEX_TYPE      = GLuint,
      typename PNAME_TYPE      = GLenum,
      typename VALUES_TYPE     = GLint*>
    inline GetActiveSubroutineUniformiv<
      PROGRAM_TYPE   ,
      SHADERTYPE_TYPE,
      INDEX_TYPE     ,
      PNAME_TYPE     ,
      VALUES_TYPE    >* newGetActiveSubroutineUniformiv(
        PROGRAM_TYPE    const&program   ,
        SHADERTYPE_TYPE const&shadertype,
        INDEX_TYPE      const&index     ,
        PNAME_TYPE      const&pname     ,
        VALUES_TYPE     const&values    ){
        return new GetActiveSubroutineUniformiv<
          PROGRAM_TYPE   ,
          SHADERTYPE_TYPE,
          INDEX_TYPE     ,
          PNAME_TYPE     ,
          VALUES_TYPE    >(
              program   ,
              shadertype,
              index     ,
              pname     ,
              values    );
    }
    template<
      typename PROGRAM_TYPE    = GLuint,
      typename SHADERTYPE_TYPE = GLenum,
      typename INDEX_TYPE      = GLuint,
      typename PNAME_TYPE      = GLenum,
      typename VALUES_TYPE     = GLint*>
    inline std::shared_ptr<GetActiveSubroutineUniformiv<
      PROGRAM_TYPE   ,
      SHADERTYPE_TYPE,
      INDEX_TYPE     ,
      PNAME_TYPE     ,
      VALUES_TYPE    >> sharedGetActiveSubroutineUniformiv(
        PROGRAM_TYPE    const&program   ,
        SHADERTYPE_TYPE const&shadertype,
        INDEX_TYPE      const&index     ,
        PNAME_TYPE      const&pname     ,
        VALUES_TYPE     const&values    ){
        return std::make_shared<GetActiveSubroutineUniformiv<
          PROGRAM_TYPE   ,
          SHADERTYPE_TYPE,
          INDEX_TYPE     ,
          PNAME_TYPE     ,
          VALUES_TYPE    >>(
              program   ,
              shadertype,
              index     ,
              pname     ,
              values    );
    }

    template<
      typename SHADER_TYPE  = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename SOURCE_TYPE  = GLchar* >
    inline GetShaderSource<
      SHADER_TYPE ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      SOURCE_TYPE >* newGetShaderSource(
        SHADER_TYPE  const&shader ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        SOURCE_TYPE  const&source ){
        return new GetShaderSource<
          SHADER_TYPE ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          SOURCE_TYPE >(
              shader ,
              bufSize,
              length ,
              source );
    }
    template<
      typename SHADER_TYPE  = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename SOURCE_TYPE  = GLchar* >
    inline std::shared_ptr<GetShaderSource<
      SHADER_TYPE ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      SOURCE_TYPE >> sharedGetShaderSource(
        SHADER_TYPE  const&shader ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        SOURCE_TYPE  const&source ){
        return std::make_shared<GetShaderSource<
          SHADER_TYPE ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          SOURCE_TYPE >>(
              shader ,
              bufSize,
              length ,
              source );
    }

    template<
      typename TARGET_TYPE         = GLenum,
      typename INTERNALFORMAT_TYPE = GLenum,
      typename BUFFER_TYPE         = GLuint>
    inline TexBuffer<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      BUFFER_TYPE        >* newTexBuffer(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        BUFFER_TYPE         const&buffer        ){
        return new TexBuffer<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          BUFFER_TYPE        >(
              target        ,
              internalformat,
              buffer        );
    }
    template<
      typename TARGET_TYPE         = GLenum,
      typename INTERNALFORMAT_TYPE = GLenum,
      typename BUFFER_TYPE         = GLuint>
    inline std::shared_ptr<TexBuffer<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      BUFFER_TYPE        >> sharedTexBuffer(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        BUFFER_TYPE         const&buffer        ){
        return std::make_shared<TexBuffer<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          BUFFER_TYPE        >>(
              target        ,
              internalformat,
              buffer        );
    }

    template<
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint >
    inline PixelStorei<
      PNAME_TYPE,
      PARAM_TYPE>* newPixelStorei(
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return new PixelStorei<
          PNAME_TYPE,
          PARAM_TYPE>(
              pname,
              param);
    }
    template<
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint >
    inline std::shared_ptr<PixelStorei<
      PNAME_TYPE,
      PARAM_TYPE>> sharedPixelStorei(
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return std::make_shared<PixelStorei<
          PNAME_TYPE,
          PARAM_TYPE>>(
              pname,
              param);
    }

    template<
      typename PROGRAM_TYPE = GLuint>
    inline ValidateProgram<
      PROGRAM_TYPE>* newValidateProgram(
        PROGRAM_TYPE const&program){
        return new ValidateProgram<
          PROGRAM_TYPE>(
              program);
    }
    template<
      typename PROGRAM_TYPE = GLuint>
    inline std::shared_ptr<ValidateProgram<
      PROGRAM_TYPE>> sharedValidateProgram(
        PROGRAM_TYPE const&program){
        return std::make_shared<ValidateProgram<
          PROGRAM_TYPE>>(
              program);
    }

    template<
      typename PNAME_TYPE = GLenum ,
      typename PARAM_TYPE = GLfloat>
    inline PixelStoref<
      PNAME_TYPE,
      PARAM_TYPE>* newPixelStoref(
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return new PixelStoref<
          PNAME_TYPE,
          PARAM_TYPE>(
              pname,
              param);
    }
    template<
      typename PNAME_TYPE = GLenum ,
      typename PARAM_TYPE = GLfloat>
    inline std::shared_ptr<PixelStoref<
      PNAME_TYPE,
      PARAM_TYPE>> sharedPixelStoref(
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return std::make_shared<PixelStoref<
          PNAME_TYPE,
          PARAM_TYPE>>(
              pname,
              param);
    }

    template<
      typename N_TYPE       = GLsizei,
      typename BUFFERS_TYPE = GLuint*>
    inline CreateBuffers<
      N_TYPE      ,
      BUFFERS_TYPE>* newCreateBuffers(
        N_TYPE       const&n      ,
        BUFFERS_TYPE const&buffers){
        return new CreateBuffers<
          N_TYPE      ,
          BUFFERS_TYPE>(
              n      ,
              buffers);
    }
    template<
      typename N_TYPE       = GLsizei,
      typename BUFFERS_TYPE = GLuint*>
    inline std::shared_ptr<CreateBuffers<
      N_TYPE      ,
      BUFFERS_TYPE>> sharedCreateBuffers(
        N_TYPE       const&n      ,
        BUFFERS_TYPE const&buffers){
        return std::make_shared<CreateBuffers<
          N_TYPE      ,
          BUFFERS_TYPE>>(
              n      ,
              buffers);
    }

    template<
      typename TARGET_TYPE = GLenum    ,
      typename INDEX_TYPE  = GLuint    ,
      typename DATA_TYPE   = GLboolean*>
    inline GetBooleani_v<
      TARGET_TYPE,
      INDEX_TYPE ,
      DATA_TYPE  >* newGetBooleani_v(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        DATA_TYPE   const&data  ){
        return new GetBooleani_v<
          TARGET_TYPE,
          INDEX_TYPE ,
          DATA_TYPE  >(
              target,
              index ,
              data  );
    }
    template<
      typename TARGET_TYPE = GLenum    ,
      typename INDEX_TYPE  = GLuint    ,
      typename DATA_TYPE   = GLboolean*>
    inline std::shared_ptr<GetBooleani_v<
      TARGET_TYPE,
      INDEX_TYPE ,
      DATA_TYPE  >> sharedGetBooleani_v(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        DATA_TYPE   const&data  ){
        return std::make_shared<GetBooleani_v<
          TARGET_TYPE,
          INDEX_TYPE ,
          DATA_TYPE  >>(
              target,
              index ,
              data  );
    }

    template<
      typename ORIGIN_TYPE = GLenum,
      typename DEPTH_TYPE  = GLenum>
    inline ClipControl<
      ORIGIN_TYPE,
      DEPTH_TYPE >* newClipControl(
        ORIGIN_TYPE const&origin,
        DEPTH_TYPE  const&depth ){
        return new ClipControl<
          ORIGIN_TYPE,
          DEPTH_TYPE >(
              origin,
              depth );
    }
    template<
      typename ORIGIN_TYPE = GLenum,
      typename DEPTH_TYPE  = GLenum>
    inline std::shared_ptr<ClipControl<
      ORIGIN_TYPE,
      DEPTH_TYPE >> sharedClipControl(
        ORIGIN_TYPE const&origin,
        DEPTH_TYPE  const&depth ){
        return std::make_shared<ClipControl<
          ORIGIN_TYPE,
          DEPTH_TYPE >>(
              origin,
              depth );
    }

    template<
      typename N_TYPE         = GLsizei,
      typename PIPELINES_TYPE = GLuint*>
    inline GenProgramPipelines<
      N_TYPE        ,
      PIPELINES_TYPE>* newGenProgramPipelines(
        N_TYPE         const&n        ,
        PIPELINES_TYPE const&pipelines){
        return new GenProgramPipelines<
          N_TYPE        ,
          PIPELINES_TYPE>(
              n        ,
              pipelines);
    }
    template<
      typename N_TYPE         = GLsizei,
      typename PIPELINES_TYPE = GLuint*>
    inline std::shared_ptr<GenProgramPipelines<
      N_TYPE        ,
      PIPELINES_TYPE>> sharedGenProgramPipelines(
        N_TYPE         const&n        ,
        PIPELINES_TYPE const&pipelines){
        return std::make_shared<GenProgramPipelines<
          N_TYPE        ,
          PIPELINES_TYPE>>(
              n        ,
              pipelines);
    }

    template<
      typename TARGET_TYPE         = GLenum ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename PNAME_TYPE          = GLenum ,
      typename BUFSIZE_TYPE        = GLsizei,
      typename PARAMS_TYPE         = GLint* >
    inline GetInternalformativ<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      PNAME_TYPE         ,
      BUFSIZE_TYPE       ,
      PARAMS_TYPE        >* newGetInternalformativ(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        PNAME_TYPE          const&pname         ,
        BUFSIZE_TYPE        const&bufSize       ,
        PARAMS_TYPE         const&params        ){
        return new GetInternalformativ<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          PNAME_TYPE         ,
          BUFSIZE_TYPE       ,
          PARAMS_TYPE        >(
              target        ,
              internalformat,
              pname         ,
              bufSize       ,
              params        );
    }
    template<
      typename TARGET_TYPE         = GLenum ,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename PNAME_TYPE          = GLenum ,
      typename BUFSIZE_TYPE        = GLsizei,
      typename PARAMS_TYPE         = GLint* >
    inline std::shared_ptr<GetInternalformativ<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      PNAME_TYPE         ,
      BUFSIZE_TYPE       ,
      PARAMS_TYPE        >> sharedGetInternalformativ(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        PNAME_TYPE          const&pname         ,
        BUFSIZE_TYPE        const&bufSize       ,
        PARAMS_TYPE         const&params        ){
        return std::make_shared<GetInternalformativ<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          PNAME_TYPE         ,
          BUFSIZE_TYPE       ,
          PARAMS_TYPE        >>(
              target        ,
              internalformat,
              pname         ,
              bufSize       ,
              params        );
    }

    template<
      typename PNAME_TYPE = GLenum  ,
      typename DATA_TYPE  = GLfloat*>
    inline GetFloatv<
      PNAME_TYPE,
      DATA_TYPE >* newGetFloatv(
        PNAME_TYPE const&pname,
        DATA_TYPE  const&data ){
        return new GetFloatv<
          PNAME_TYPE,
          DATA_TYPE >(
              pname,
              data );
    }
    template<
      typename PNAME_TYPE = GLenum  ,
      typename DATA_TYPE  = GLfloat*>
    inline std::shared_ptr<GetFloatv<
      PNAME_TYPE,
      DATA_TYPE >> sharedGetFloatv(
        PNAME_TYPE const&pname,
        DATA_TYPE  const&data ){
        return std::make_shared<GetFloatv<
          PNAME_TYPE,
          DATA_TYPE >>(
              pname,
              data );
    }

    template<
      typename INDEX_TYPE      = GLuint       ,
      typename TYPE_TYPE       = GLenum       ,
      typename NORMALIZED_TYPE = GLboolean    ,
      typename VALUE_TYPE      = const GLuint*>
    inline VertexAttribP1uiv<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >* newVertexAttribP1uiv(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return new VertexAttribP1uiv<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >(
              index     ,
              type      ,
              normalized,
              value     );
    }
    template<
      typename INDEX_TYPE      = GLuint       ,
      typename TYPE_TYPE       = GLenum       ,
      typename NORMALIZED_TYPE = GLboolean    ,
      typename VALUE_TYPE      = const GLuint*>
    inline std::shared_ptr<VertexAttribP1uiv<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >> sharedVertexAttribP1uiv(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return std::make_shared<VertexAttribP1uiv<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >>(
              index     ,
              type      ,
              normalized,
              value     );
    }

    template<
      typename PROGRAM_TYPE = GLuint>
    inline LinkProgram<
      PROGRAM_TYPE>* newLinkProgram(
        PROGRAM_TYPE const&program){
        return new LinkProgram<
          PROGRAM_TYPE>(
              program);
    }
    template<
      typename PROGRAM_TYPE = GLuint>
    inline std::shared_ptr<LinkProgram<
      PROGRAM_TYPE>> sharedLinkProgram(
        PROGRAM_TYPE const&program){
        return std::make_shared<LinkProgram<
          PROGRAM_TYPE>>(
              program);
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename MODE_TYPE   = GLenum>
    inline Hint<
      TARGET_TYPE,
      MODE_TYPE  >* newHint(
        TARGET_TYPE const&target,
        MODE_TYPE   const&mode  ){
        return new Hint<
          TARGET_TYPE,
          MODE_TYPE  >(
              target,
              mode  );
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename MODE_TYPE   = GLenum>
    inline std::shared_ptr<Hint<
      TARGET_TYPE,
      MODE_TYPE  >> sharedHint(
        TARGET_TYPE const&target,
        MODE_TYPE   const&mode  ){
        return std::make_shared<Hint<
          TARGET_TYPE,
          MODE_TYPE  >>(
              target,
              mode  );
    }

    template<
      typename MODE_TYPE      = GLenum     ,
      typename INDIRECT_TYPE  = const void*,
      typename DRAWCOUNT_TYPE = GLsizei    ,
      typename STRIDE_TYPE    = GLsizei    >
    inline MultiDrawArraysIndirect<
      MODE_TYPE     ,
      INDIRECT_TYPE ,
      DRAWCOUNT_TYPE,
      STRIDE_TYPE   >* newMultiDrawArraysIndirect(
        MODE_TYPE      const&mode     ,
        INDIRECT_TYPE  const&indirect ,
        DRAWCOUNT_TYPE const&drawcount,
        STRIDE_TYPE    const&stride   ){
        return new MultiDrawArraysIndirect<
          MODE_TYPE     ,
          INDIRECT_TYPE ,
          DRAWCOUNT_TYPE,
          STRIDE_TYPE   >(
              mode     ,
              indirect ,
              drawcount,
              stride   );
    }
    template<
      typename MODE_TYPE      = GLenum     ,
      typename INDIRECT_TYPE  = const void*,
      typename DRAWCOUNT_TYPE = GLsizei    ,
      typename STRIDE_TYPE    = GLsizei    >
    inline std::shared_ptr<MultiDrawArraysIndirect<
      MODE_TYPE     ,
      INDIRECT_TYPE ,
      DRAWCOUNT_TYPE,
      STRIDE_TYPE   >> sharedMultiDrawArraysIndirect(
        MODE_TYPE      const&mode     ,
        INDIRECT_TYPE  const&indirect ,
        DRAWCOUNT_TYPE const&drawcount,
        STRIDE_TYPE    const&stride   ){
        return std::make_shared<MultiDrawArraysIndirect<
          MODE_TYPE     ,
          INDIRECT_TYPE ,
          DRAWCOUNT_TYPE,
          STRIDE_TYPE   >>(
              mode     ,
              indirect ,
              drawcount,
              stride   );
    }

    template<
      typename FIRST_TYPE    = GLuint       ,
      typename COUNT_TYPE    = GLsizei      ,
      typename TEXTURES_TYPE = const GLuint*>
    inline BindImageTextures<
      FIRST_TYPE   ,
      COUNT_TYPE   ,
      TEXTURES_TYPE>* newBindImageTextures(
        FIRST_TYPE    const&first   ,
        COUNT_TYPE    const&count   ,
        TEXTURES_TYPE const&textures){
        return new BindImageTextures<
          FIRST_TYPE   ,
          COUNT_TYPE   ,
          TEXTURES_TYPE>(
              first   ,
              count   ,
              textures);
    }
    template<
      typename FIRST_TYPE    = GLuint       ,
      typename COUNT_TYPE    = GLsizei      ,
      typename TEXTURES_TYPE = const GLuint*>
    inline std::shared_ptr<BindImageTextures<
      FIRST_TYPE   ,
      COUNT_TYPE   ,
      TEXTURES_TYPE>> sharedBindImageTextures(
        FIRST_TYPE    const&first   ,
        COUNT_TYPE    const&count   ,
        TEXTURES_TYPE const&textures){
        return std::make_shared<BindImageTextures<
          FIRST_TYPE   ,
          COUNT_TYPE   ,
          TEXTURES_TYPE>>(
              first   ,
              count   ,
              textures);
    }

    template<
      typename PIPELINE_TYPE = GLuint  ,
      typename BUFSIZE_TYPE  = GLsizei ,
      typename LENGTH_TYPE   = GLsizei*,
      typename INFOLOG_TYPE  = GLchar* >
    inline GetProgramPipelineInfoLog<
      PIPELINE_TYPE,
      BUFSIZE_TYPE ,
      LENGTH_TYPE  ,
      INFOLOG_TYPE >* newGetProgramPipelineInfoLog(
        PIPELINE_TYPE const&pipeline,
        BUFSIZE_TYPE  const&bufSize ,
        LENGTH_TYPE   const&length  ,
        INFOLOG_TYPE  const&infoLog ){
        return new GetProgramPipelineInfoLog<
          PIPELINE_TYPE,
          BUFSIZE_TYPE ,
          LENGTH_TYPE  ,
          INFOLOG_TYPE >(
              pipeline,
              bufSize ,
              length  ,
              infoLog );
    }
    template<
      typename PIPELINE_TYPE = GLuint  ,
      typename BUFSIZE_TYPE  = GLsizei ,
      typename LENGTH_TYPE   = GLsizei*,
      typename INFOLOG_TYPE  = GLchar* >
    inline std::shared_ptr<GetProgramPipelineInfoLog<
      PIPELINE_TYPE,
      BUFSIZE_TYPE ,
      LENGTH_TYPE  ,
      INFOLOG_TYPE >> sharedGetProgramPipelineInfoLog(
        PIPELINE_TYPE const&pipeline,
        BUFSIZE_TYPE  const&bufSize ,
        LENGTH_TYPE   const&length  ,
        INFOLOG_TYPE  const&infoLog ){
        return std::make_shared<GetProgramPipelineInfoLog<
          PIPELINE_TYPE,
          BUFSIZE_TYPE ,
          LENGTH_TYPE  ,
          INFOLOG_TYPE >>(
              pipeline,
              bufSize ,
              length  ,
              infoLog );
    }

    template<
      typename RET_TYPE  = const GLubyte*,
      typename NAME_TYPE = GLenum        >
    inline GetString<
      RET_TYPE ,
      NAME_TYPE>* newGetString(
        RET_TYPE  const&ret ,
        NAME_TYPE const&name){
        return new GetString<
          RET_TYPE ,
          NAME_TYPE>(
              ret ,
              name);
    }
    template<
      typename RET_TYPE  = const GLubyte*,
      typename NAME_TYPE = GLenum        >
    inline std::shared_ptr<GetString<
      RET_TYPE ,
      NAME_TYPE>> sharedGetString(
        RET_TYPE  const&ret ,
        NAME_TYPE const&name){
        return std::make_shared<GetString<
          RET_TYPE ,
          NAME_TYPE>>(
              ret ,
              name);
    }

    template<
      typename INDEX_TYPE      = GLuint       ,
      typename TYPE_TYPE       = GLenum       ,
      typename NORMALIZED_TYPE = GLboolean    ,
      typename VALUE_TYPE      = const GLuint*>
    inline VertexAttribP2uiv<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >* newVertexAttribP2uiv(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return new VertexAttribP2uiv<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >(
              index     ,
              type      ,
              normalized,
              value     );
    }
    template<
      typename INDEX_TYPE      = GLuint       ,
      typename TYPE_TYPE       = GLenum       ,
      typename NORMALIZED_TYPE = GLboolean    ,
      typename VALUE_TYPE      = const GLuint*>
    inline std::shared_ptr<VertexAttribP2uiv<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >> sharedVertexAttribP2uiv(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return std::make_shared<VertexAttribP2uiv<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >>(
              index     ,
              type      ,
              normalized,
              value     );
    }

    template<
      typename PROGRAM_TYPE = GLuint,
      typename SHADER_TYPE  = GLuint>
    inline DetachShader<
      PROGRAM_TYPE,
      SHADER_TYPE >* newDetachShader(
        PROGRAM_TYPE const&program,
        SHADER_TYPE  const&shader ){
        return new DetachShader<
          PROGRAM_TYPE,
          SHADER_TYPE >(
              program,
              shader );
    }
    template<
      typename PROGRAM_TYPE = GLuint,
      typename SHADER_TYPE  = GLuint>
    inline std::shared_ptr<DetachShader<
      PROGRAM_TYPE,
      SHADER_TYPE >> sharedDetachShader(
        PROGRAM_TYPE const&program,
        SHADER_TYPE  const&shader ){
        return std::make_shared<DetachShader<
          PROGRAM_TYPE,
          SHADER_TYPE >>(
              program,
              shader );
    }

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline UniformMatrix3x4dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix3x4dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix3x4dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<UniformMatrix3x4dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix3x4dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix3x4dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename TARGET_TYPE = GLenum>
    inline EndQuery<
      TARGET_TYPE>* newEndQuery(
        TARGET_TYPE const&target){
        return new EndQuery<
          TARGET_TYPE>(
              target);
    }
    template<
      typename TARGET_TYPE = GLenum>
    inline std::shared_ptr<EndQuery<
      TARGET_TYPE>> sharedEndQuery(
        TARGET_TYPE const&target){
        return std::make_shared<EndQuery<
          TARGET_TYPE>>(
              target);
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAM_TYPE  = GLint >
    inline FramebufferParameteri<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAM_TYPE >* newFramebufferParameteri(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAM_TYPE  const&param ){
        return new FramebufferParameteri<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAM_TYPE >(
              target,
              pname ,
              param );
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAM_TYPE  = GLint >
    inline std::shared_ptr<FramebufferParameteri<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAM_TYPE >> sharedFramebufferParameteri(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAM_TYPE  const&param ){
        return std::make_shared<FramebufferParameteri<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAM_TYPE >>(
              target,
              pname ,
              param );
    }

    template<
      typename PROGRAM_TYPE          = GLuint  ,
      typename PROGRAMINTERFACE_TYPE = GLenum  ,
      typename INDEX_TYPE            = GLuint  ,
      typename BUFSIZE_TYPE          = GLsizei ,
      typename LENGTH_TYPE           = GLsizei*,
      typename NAME_TYPE             = GLchar* >
    inline GetProgramResourceName<
      PROGRAM_TYPE         ,
      PROGRAMINTERFACE_TYPE,
      INDEX_TYPE           ,
      BUFSIZE_TYPE         ,
      LENGTH_TYPE          ,
      NAME_TYPE            >* newGetProgramResourceName(
        PROGRAM_TYPE          const&program         ,
        PROGRAMINTERFACE_TYPE const&programInterface,
        INDEX_TYPE            const&index           ,
        BUFSIZE_TYPE          const&bufSize         ,
        LENGTH_TYPE           const&length          ,
        NAME_TYPE             const&name            ){
        return new GetProgramResourceName<
          PROGRAM_TYPE         ,
          PROGRAMINTERFACE_TYPE,
          INDEX_TYPE           ,
          BUFSIZE_TYPE         ,
          LENGTH_TYPE          ,
          NAME_TYPE            >(
              program         ,
              programInterface,
              index           ,
              bufSize         ,
              length          ,
              name            );
    }
    template<
      typename PROGRAM_TYPE          = GLuint  ,
      typename PROGRAMINTERFACE_TYPE = GLenum  ,
      typename INDEX_TYPE            = GLuint  ,
      typename BUFSIZE_TYPE          = GLsizei ,
      typename LENGTH_TYPE           = GLsizei*,
      typename NAME_TYPE             = GLchar* >
    inline std::shared_ptr<GetProgramResourceName<
      PROGRAM_TYPE         ,
      PROGRAMINTERFACE_TYPE,
      INDEX_TYPE           ,
      BUFSIZE_TYPE         ,
      LENGTH_TYPE          ,
      NAME_TYPE            >> sharedGetProgramResourceName(
        PROGRAM_TYPE          const&program         ,
        PROGRAMINTERFACE_TYPE const&programInterface,
        INDEX_TYPE            const&index           ,
        BUFSIZE_TYPE          const&bufSize         ,
        LENGTH_TYPE           const&length          ,
        NAME_TYPE             const&name            ){
        return std::make_shared<GetProgramResourceName<
          PROGRAM_TYPE         ,
          PROGRAMINTERFACE_TYPE,
          INDEX_TYPE           ,
          BUFSIZE_TYPE         ,
          LENGTH_TYPE          ,
          NAME_TYPE            >>(
              program         ,
              programInterface,
              index           ,
              bufSize         ,
              length          ,
              name            );
    }

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline UniformMatrix4x3dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix4x3dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix4x3dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<UniformMatrix4x3dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix4x3dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix4x3dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename FIRST_TYPE = GLuint         ,
      typename COUNT_TYPE = GLsizei        ,
      typename V_TYPE     = const GLdouble*>
    inline DepthRangeArrayv<
      FIRST_TYPE,
      COUNT_TYPE,
      V_TYPE    >* newDepthRangeArrayv(
        FIRST_TYPE const&first,
        COUNT_TYPE const&count,
        V_TYPE     const&v    ){
        return new DepthRangeArrayv<
          FIRST_TYPE,
          COUNT_TYPE,
          V_TYPE    >(
              first,
              count,
              v    );
    }
    template<
      typename FIRST_TYPE = GLuint         ,
      typename COUNT_TYPE = GLsizei        ,
      typename V_TYPE     = const GLdouble*>
    inline std::shared_ptr<DepthRangeArrayv<
      FIRST_TYPE,
      COUNT_TYPE,
      V_TYPE    >> sharedDepthRangeArrayv(
        FIRST_TYPE const&first,
        COUNT_TYPE const&count,
        V_TYPE     const&v    ){
        return std::make_shared<DepthRangeArrayv<
          FIRST_TYPE,
          COUNT_TYPE,
          V_TYPE    >>(
              first,
              count,
              v    );
    }

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLuint,
      typename Y_TYPE     = GLuint>
    inline VertexAttribI2ui<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    >* newVertexAttribI2ui(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ){
        return new VertexAttribI2ui<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    >(
              index,
              x    ,
              y    );
    }
    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLuint,
      typename Y_TYPE     = GLuint>
    inline std::shared_ptr<VertexAttribI2ui<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    >> sharedVertexAttribI2ui(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ){
        return std::make_shared<VertexAttribI2ui<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    >>(
              index,
              x    ,
              y    );
    }

    template<
      typename RET_TYPE              = GLint        ,
      typename PROGRAM_TYPE          = GLuint       ,
      typename PROGRAMINTERFACE_TYPE = GLenum       ,
      typename NAME_TYPE             = const GLchar*>
    inline GetProgramResourceLocation<
      RET_TYPE             ,
      PROGRAM_TYPE         ,
      PROGRAMINTERFACE_TYPE,
      NAME_TYPE            >* newGetProgramResourceLocation(
        RET_TYPE              const&ret             ,
        PROGRAM_TYPE          const&program         ,
        PROGRAMINTERFACE_TYPE const&programInterface,
        NAME_TYPE             const&name            ){
        return new GetProgramResourceLocation<
          RET_TYPE             ,
          PROGRAM_TYPE         ,
          PROGRAMINTERFACE_TYPE,
          NAME_TYPE            >(
              ret             ,
              program         ,
              programInterface,
              name            );
    }
    template<
      typename RET_TYPE              = GLint        ,
      typename PROGRAM_TYPE          = GLuint       ,
      typename PROGRAMINTERFACE_TYPE = GLenum       ,
      typename NAME_TYPE             = const GLchar*>
    inline std::shared_ptr<GetProgramResourceLocation<
      RET_TYPE             ,
      PROGRAM_TYPE         ,
      PROGRAMINTERFACE_TYPE,
      NAME_TYPE            >> sharedGetProgramResourceLocation(
        RET_TYPE              const&ret             ,
        PROGRAM_TYPE          const&program         ,
        PROGRAMINTERFACE_TYPE const&programInterface,
        NAME_TYPE             const&name            ){
        return std::make_shared<GetProgramResourceLocation<
          RET_TYPE             ,
          PROGRAM_TYPE         ,
          PROGRAMINTERFACE_TYPE,
          NAME_TYPE            >>(
              ret             ,
              program         ,
              programInterface,
              name            );
    }

    template<
      typename N_TYPE        = GLsizei      ,
      typename TEXTURES_TYPE = const GLuint*>
    inline DeleteTextures<
      N_TYPE       ,
      TEXTURES_TYPE>* newDeleteTextures(
        N_TYPE        const&n       ,
        TEXTURES_TYPE const&textures){
        return new DeleteTextures<
          N_TYPE       ,
          TEXTURES_TYPE>(
              n       ,
              textures);
    }
    template<
      typename N_TYPE        = GLsizei      ,
      typename TEXTURES_TYPE = const GLuint*>
    inline std::shared_ptr<DeleteTextures<
      N_TYPE       ,
      TEXTURES_TYPE>> sharedDeleteTextures(
        N_TYPE        const&n       ,
        TEXTURES_TYPE const&textures){
        return std::make_shared<DeleteTextures<
          N_TYPE       ,
          TEXTURES_TYPE>>(
              n       ,
              textures);
    }

    template<
      typename PROGRAM_TYPE     = GLuint,
      typename BUFFERINDEX_TYPE = GLuint,
      typename PNAME_TYPE       = GLenum,
      typename PARAMS_TYPE      = GLint*>
    inline GetActiveAtomicCounterBufferiv<
      PROGRAM_TYPE    ,
      BUFFERINDEX_TYPE,
      PNAME_TYPE      ,
      PARAMS_TYPE     >* newGetActiveAtomicCounterBufferiv(
        PROGRAM_TYPE     const&program    ,
        BUFFERINDEX_TYPE const&bufferIndex,
        PNAME_TYPE       const&pname      ,
        PARAMS_TYPE      const&params     ){
        return new GetActiveAtomicCounterBufferiv<
          PROGRAM_TYPE    ,
          BUFFERINDEX_TYPE,
          PNAME_TYPE      ,
          PARAMS_TYPE     >(
              program    ,
              bufferIndex,
              pname      ,
              params     );
    }
    template<
      typename PROGRAM_TYPE     = GLuint,
      typename BUFFERINDEX_TYPE = GLuint,
      typename PNAME_TYPE       = GLenum,
      typename PARAMS_TYPE      = GLint*>
    inline std::shared_ptr<GetActiveAtomicCounterBufferiv<
      PROGRAM_TYPE    ,
      BUFFERINDEX_TYPE,
      PNAME_TYPE      ,
      PARAMS_TYPE     >> sharedGetActiveAtomicCounterBufferiv(
        PROGRAM_TYPE     const&program    ,
        BUFFERINDEX_TYPE const&bufferIndex,
        PNAME_TYPE       const&pname      ,
        PARAMS_TYPE      const&params     ){
        return std::make_shared<GetActiveAtomicCounterBufferiv<
          PROGRAM_TYPE    ,
          BUFFERINDEX_TYPE,
          PNAME_TYPE      ,
          PARAMS_TYPE     >>(
              program    ,
              bufferIndex,
              pname      ,
              params     );
    }

    template<
      typename FACE_TYPE   = GLenum,
      typename SFAIL_TYPE  = GLenum,
      typename DPFAIL_TYPE = GLenum,
      typename DPPASS_TYPE = GLenum>
    inline StencilOpSeparate<
      FACE_TYPE  ,
      SFAIL_TYPE ,
      DPFAIL_TYPE,
      DPPASS_TYPE>* newStencilOpSeparate(
        FACE_TYPE   const&face  ,
        SFAIL_TYPE  const&sfail ,
        DPFAIL_TYPE const&dpfail,
        DPPASS_TYPE const&dppass){
        return new StencilOpSeparate<
          FACE_TYPE  ,
          SFAIL_TYPE ,
          DPFAIL_TYPE,
          DPPASS_TYPE>(
              face  ,
              sfail ,
              dpfail,
              dppass);
    }
    template<
      typename FACE_TYPE   = GLenum,
      typename SFAIL_TYPE  = GLenum,
      typename DPFAIL_TYPE = GLenum,
      typename DPPASS_TYPE = GLenum>
    inline std::shared_ptr<StencilOpSeparate<
      FACE_TYPE  ,
      SFAIL_TYPE ,
      DPFAIL_TYPE,
      DPPASS_TYPE>> sharedStencilOpSeparate(
        FACE_TYPE   const&face  ,
        SFAIL_TYPE  const&sfail ,
        DPFAIL_TYPE const&dpfail,
        DPPASS_TYPE const&dppass){
        return std::make_shared<StencilOpSeparate<
          FACE_TYPE  ,
          SFAIL_TYPE ,
          DPFAIL_TYPE,
          DPPASS_TYPE>>(
              face  ,
              sfail ,
              dpfail,
              dppass);
    }

    template<
      typename N_TYPE   = GLsizei      ,
      typename IDS_TYPE = const GLuint*>
    inline DeleteQueries<
      N_TYPE  ,
      IDS_TYPE>* newDeleteQueries(
        N_TYPE   const&n  ,
        IDS_TYPE const&ids){
        return new DeleteQueries<
          N_TYPE  ,
          IDS_TYPE>(
              n  ,
              ids);
    }
    template<
      typename N_TYPE   = GLsizei      ,
      typename IDS_TYPE = const GLuint*>
    inline std::shared_ptr<DeleteQueries<
      N_TYPE  ,
      IDS_TYPE>> sharedDeleteQueries(
        N_TYPE   const&n  ,
        IDS_TYPE const&ids){
        return std::make_shared<DeleteQueries<
          N_TYPE  ,
          IDS_TYPE>>(
              n  ,
              ids);
    }

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat,
      typename Y_TYPE     = GLfloat,
      typename Z_TYPE     = GLfloat,
      typename W_TYPE     = GLfloat>
    inline VertexAttrib4f<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >* newVertexAttrib4f(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return new VertexAttrib4f<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }
    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat,
      typename Y_TYPE     = GLfloat,
      typename Z_TYPE     = GLfloat,
      typename W_TYPE     = GLfloat>
    inline std::shared_ptr<VertexAttrib4f<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >> sharedVertexAttrib4f(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return std::make_shared<VertexAttrib4f<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >>(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename PNAME_TYPE       = GLenum,
      typename PARAM_TYPE       = GLint >
    inline NamedFramebufferParameteri<
      FRAMEBUFFER_TYPE,
      PNAME_TYPE      ,
      PARAM_TYPE      >* newNamedFramebufferParameteri(
        FRAMEBUFFER_TYPE const&framebuffer,
        PNAME_TYPE       const&pname      ,
        PARAM_TYPE       const&param      ){
        return new NamedFramebufferParameteri<
          FRAMEBUFFER_TYPE,
          PNAME_TYPE      ,
          PARAM_TYPE      >(
              framebuffer,
              pname      ,
              param      );
    }
    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename PNAME_TYPE       = GLenum,
      typename PARAM_TYPE       = GLint >
    inline std::shared_ptr<NamedFramebufferParameteri<
      FRAMEBUFFER_TYPE,
      PNAME_TYPE      ,
      PARAM_TYPE      >> sharedNamedFramebufferParameteri(
        FRAMEBUFFER_TYPE const&framebuffer,
        PNAME_TYPE       const&pname      ,
        PARAM_TYPE       const&param      ){
        return std::make_shared<NamedFramebufferParameteri<
          FRAMEBUFFER_TYPE,
          PNAME_TYPE      ,
          PARAM_TYPE      >>(
              framebuffer,
              pname      ,
              param      );
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    inline ViewportIndexedfv<
      INDEX_TYPE,
      V_TYPE    >* newViewportIndexedfv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new ViewportIndexedfv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    inline std::shared_ptr<ViewportIndexedfv<
      INDEX_TYPE,
      V_TYPE    >> sharedViewportIndexedfv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<ViewportIndexedfv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename TARGET_TYPE  = GLenum       ,
      typename FIRST_TYPE   = GLuint       ,
      typename COUNT_TYPE   = GLsizei      ,
      typename BUFFERS_TYPE = const GLuint*>
    inline BindBuffersBase<
      TARGET_TYPE ,
      FIRST_TYPE  ,
      COUNT_TYPE  ,
      BUFFERS_TYPE>* newBindBuffersBase(
        TARGET_TYPE  const&target ,
        FIRST_TYPE   const&first  ,
        COUNT_TYPE   const&count  ,
        BUFFERS_TYPE const&buffers){
        return new BindBuffersBase<
          TARGET_TYPE ,
          FIRST_TYPE  ,
          COUNT_TYPE  ,
          BUFFERS_TYPE>(
              target ,
              first  ,
              count  ,
              buffers);
    }
    template<
      typename TARGET_TYPE  = GLenum       ,
      typename FIRST_TYPE   = GLuint       ,
      typename COUNT_TYPE   = GLsizei      ,
      typename BUFFERS_TYPE = const GLuint*>
    inline std::shared_ptr<BindBuffersBase<
      TARGET_TYPE ,
      FIRST_TYPE  ,
      COUNT_TYPE  ,
      BUFFERS_TYPE>> sharedBindBuffersBase(
        TARGET_TYPE  const&target ,
        FIRST_TYPE   const&first  ,
        COUNT_TYPE   const&count  ,
        BUFFERS_TYPE const&buffers){
        return std::make_shared<BindBuffersBase<
          TARGET_TYPE ,
          FIRST_TYPE  ,
          COUNT_TYPE  ,
          BUFFERS_TYPE>>(
              target ,
              first  ,
              count  ,
              buffers);
    }

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline VertexAttribL4dv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribL4dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribL4dv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline std::shared_ptr<VertexAttribL4dv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribL4dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribL4dv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetTexParameteriv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetTexParameteriv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetTexParameteriv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetTexParameteriv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetTexParameteriv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetTexParameteriv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename N_TYPE      = GLsizei,
      typename ARRAYS_TYPE = GLuint*>
    inline CreateVertexArrays<
      N_TYPE     ,
      ARRAYS_TYPE>* newCreateVertexArrays(
        N_TYPE      const&n     ,
        ARRAYS_TYPE const&arrays){
        return new CreateVertexArrays<
          N_TYPE     ,
          ARRAYS_TYPE>(
              n     ,
              arrays);
    }
    template<
      typename N_TYPE      = GLsizei,
      typename ARRAYS_TYPE = GLuint*>
    inline std::shared_ptr<CreateVertexArrays<
      N_TYPE     ,
      ARRAYS_TYPE>> sharedCreateVertexArrays(
        N_TYPE      const&n     ,
        ARRAYS_TYPE const&arrays){
        return std::make_shared<CreateVertexArrays<
          N_TYPE     ,
          ARRAYS_TYPE>>(
              n     ,
              arrays);
    }

    template<
      typename PROGRAM_TYPE  = GLuint         ,
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline ProgramUniform1dv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform1dv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform1dv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint         ,
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline std::shared_ptr<ProgramUniform1dv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform1dv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform1dv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename ID_TYPE   = GLuint,
      typename MODE_TYPE = GLenum>
    inline BeginConditionalRender<
      ID_TYPE  ,
      MODE_TYPE>* newBeginConditionalRender(
        ID_TYPE   const&id  ,
        MODE_TYPE const&mode){
        return new BeginConditionalRender<
          ID_TYPE  ,
          MODE_TYPE>(
              id  ,
              mode);
    }
    template<
      typename ID_TYPE   = GLuint,
      typename MODE_TYPE = GLenum>
    inline std::shared_ptr<BeginConditionalRender<
      ID_TYPE  ,
      MODE_TYPE>> sharedBeginConditionalRender(
        ID_TYPE   const&id  ,
        MODE_TYPE const&mode){
        return std::make_shared<BeginConditionalRender<
          ID_TYPE  ,
          MODE_TYPE>>(
              id  ,
              mode);
    }

    template<
      typename MODE_TYPE       = GLenum     ,
      typename COUNT_TYPE      = GLsizei    ,
      typename TYPE_TYPE       = GLenum     ,
      typename INDICES_TYPE    = const void*,
      typename BASEVERTEX_TYPE = GLint      >
    inline DrawElementsBaseVertex<
      MODE_TYPE      ,
      COUNT_TYPE     ,
      TYPE_TYPE      ,
      INDICES_TYPE   ,
      BASEVERTEX_TYPE>* newDrawElementsBaseVertex(
        MODE_TYPE       const&mode      ,
        COUNT_TYPE      const&count     ,
        TYPE_TYPE       const&type      ,
        INDICES_TYPE    const&indices   ,
        BASEVERTEX_TYPE const&basevertex){
        return new DrawElementsBaseVertex<
          MODE_TYPE      ,
          COUNT_TYPE     ,
          TYPE_TYPE      ,
          INDICES_TYPE   ,
          BASEVERTEX_TYPE>(
              mode      ,
              count     ,
              type      ,
              indices   ,
              basevertex);
    }
    template<
      typename MODE_TYPE       = GLenum     ,
      typename COUNT_TYPE      = GLsizei    ,
      typename TYPE_TYPE       = GLenum     ,
      typename INDICES_TYPE    = const void*,
      typename BASEVERTEX_TYPE = GLint      >
    inline std::shared_ptr<DrawElementsBaseVertex<
      MODE_TYPE      ,
      COUNT_TYPE     ,
      TYPE_TYPE      ,
      INDICES_TYPE   ,
      BASEVERTEX_TYPE>> sharedDrawElementsBaseVertex(
        MODE_TYPE       const&mode      ,
        COUNT_TYPE      const&count     ,
        TYPE_TYPE       const&type      ,
        INDICES_TYPE    const&indices   ,
        BASEVERTEX_TYPE const&basevertex){
        return std::make_shared<DrawElementsBaseVertex<
          MODE_TYPE      ,
          COUNT_TYPE     ,
          TYPE_TYPE      ,
          INDICES_TYPE   ,
          BASEVERTEX_TYPE>>(
              mode      ,
              count     ,
              type      ,
              indices   ,
              basevertex);
    }

    template<
      typename VALUE_TYPE  = GLfloat  ,
      typename INVERT_TYPE = GLboolean>
    inline SampleCoverage<
      VALUE_TYPE ,
      INVERT_TYPE>* newSampleCoverage(
        VALUE_TYPE  const&value ,
        INVERT_TYPE const&invert){
        return new SampleCoverage<
          VALUE_TYPE ,
          INVERT_TYPE>(
              value ,
              invert);
    }
    template<
      typename VALUE_TYPE  = GLfloat  ,
      typename INVERT_TYPE = GLboolean>
    inline std::shared_ptr<SampleCoverage<
      VALUE_TYPE ,
      INVERT_TYPE>> sharedSampleCoverage(
        VALUE_TYPE  const&value ,
        INVERT_TYPE const&invert){
        return std::make_shared<SampleCoverage<
          VALUE_TYPE ,
          INVERT_TYPE>>(
              value ,
              invert);
    }

    template<
      typename SAMPLER_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAM_TYPE   = GLint >
    inline SamplerParameteri<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >* newSamplerParameteri(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return new SamplerParameteri<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >(
              sampler,
              pname  ,
              param  );
    }
    template<
      typename SAMPLER_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAM_TYPE   = GLint >
    inline std::shared_ptr<SamplerParameteri<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >> sharedSamplerParameteri(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return std::make_shared<SamplerParameteri<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >>(
              sampler,
              pname  ,
              param  );
    }

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename OFFSET_TYPE         = GLintptr   ,
      typename SIZE_TYPE           = GLsizeiptr ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename DATA_TYPE           = const void*>
    inline ClearBufferSubData<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      OFFSET_TYPE        ,
      SIZE_TYPE          ,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      DATA_TYPE          >* newClearBufferSubData(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        OFFSET_TYPE         const&offset        ,
        SIZE_TYPE           const&size          ,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        DATA_TYPE           const&data          ){
        return new ClearBufferSubData<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          OFFSET_TYPE        ,
          SIZE_TYPE          ,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          DATA_TYPE          >(
              target        ,
              internalformat,
              offset        ,
              size          ,
              format        ,
              type          ,
              data          );
    }
    template<
      typename TARGET_TYPE         = GLenum     ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename OFFSET_TYPE         = GLintptr   ,
      typename SIZE_TYPE           = GLsizeiptr ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename DATA_TYPE           = const void*>
    inline std::shared_ptr<ClearBufferSubData<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      OFFSET_TYPE        ,
      SIZE_TYPE          ,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      DATA_TYPE          >> sharedClearBufferSubData(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        OFFSET_TYPE         const&offset        ,
        SIZE_TYPE           const&size          ,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        DATA_TYPE           const&data          ){
        return std::make_shared<ClearBufferSubData<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          OFFSET_TYPE        ,
          SIZE_TYPE          ,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          DATA_TYPE          >>(
              target        ,
              internalformat,
              offset        ,
              size          ,
              format        ,
              type          ,
              data          );
    }

    template<
      typename SAMPLER_TYPE = GLuint ,
      typename PNAME_TYPE   = GLenum ,
      typename PARAM_TYPE   = GLfloat>
    inline SamplerParameterf<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >* newSamplerParameterf(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return new SamplerParameterf<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >(
              sampler,
              pname  ,
              param  );
    }
    template<
      typename SAMPLER_TYPE = GLuint ,
      typename PNAME_TYPE   = GLenum ,
      typename PARAM_TYPE   = GLfloat>
    inline std::shared_ptr<SamplerParameterf<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >> sharedSamplerParameterf(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return std::make_shared<SamplerParameterf<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >>(
              sampler,
              pname  ,
              param  );
    }

    template<
      typename FRAMEBUFFER_TYPE = GLuint       ,
      typename BUFFER_TYPE      = GLenum       ,
      typename DRAWBUFFER_TYPE  = GLint        ,
      typename VALUE_TYPE       = const GLuint*>
    inline ClearNamedFramebufferuiv<
      FRAMEBUFFER_TYPE,
      BUFFER_TYPE     ,
      DRAWBUFFER_TYPE ,
      VALUE_TYPE      >* newClearNamedFramebufferuiv(
        FRAMEBUFFER_TYPE const&framebuffer,
        BUFFER_TYPE      const&buffer     ,
        DRAWBUFFER_TYPE  const&drawbuffer ,
        VALUE_TYPE       const&value      ){
        return new ClearNamedFramebufferuiv<
          FRAMEBUFFER_TYPE,
          BUFFER_TYPE     ,
          DRAWBUFFER_TYPE ,
          VALUE_TYPE      >(
              framebuffer,
              buffer     ,
              drawbuffer ,
              value      );
    }
    template<
      typename FRAMEBUFFER_TYPE = GLuint       ,
      typename BUFFER_TYPE      = GLenum       ,
      typename DRAWBUFFER_TYPE  = GLint        ,
      typename VALUE_TYPE       = const GLuint*>
    inline std::shared_ptr<ClearNamedFramebufferuiv<
      FRAMEBUFFER_TYPE,
      BUFFER_TYPE     ,
      DRAWBUFFER_TYPE ,
      VALUE_TYPE      >> sharedClearNamedFramebufferuiv(
        FRAMEBUFFER_TYPE const&framebuffer,
        BUFFER_TYPE      const&buffer     ,
        DRAWBUFFER_TYPE  const&drawbuffer ,
        VALUE_TYPE       const&value      ){
        return std::make_shared<ClearNamedFramebufferuiv<
          FRAMEBUFFER_TYPE,
          BUFFER_TYPE     ,
          DRAWBUFFER_TYPE ,
          VALUE_TYPE      >>(
              framebuffer,
              buffer     ,
              drawbuffer ,
              value      );
    }

    template<
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat>
    inline Uniform1f<
      LOCATION_TYPE,
      V0_TYPE      >* newUniform1f(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return new Uniform1f<
          LOCATION_TYPE,
          V0_TYPE      >(
              location,
              v0      );
    }
    template<
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat>
    inline std::shared_ptr<Uniform1f<
      LOCATION_TYPE,
      V0_TYPE      >> sharedUniform1f(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return std::make_shared<Uniform1f<
          LOCATION_TYPE,
          V0_TYPE      >>(
              location,
              v0      );
    }

    template<
      typename INDEX_TYPE  = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLfloat*>
    inline GetVertexAttribfv<
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetVertexAttribfv(
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetVertexAttribfv<
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              index ,
              pname ,
              params);
    }
    template<
      typename INDEX_TYPE  = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLfloat*>
    inline std::shared_ptr<GetVertexAttribfv<
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetVertexAttribfv(
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetVertexAttribfv<
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              index ,
              pname ,
              params);
    }

    template<
      typename NUM_GROUPS_X_TYPE = GLuint,
      typename NUM_GROUPS_Y_TYPE = GLuint,
      typename NUM_GROUPS_Z_TYPE = GLuint>
    inline DispatchCompute<
      NUM_GROUPS_X_TYPE,
      NUM_GROUPS_Y_TYPE,
      NUM_GROUPS_Z_TYPE>* newDispatchCompute(
        NUM_GROUPS_X_TYPE const&num_groups_x,
        NUM_GROUPS_Y_TYPE const&num_groups_y,
        NUM_GROUPS_Z_TYPE const&num_groups_z){
        return new DispatchCompute<
          NUM_GROUPS_X_TYPE,
          NUM_GROUPS_Y_TYPE,
          NUM_GROUPS_Z_TYPE>(
              num_groups_x,
              num_groups_y,
              num_groups_z);
    }
    template<
      typename NUM_GROUPS_X_TYPE = GLuint,
      typename NUM_GROUPS_Y_TYPE = GLuint,
      typename NUM_GROUPS_Z_TYPE = GLuint>
    inline std::shared_ptr<DispatchCompute<
      NUM_GROUPS_X_TYPE,
      NUM_GROUPS_Y_TYPE,
      NUM_GROUPS_Z_TYPE>> sharedDispatchCompute(
        NUM_GROUPS_X_TYPE const&num_groups_x,
        NUM_GROUPS_Y_TYPE const&num_groups_y,
        NUM_GROUPS_Z_TYPE const&num_groups_z){
        return std::make_shared<DispatchCompute<
          NUM_GROUPS_X_TYPE,
          NUM_GROUPS_Y_TYPE,
          NUM_GROUPS_Z_TYPE>>(
              num_groups_x,
              num_groups_y,
              num_groups_z);
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename LEVEL_TYPE  = GLint ,
      typename IMG_TYPE    = void* >
    inline GetCompressedTexImage<
      TARGET_TYPE,
      LEVEL_TYPE ,
      IMG_TYPE   >* newGetCompressedTexImage(
        TARGET_TYPE const&target,
        LEVEL_TYPE  const&level ,
        IMG_TYPE    const&img   ){
        return new GetCompressedTexImage<
          TARGET_TYPE,
          LEVEL_TYPE ,
          IMG_TYPE   >(
              target,
              level ,
              img   );
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename LEVEL_TYPE  = GLint ,
      typename IMG_TYPE    = void* >
    inline std::shared_ptr<GetCompressedTexImage<
      TARGET_TYPE,
      LEVEL_TYPE ,
      IMG_TYPE   >> sharedGetCompressedTexImage(
        TARGET_TYPE const&target,
        LEVEL_TYPE  const&level ,
        IMG_TYPE    const&img   ){
        return std::make_shared<GetCompressedTexImage<
          TARGET_TYPE,
          LEVEL_TYPE ,
          IMG_TYPE   >>(
              target,
              level ,
              img   );
    }

    template<
      typename TARGET_TYPE  = GLenum ,
      typename LOD_TYPE     = GLint  ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    inline GetnCompressedTexImage<
      TARGET_TYPE ,
      LOD_TYPE    ,
      BUFSIZE_TYPE,
      PIXELS_TYPE >* newGetnCompressedTexImage(
        TARGET_TYPE  const&target ,
        LOD_TYPE     const&lod    ,
        BUFSIZE_TYPE const&bufSize,
        PIXELS_TYPE  const&pixels ){
        return new GetnCompressedTexImage<
          TARGET_TYPE ,
          LOD_TYPE    ,
          BUFSIZE_TYPE,
          PIXELS_TYPE >(
              target ,
              lod    ,
              bufSize,
              pixels );
    }
    template<
      typename TARGET_TYPE  = GLenum ,
      typename LOD_TYPE     = GLint  ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    inline std::shared_ptr<GetnCompressedTexImage<
      TARGET_TYPE ,
      LOD_TYPE    ,
      BUFSIZE_TYPE,
      PIXELS_TYPE >> sharedGetnCompressedTexImage(
        TARGET_TYPE  const&target ,
        LOD_TYPE     const&lod    ,
        BUFSIZE_TYPE const&bufSize,
        PIXELS_TYPE  const&pixels ){
        return std::make_shared<GetnCompressedTexImage<
          TARGET_TYPE ,
          LOD_TYPE    ,
          BUFSIZE_TYPE,
          PIXELS_TYPE >>(
              target ,
              lod    ,
              bufSize,
              pixels );
    }

    template<
      typename LOCATION_TYPE = GLint,
      typename V0_TYPE       = GLint>
    inline Uniform1i<
      LOCATION_TYPE,
      V0_TYPE      >* newUniform1i(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return new Uniform1i<
          LOCATION_TYPE,
          V0_TYPE      >(
              location,
              v0      );
    }
    template<
      typename LOCATION_TYPE = GLint,
      typename V0_TYPE       = GLint>
    inline std::shared_ptr<Uniform1i<
      LOCATION_TYPE,
      V0_TYPE      >> sharedUniform1i(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ){
        return std::make_shared<Uniform1i<
          LOCATION_TYPE,
          V0_TYPE      >>(
              location,
              v0      );
    }

    template<
      typename PROGRAM_TYPE = GLuint  ,
      typename INDEX_TYPE   = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename SIZE_TYPE    = GLint*  ,
      typename TYPE_TYPE    = GLenum* ,
      typename NAME_TYPE    = GLchar* >
    inline GetActiveAttrib<
      PROGRAM_TYPE,
      INDEX_TYPE  ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      SIZE_TYPE   ,
      TYPE_TYPE   ,
      NAME_TYPE   >* newGetActiveAttrib(
        PROGRAM_TYPE const&program,
        INDEX_TYPE   const&index  ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        SIZE_TYPE    const&size   ,
        TYPE_TYPE    const&type   ,
        NAME_TYPE    const&name   ){
        return new GetActiveAttrib<
          PROGRAM_TYPE,
          INDEX_TYPE  ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          SIZE_TYPE   ,
          TYPE_TYPE   ,
          NAME_TYPE   >(
              program,
              index  ,
              bufSize,
              length ,
              size   ,
              type   ,
              name   );
    }
    template<
      typename PROGRAM_TYPE = GLuint  ,
      typename INDEX_TYPE   = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename SIZE_TYPE    = GLint*  ,
      typename TYPE_TYPE    = GLenum* ,
      typename NAME_TYPE    = GLchar* >
    inline std::shared_ptr<GetActiveAttrib<
      PROGRAM_TYPE,
      INDEX_TYPE  ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      SIZE_TYPE   ,
      TYPE_TYPE   ,
      NAME_TYPE   >> sharedGetActiveAttrib(
        PROGRAM_TYPE const&program,
        INDEX_TYPE   const&index  ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        SIZE_TYPE    const&size   ,
        TYPE_TYPE    const&type   ,
        NAME_TYPE    const&name   ){
        return std::make_shared<GetActiveAttrib<
          PROGRAM_TYPE,
          INDEX_TYPE  ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          SIZE_TYPE   ,
          TYPE_TYPE   ,
          NAME_TYPE   >>(
              program,
              index  ,
              bufSize,
              length ,
              size   ,
              type   ,
              name   );
    }

    template<
      typename TARGET_TYPE  = GLenum     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    inline TexSubImage2D<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      PIXELS_TYPE >* newTexSubImage2D(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        PIXELS_TYPE  const&pixels ){
        return new TexSubImage2D<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          PIXELS_TYPE >(
              target ,
              level  ,
              xoffset,
              yoffset,
              width  ,
              height ,
              format ,
              type   ,
              pixels );
    }
    template<
      typename TARGET_TYPE  = GLenum     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    inline std::shared_ptr<TexSubImage2D<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      PIXELS_TYPE >> sharedTexSubImage2D(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        PIXELS_TYPE  const&pixels ){
        return std::make_shared<TexSubImage2D<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          PIXELS_TYPE >>(
              target ,
              level  ,
              xoffset,
              yoffset,
              width  ,
              height ,
              format ,
              type   ,
              pixels );
    }

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename PARAMS_TYPE   = GLint*>
    inline GetUniformiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      PARAMS_TYPE  >* newGetUniformiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        PARAMS_TYPE   const&params  ){
        return new GetUniformiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          PARAMS_TYPE  >(
              program ,
              location,
              params  );
    }
    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename PARAMS_TYPE   = GLint*>
    inline std::shared_ptr<GetUniformiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      PARAMS_TYPE  >> sharedGetUniformiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        PARAMS_TYPE   const&params  ){
        return std::make_shared<GetUniformiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          PARAMS_TYPE  >>(
              program ,
              location,
              params  );
    }

    template<
      typename BUFFER_TYPE     = GLenum        ,
      typename DRAWBUFFER_TYPE = GLint         ,
      typename VALUE_TYPE      = const GLfloat*>
    inline ClearBufferfv<
      BUFFER_TYPE    ,
      DRAWBUFFER_TYPE,
      VALUE_TYPE     >* newClearBufferfv(
        BUFFER_TYPE     const&buffer    ,
        DRAWBUFFER_TYPE const&drawbuffer,
        VALUE_TYPE      const&value     ){
        return new ClearBufferfv<
          BUFFER_TYPE    ,
          DRAWBUFFER_TYPE,
          VALUE_TYPE     >(
              buffer    ,
              drawbuffer,
              value     );
    }
    template<
      typename BUFFER_TYPE     = GLenum        ,
      typename DRAWBUFFER_TYPE = GLint         ,
      typename VALUE_TYPE      = const GLfloat*>
    inline std::shared_ptr<ClearBufferfv<
      BUFFER_TYPE    ,
      DRAWBUFFER_TYPE,
      VALUE_TYPE     >> sharedClearBufferfv(
        BUFFER_TYPE     const&buffer    ,
        DRAWBUFFER_TYPE const&drawbuffer,
        VALUE_TYPE      const&value     ){
        return std::make_shared<ClearBufferfv<
          BUFFER_TYPE    ,
          DRAWBUFFER_TYPE,
          VALUE_TYPE     >>(
              buffer    ,
              drawbuffer,
              value     );
    }

    template<
      typename OPCODE_TYPE = GLenum>
    inline LogicOp<
      OPCODE_TYPE>* newLogicOp(
        OPCODE_TYPE const&opcode){
        return new LogicOp<
          OPCODE_TYPE>(
              opcode);
    }
    template<
      typename OPCODE_TYPE = GLenum>
    inline std::shared_ptr<LogicOp<
      OPCODE_TYPE>> sharedLogicOp(
        OPCODE_TYPE const&opcode){
        return std::make_shared<LogicOp<
          OPCODE_TYPE>>(
              opcode);
    }

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline ProgramUniformMatrix3x4fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix3x4fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix3x4fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<ProgramUniformMatrix3x4fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix3x4fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix3x4fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename PNAME_TYPE   = GLenum ,
      typename PARAMS_TYPE  = GLuint*>
    inline GetTextureParameterIuiv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newGetTextureParameterIuiv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new GetTextureParameterIuiv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              texture,
              pname  ,
              params );
    }
    template<
      typename TEXTURE_TYPE = GLuint ,
      typename PNAME_TYPE   = GLenum ,
      typename PARAMS_TYPE  = GLuint*>
    inline std::shared_ptr<GetTextureParameterIuiv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedGetTextureParameterIuiv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<GetTextureParameterIuiv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              texture,
              pname  ,
              params );
    }

    template<
      typename PROGRAM_TYPE  = GLuint       ,
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline ProgramUniform4uiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform4uiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform4uiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint       ,
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline std::shared_ptr<ProgramUniform4uiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform4uiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform4uiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint,
      typename V2_TYPE       = GLuint,
      typename V3_TYPE       = GLuint>
    inline Uniform4ui<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >* newUniform4ui(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return new Uniform4ui<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >(
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }
    template<
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint,
      typename V2_TYPE       = GLuint,
      typename V3_TYPE       = GLuint>
    inline std::shared_ptr<Uniform4ui<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >> sharedUniform4ui(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return std::make_shared<Uniform4ui<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >>(
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei>
    inline CopyTextureSubImage2D<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  ,
      HEIGHT_TYPE >* newCopyTextureSubImage2D(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ){
        return new CopyTextureSubImage2D<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  ,
          HEIGHT_TYPE >(
              texture,
              level  ,
              xoffset,
              yoffset,
              x      ,
              y      ,
              width  ,
              height );
    }
    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei>
    inline std::shared_ptr<CopyTextureSubImage2D<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  ,
      HEIGHT_TYPE >> sharedCopyTextureSubImage2D(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ){
        return std::make_shared<CopyTextureSubImage2D<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  ,
          HEIGHT_TYPE >>(
              texture,
              level  ,
              xoffset,
              yoffset,
              x      ,
              y      ,
              width  ,
              height );
    }

    template<
      typename TARGET_TYPE      = GLenum,
      typename FRAMEBUFFER_TYPE = GLuint>
    inline BindFramebuffer<
      TARGET_TYPE     ,
      FRAMEBUFFER_TYPE>* newBindFramebuffer(
        TARGET_TYPE      const&target     ,
        FRAMEBUFFER_TYPE const&framebuffer){
        return new BindFramebuffer<
          TARGET_TYPE     ,
          FRAMEBUFFER_TYPE>(
              target     ,
              framebuffer);
    }
    template<
      typename TARGET_TYPE      = GLenum,
      typename FRAMEBUFFER_TYPE = GLuint>
    inline std::shared_ptr<BindFramebuffer<
      TARGET_TYPE     ,
      FRAMEBUFFER_TYPE>> sharedBindFramebuffer(
        TARGET_TYPE      const&target     ,
        FRAMEBUFFER_TYPE const&framebuffer){
        return std::make_shared<BindFramebuffer<
          TARGET_TYPE     ,
          FRAMEBUFFER_TYPE>>(
              target     ,
              framebuffer);
    }

    template<
      typename MODE_TYPE = GLenum>
    inline CullFace<
      MODE_TYPE>* newCullFace(
        MODE_TYPE const&mode){
        return new CullFace<
          MODE_TYPE>(
              mode);
    }
    template<
      typename MODE_TYPE = GLenum>
    inline std::shared_ptr<CullFace<
      MODE_TYPE>> sharedCullFace(
        MODE_TYPE const&mode){
        return std::make_shared<CullFace<
          MODE_TYPE>>(
              mode);
    }

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLint ,
      typename V1_TYPE       = GLint ,
      typename V2_TYPE       = GLint ,
      typename V3_TYPE       = GLint >
    inline ProgramUniform4i<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >* newProgramUniform4i(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return new ProgramUniform4i<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >(
              program ,
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLint ,
      typename V1_TYPE       = GLint ,
      typename V2_TYPE       = GLint ,
      typename V3_TYPE       = GLint >
    inline std::shared_ptr<ProgramUniform4i<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >> sharedProgramUniform4i(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return std::make_shared<ProgramUniform4i<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >>(
              program ,
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat,
      typename V2_TYPE       = GLfloat,
      typename V3_TYPE       = GLfloat>
    inline ProgramUniform4f<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >* newProgramUniform4f(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return new ProgramUniform4f<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >(
              program ,
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat,
      typename V2_TYPE       = GLfloat,
      typename V3_TYPE       = GLfloat>
    inline std::shared_ptr<ProgramUniform4f<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >> sharedProgramUniform4f(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return std::make_shared<ProgramUniform4f<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >>(
              program ,
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat,
      typename Y_TYPE     = GLfloat,
      typename W_TYPE     = GLfloat,
      typename H_TYPE     = GLfloat>
    inline ViewportIndexedf<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      W_TYPE    ,
      H_TYPE    >* newViewportIndexedf(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        W_TYPE     const&w    ,
        H_TYPE     const&h    ){
        return new ViewportIndexedf<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          W_TYPE    ,
          H_TYPE    >(
              index,
              x    ,
              y    ,
              w    ,
              h    );
    }
    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat,
      typename Y_TYPE     = GLfloat,
      typename W_TYPE     = GLfloat,
      typename H_TYPE     = GLfloat>
    inline std::shared_ptr<ViewportIndexedf<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      W_TYPE    ,
      H_TYPE    >> sharedViewportIndexedf(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        W_TYPE     const&w    ,
        H_TYPE     const&h    ){
        return std::make_shared<ViewportIndexedf<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          W_TYPE    ,
          H_TYPE    >>(
              index,
              x    ,
              y    ,
              w    ,
              h    );
    }

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename V0_TYPE       = GLdouble,
      typename V1_TYPE       = GLdouble,
      typename V2_TYPE       = GLdouble,
      typename V3_TYPE       = GLdouble>
    inline ProgramUniform4d<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >* newProgramUniform4d(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return new ProgramUniform4d<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >(
              program ,
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename V0_TYPE       = GLdouble,
      typename V1_TYPE       = GLdouble,
      typename V2_TYPE       = GLdouble,
      typename V3_TYPE       = GLdouble>
    inline std::shared_ptr<ProgramUniform4d<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >> sharedProgramUniform4d(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return std::make_shared<ProgramUniform4d<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >>(
              program ,
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }

    template<
      typename TEXTURE_TYPE = GLuint      ,
      typename PNAME_TYPE   = GLenum      ,
      typename PARAMS_TYPE  = const GLint*>
    inline TextureParameterIiv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newTextureParameterIiv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new TextureParameterIiv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              texture,
              pname  ,
              params );
    }
    template<
      typename TEXTURE_TYPE = GLuint      ,
      typename PNAME_TYPE   = GLenum      ,
      typename PARAMS_TYPE  = const GLint*>
    inline std::shared_ptr<TextureParameterIiv<
      TEXTURE_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedTextureParameterIiv(
        TEXTURE_TYPE const&texture,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<TextureParameterIiv<
          TEXTURE_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              texture,
              pname  ,
              params );
    }

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    inline VertexAttribI2uiv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribI2uiv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribI2uiv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    inline std::shared_ptr<VertexAttribI2uiv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribI2uiv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribI2uiv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    inline TextureSubImage2D<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      PIXELS_TYPE >* newTextureSubImage2D(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        PIXELS_TYPE  const&pixels ){
        return new TextureSubImage2D<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          PIXELS_TYPE >(
              texture,
              level  ,
              xoffset,
              yoffset,
              width  ,
              height ,
              format ,
              type   ,
              pixels );
    }
    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename YOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename HEIGHT_TYPE  = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    inline std::shared_ptr<TextureSubImage2D<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      PIXELS_TYPE >> sharedTextureSubImage2D(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        PIXELS_TYPE  const&pixels ){
        return std::make_shared<TextureSubImage2D<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          PIXELS_TYPE >>(
              texture,
              level  ,
              xoffset,
              yoffset,
              width  ,
              height ,
              format ,
              type   ,
              pixels );
    }

    template<
      typename INDEX_TYPE  = GLuint ,
      typename LEFT_TYPE   = GLint  ,
      typename BOTTOM_TYPE = GLint  ,
      typename WIDTH_TYPE  = GLsizei,
      typename HEIGHT_TYPE = GLsizei>
    inline ScissorIndexed<
      INDEX_TYPE ,
      LEFT_TYPE  ,
      BOTTOM_TYPE,
      WIDTH_TYPE ,
      HEIGHT_TYPE>* newScissorIndexed(
        INDEX_TYPE  const&index ,
        LEFT_TYPE   const&left  ,
        BOTTOM_TYPE const&bottom,
        WIDTH_TYPE  const&width ,
        HEIGHT_TYPE const&height){
        return new ScissorIndexed<
          INDEX_TYPE ,
          LEFT_TYPE  ,
          BOTTOM_TYPE,
          WIDTH_TYPE ,
          HEIGHT_TYPE>(
              index ,
              left  ,
              bottom,
              width ,
              height);
    }
    template<
      typename INDEX_TYPE  = GLuint ,
      typename LEFT_TYPE   = GLint  ,
      typename BOTTOM_TYPE = GLint  ,
      typename WIDTH_TYPE  = GLsizei,
      typename HEIGHT_TYPE = GLsizei>
    inline std::shared_ptr<ScissorIndexed<
      INDEX_TYPE ,
      LEFT_TYPE  ,
      BOTTOM_TYPE,
      WIDTH_TYPE ,
      HEIGHT_TYPE>> sharedScissorIndexed(
        INDEX_TYPE  const&index ,
        LEFT_TYPE   const&left  ,
        BOTTOM_TYPE const&bottom,
        WIDTH_TYPE  const&width ,
        HEIGHT_TYPE const&height){
        return std::make_shared<ScissorIndexed<
          INDEX_TYPE ,
          LEFT_TYPE  ,
          BOTTOM_TYPE,
          WIDTH_TYPE ,
          HEIGHT_TYPE>>(
              index ,
              left  ,
              bottom,
              width ,
              height);
    }

    template<
      typename MODE_TYPE   = GLenum,
      typename ID_TYPE     = GLuint,
      typename STREAM_TYPE = GLuint>
    inline DrawTransformFeedbackStream<
      MODE_TYPE  ,
      ID_TYPE    ,
      STREAM_TYPE>* newDrawTransformFeedbackStream(
        MODE_TYPE   const&mode  ,
        ID_TYPE     const&id    ,
        STREAM_TYPE const&stream){
        return new DrawTransformFeedbackStream<
          MODE_TYPE  ,
          ID_TYPE    ,
          STREAM_TYPE>(
              mode  ,
              id    ,
              stream);
    }
    template<
      typename MODE_TYPE   = GLenum,
      typename ID_TYPE     = GLuint,
      typename STREAM_TYPE = GLuint>
    inline std::shared_ptr<DrawTransformFeedbackStream<
      MODE_TYPE  ,
      ID_TYPE    ,
      STREAM_TYPE>> sharedDrawTransformFeedbackStream(
        MODE_TYPE   const&mode  ,
        ID_TYPE     const&id    ,
        STREAM_TYPE const&stream){
        return std::make_shared<DrawTransformFeedbackStream<
          MODE_TYPE  ,
          ID_TYPE    ,
          STREAM_TYPE>>(
              mode  ,
              id    ,
              stream);
    }

    template<
      typename PROGRAM_TYPE = GLuint,
      typename SHADER_TYPE  = GLuint>
    inline AttachShader<
      PROGRAM_TYPE,
      SHADER_TYPE >* newAttachShader(
        PROGRAM_TYPE const&program,
        SHADER_TYPE  const&shader ){
        return new AttachShader<
          PROGRAM_TYPE,
          SHADER_TYPE >(
              program,
              shader );
    }
    template<
      typename PROGRAM_TYPE = GLuint,
      typename SHADER_TYPE  = GLuint>
    inline std::shared_ptr<AttachShader<
      PROGRAM_TYPE,
      SHADER_TYPE >> sharedAttachShader(
        PROGRAM_TYPE const&program,
        SHADER_TYPE  const&shader ){
        return std::make_shared<AttachShader<
          PROGRAM_TYPE,
          SHADER_TYPE >>(
              program,
              shader );
    }

    template<
      typename TEXTURE_TYPE        = GLuint,
      typename INTERNALFORMAT_TYPE = GLenum,
      typename BUFFER_TYPE         = GLuint>
    inline TextureBuffer<
      TEXTURE_TYPE       ,
      INTERNALFORMAT_TYPE,
      BUFFER_TYPE        >* newTextureBuffer(
        TEXTURE_TYPE        const&texture       ,
        INTERNALFORMAT_TYPE const&internalformat,
        BUFFER_TYPE         const&buffer        ){
        return new TextureBuffer<
          TEXTURE_TYPE       ,
          INTERNALFORMAT_TYPE,
          BUFFER_TYPE        >(
              texture       ,
              internalformat,
              buffer        );
    }
    template<
      typename TEXTURE_TYPE        = GLuint,
      typename INTERNALFORMAT_TYPE = GLenum,
      typename BUFFER_TYPE         = GLuint>
    inline std::shared_ptr<TextureBuffer<
      TEXTURE_TYPE       ,
      INTERNALFORMAT_TYPE,
      BUFFER_TYPE        >> sharedTextureBuffer(
        TEXTURE_TYPE        const&texture       ,
        INTERNALFORMAT_TYPE const&internalformat,
        BUFFER_TYPE         const&buffer        ){
        return std::make_shared<TextureBuffer<
          TEXTURE_TYPE       ,
          INTERNALFORMAT_TYPE,
          BUFFER_TYPE        >>(
              texture       ,
              internalformat,
              buffer        );
    }

    template<
      typename ID_TYPE     = GLuint,
      typename TARGET_TYPE = GLenum>
    inline QueryCounter<
      ID_TYPE    ,
      TARGET_TYPE>* newQueryCounter(
        ID_TYPE     const&id    ,
        TARGET_TYPE const&target){
        return new QueryCounter<
          ID_TYPE    ,
          TARGET_TYPE>(
              id    ,
              target);
    }
    template<
      typename ID_TYPE     = GLuint,
      typename TARGET_TYPE = GLenum>
    inline std::shared_ptr<QueryCounter<
      ID_TYPE    ,
      TARGET_TYPE>> sharedQueryCounter(
        ID_TYPE     const&id    ,
        TARGET_TYPE const&target){
        return std::make_shared<QueryCounter<
          ID_TYPE    ,
          TARGET_TYPE>>(
              id    ,
              target);
    }

    template<
      typename PROGRAM_TYPE = GLuint>
    inline DeleteProgram<
      PROGRAM_TYPE>* newDeleteProgram(
        PROGRAM_TYPE const&program){
        return new DeleteProgram<
          PROGRAM_TYPE>(
              program);
    }
    template<
      typename PROGRAM_TYPE = GLuint>
    inline std::shared_ptr<DeleteProgram<
      PROGRAM_TYPE>> sharedDeleteProgram(
        PROGRAM_TYPE const&program){
        return std::make_shared<DeleteProgram<
          PROGRAM_TYPE>>(
              program);
    }

    template<
      typename MODE_TYPE = GLenum>
    inline ProvokingVertex<
      MODE_TYPE>* newProvokingVertex(
        MODE_TYPE const&mode){
        return new ProvokingVertex<
          MODE_TYPE>(
              mode);
    }
    template<
      typename MODE_TYPE = GLenum>
    inline std::shared_ptr<ProvokingVertex<
      MODE_TYPE>> sharedProvokingVertex(
        MODE_TYPE const&mode){
        return std::make_shared<ProvokingVertex<
          MODE_TYPE>>(
              mode);
    }

    template<
      typename COUNT_TYPE        = GLsizei      ,
      typename SHADERS_TYPE      = const GLuint*,
      typename BINARYFORMAT_TYPE = GLenum       ,
      typename BINARY_TYPE       = const void*  ,
      typename LENGTH_TYPE       = GLsizei      >
    inline ShaderBinary<
      COUNT_TYPE       ,
      SHADERS_TYPE     ,
      BINARYFORMAT_TYPE,
      BINARY_TYPE      ,
      LENGTH_TYPE      >* newShaderBinary(
        COUNT_TYPE        const&count       ,
        SHADERS_TYPE      const&shaders     ,
        BINARYFORMAT_TYPE const&binaryformat,
        BINARY_TYPE       const&binary      ,
        LENGTH_TYPE       const&length      ){
        return new ShaderBinary<
          COUNT_TYPE       ,
          SHADERS_TYPE     ,
          BINARYFORMAT_TYPE,
          BINARY_TYPE      ,
          LENGTH_TYPE      >(
              count       ,
              shaders     ,
              binaryformat,
              binary      ,
              length      );
    }
    template<
      typename COUNT_TYPE        = GLsizei      ,
      typename SHADERS_TYPE      = const GLuint*,
      typename BINARYFORMAT_TYPE = GLenum       ,
      typename BINARY_TYPE       = const void*  ,
      typename LENGTH_TYPE       = GLsizei      >
    inline std::shared_ptr<ShaderBinary<
      COUNT_TYPE       ,
      SHADERS_TYPE     ,
      BINARYFORMAT_TYPE,
      BINARY_TYPE      ,
      LENGTH_TYPE      >> sharedShaderBinary(
        COUNT_TYPE        const&count       ,
        SHADERS_TYPE      const&shaders     ,
        BINARYFORMAT_TYPE const&binaryformat,
        BINARY_TYPE       const&binary      ,
        LENGTH_TYPE       const&length      ){
        return std::make_shared<ShaderBinary<
          COUNT_TYPE       ,
          SHADERS_TYPE     ,
          BINARYFORMAT_TYPE,
          BINARY_TYPE      ,
          LENGTH_TYPE      >>(
              count       ,
              shaders     ,
              binaryformat,
              binary      ,
              length      );
    }

    template<
      typename RET_TYPE    = GLboolean,
      typename BUFFER_TYPE = GLuint   >
    inline UnmapNamedBuffer<
      RET_TYPE   ,
      BUFFER_TYPE>* newUnmapNamedBuffer(
        RET_TYPE    const&ret   ,
        BUFFER_TYPE const&buffer){
        return new UnmapNamedBuffer<
          RET_TYPE   ,
          BUFFER_TYPE>(
              ret   ,
              buffer);
    }
    template<
      typename RET_TYPE    = GLboolean,
      typename BUFFER_TYPE = GLuint   >
    inline std::shared_ptr<UnmapNamedBuffer<
      RET_TYPE   ,
      BUFFER_TYPE>> sharedUnmapNamedBuffer(
        RET_TYPE    const&ret   ,
        BUFFER_TYPE const&buffer){
        return std::make_shared<UnmapNamedBuffer<
          RET_TYPE   ,
          BUFFER_TYPE>>(
              ret   ,
              buffer);
    }

    template<
      typename MODE_TYPE    = GLenum     ,
      typename COUNT_TYPE   = GLsizei    ,
      typename TYPE_TYPE    = GLenum     ,
      typename INDICES_TYPE = const void*>
    inline DrawElements<
      MODE_TYPE   ,
      COUNT_TYPE  ,
      TYPE_TYPE   ,
      INDICES_TYPE>* newDrawElements(
        MODE_TYPE    const&mode   ,
        COUNT_TYPE   const&count  ,
        TYPE_TYPE    const&type   ,
        INDICES_TYPE const&indices){
        return new DrawElements<
          MODE_TYPE   ,
          COUNT_TYPE  ,
          TYPE_TYPE   ,
          INDICES_TYPE>(
              mode   ,
              count  ,
              type   ,
              indices);
    }
    template<
      typename MODE_TYPE    = GLenum     ,
      typename COUNT_TYPE   = GLsizei    ,
      typename TYPE_TYPE    = GLenum     ,
      typename INDICES_TYPE = const void*>
    inline std::shared_ptr<DrawElements<
      MODE_TYPE   ,
      COUNT_TYPE  ,
      TYPE_TYPE   ,
      INDICES_TYPE>> sharedDrawElements(
        MODE_TYPE    const&mode   ,
        COUNT_TYPE   const&count  ,
        TYPE_TYPE    const&type   ,
        INDICES_TYPE const&indices){
        return std::make_shared<DrawElements<
          MODE_TYPE   ,
          COUNT_TYPE  ,
          TYPE_TYPE   ,
          INDICES_TYPE>>(
              mode   ,
              count  ,
              type   ,
              indices);
    }

    template<
      typename RENDERBUFFER_TYPE   = GLuint ,
      typename SAMPLES_TYPE        = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    inline NamedRenderbufferStorageMultisample<
      RENDERBUFFER_TYPE  ,
      SAMPLES_TYPE       ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >* newNamedRenderbufferStorageMultisample(
        RENDERBUFFER_TYPE   const&renderbuffer  ,
        SAMPLES_TYPE        const&samples       ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return new NamedRenderbufferStorageMultisample<
          RENDERBUFFER_TYPE  ,
          SAMPLES_TYPE       ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >(
              renderbuffer  ,
              samples       ,
              internalformat,
              width         ,
              height        );
    }
    template<
      typename RENDERBUFFER_TYPE   = GLuint ,
      typename SAMPLES_TYPE        = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    inline std::shared_ptr<NamedRenderbufferStorageMultisample<
      RENDERBUFFER_TYPE  ,
      SAMPLES_TYPE       ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >> sharedNamedRenderbufferStorageMultisample(
        RENDERBUFFER_TYPE   const&renderbuffer  ,
        SAMPLES_TYPE        const&samples       ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return std::make_shared<NamedRenderbufferStorageMultisample<
          RENDERBUFFER_TYPE  ,
          SAMPLES_TYPE       ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >>(
              renderbuffer  ,
              samples       ,
              internalformat,
              width         ,
              height        );
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    inline VertexAttribI4sv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribI4sv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribI4sv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    inline std::shared_ptr<VertexAttribI4sv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribI4sv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribI4sv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename BUFFER_TYPE         = GLuint     ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename DATA_TYPE           = const void*>
    inline ClearNamedBufferData<
      BUFFER_TYPE        ,
      INTERNALFORMAT_TYPE,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      DATA_TYPE          >* newClearNamedBufferData(
        BUFFER_TYPE         const&buffer        ,
        INTERNALFORMAT_TYPE const&internalformat,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        DATA_TYPE           const&data          ){
        return new ClearNamedBufferData<
          BUFFER_TYPE        ,
          INTERNALFORMAT_TYPE,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          DATA_TYPE          >(
              buffer        ,
              internalformat,
              format        ,
              type          ,
              data          );
    }
    template<
      typename BUFFER_TYPE         = GLuint     ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename DATA_TYPE           = const void*>
    inline std::shared_ptr<ClearNamedBufferData<
      BUFFER_TYPE        ,
      INTERNALFORMAT_TYPE,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      DATA_TYPE          >> sharedClearNamedBufferData(
        BUFFER_TYPE         const&buffer        ,
        INTERNALFORMAT_TYPE const&internalformat,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        DATA_TYPE           const&data          ){
        return std::make_shared<ClearNamedBufferData<
          BUFFER_TYPE        ,
          INTERNALFORMAT_TYPE,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          DATA_TYPE          >>(
              buffer        ,
              internalformat,
              format        ,
              type          ,
              data          );
    }

    template<
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline Uniform1iv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform1iv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform1iv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline std::shared_ptr<Uniform1iv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform1iv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform1iv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename RET_TYPE     = GLuint             ,
      typename TYPE_TYPE    = GLenum             ,
      typename COUNT_TYPE   = GLsizei            ,
      typename STRINGS_TYPE = const GLchar*const*>
    inline CreateShaderProgramv<
      RET_TYPE    ,
      TYPE_TYPE   ,
      COUNT_TYPE  ,
      STRINGS_TYPE>* newCreateShaderProgramv(
        RET_TYPE     const&ret    ,
        TYPE_TYPE    const&type   ,
        COUNT_TYPE   const&count  ,
        STRINGS_TYPE const&strings){
        return new CreateShaderProgramv<
          RET_TYPE    ,
          TYPE_TYPE   ,
          COUNT_TYPE  ,
          STRINGS_TYPE>(
              ret    ,
              type   ,
              count  ,
              strings);
    }
    template<
      typename RET_TYPE     = GLuint             ,
      typename TYPE_TYPE    = GLenum             ,
      typename COUNT_TYPE   = GLsizei            ,
      typename STRINGS_TYPE = const GLchar*const*>
    inline std::shared_ptr<CreateShaderProgramv<
      RET_TYPE    ,
      TYPE_TYPE   ,
      COUNT_TYPE  ,
      STRINGS_TYPE>> sharedCreateShaderProgramv(
        RET_TYPE     const&ret    ,
        TYPE_TYPE    const&type   ,
        COUNT_TYPE   const&count  ,
        STRINGS_TYPE const&strings){
        return std::make_shared<CreateShaderProgramv<
          RET_TYPE    ,
          TYPE_TYPE   ,
          COUNT_TYPE  ,
          STRINGS_TYPE>>(
              ret    ,
              type   ,
              count  ,
              strings);
    }

    template<
      typename ID_TYPE     = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetQueryObjectiv<
      ID_TYPE    ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetQueryObjectiv(
        ID_TYPE     const&id    ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetQueryObjectiv<
          ID_TYPE    ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              id    ,
              pname ,
              params);
    }
    template<
      typename ID_TYPE     = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetQueryObjectiv<
      ID_TYPE    ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetQueryObjectiv(
        ID_TYPE     const&id    ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetQueryObjectiv<
          ID_TYPE    ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              id    ,
              pname ,
              params);
    }

    template<
      typename SRC_TYPE = GLenum>
    inline ReadBuffer<
      SRC_TYPE>* newReadBuffer(
        SRC_TYPE const&src){
        return new ReadBuffer<
          SRC_TYPE>(
              src);
    }
    template<
      typename SRC_TYPE = GLenum>
    inline std::shared_ptr<ReadBuffer<
      SRC_TYPE>> sharedReadBuffer(
        SRC_TYPE const&src){
        return std::make_shared<ReadBuffer<
          SRC_TYPE>>(
              src);
    }

    template<
      typename TARGET_TYPE = GLenum       ,
      typename PNAME_TYPE  = GLenum       ,
      typename PARAMS_TYPE = const GLuint*>
    inline TexParameterIuiv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newTexParameterIuiv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new TexParameterIuiv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum       ,
      typename PNAME_TYPE  = GLenum       ,
      typename PARAMS_TYPE = const GLuint*>
    inline std::shared_ptr<TexParameterIuiv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedTexParameterIuiv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<TexParameterIuiv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename MODE_TYPE          = GLenum ,
      typename FIRST_TYPE         = GLint  ,
      typename COUNT_TYPE         = GLsizei,
      typename INSTANCECOUNT_TYPE = GLsizei>
    inline DrawArraysInstanced<
      MODE_TYPE         ,
      FIRST_TYPE        ,
      COUNT_TYPE        ,
      INSTANCECOUNT_TYPE>* newDrawArraysInstanced(
        MODE_TYPE          const&mode         ,
        FIRST_TYPE         const&first        ,
        COUNT_TYPE         const&count        ,
        INSTANCECOUNT_TYPE const&instancecount){
        return new DrawArraysInstanced<
          MODE_TYPE         ,
          FIRST_TYPE        ,
          COUNT_TYPE        ,
          INSTANCECOUNT_TYPE>(
              mode         ,
              first        ,
              count        ,
              instancecount);
    }
    template<
      typename MODE_TYPE          = GLenum ,
      typename FIRST_TYPE         = GLint  ,
      typename COUNT_TYPE         = GLsizei,
      typename INSTANCECOUNT_TYPE = GLsizei>
    inline std::shared_ptr<DrawArraysInstanced<
      MODE_TYPE         ,
      FIRST_TYPE        ,
      COUNT_TYPE        ,
      INSTANCECOUNT_TYPE>> sharedDrawArraysInstanced(
        MODE_TYPE          const&mode         ,
        FIRST_TYPE         const&first        ,
        COUNT_TYPE         const&count        ,
        INSTANCECOUNT_TYPE const&instancecount){
        return std::make_shared<DrawArraysInstanced<
          MODE_TYPE         ,
          FIRST_TYPE        ,
          COUNT_TYPE        ,
          INSTANCECOUNT_TYPE>>(
              mode         ,
              first        ,
              count        ,
              instancecount);
    }

    template<
      typename TARGET_TYPE = GLenum>
    inline GenerateMipmap<
      TARGET_TYPE>* newGenerateMipmap(
        TARGET_TYPE const&target){
        return new GenerateMipmap<
          TARGET_TYPE>(
              target);
    }
    template<
      typename TARGET_TYPE = GLenum>
    inline std::shared_ptr<GenerateMipmap<
      TARGET_TYPE>> sharedGenerateMipmap(
        TARGET_TYPE const&target){
        return std::make_shared<GenerateMipmap<
          TARGET_TYPE>>(
              target);
    }

    template<
      typename TEXTURE_TYPE   = GLuint     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename YOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename HEIGHT_TYPE    = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    inline CompressedTextureSubImage2D<
      TEXTURE_TYPE  ,
      LEVEL_TYPE    ,
      XOFFSET_TYPE  ,
      YOFFSET_TYPE  ,
      WIDTH_TYPE    ,
      HEIGHT_TYPE   ,
      FORMAT_TYPE   ,
      IMAGESIZE_TYPE,
      DATA_TYPE     >* newCompressedTextureSubImage2D(
        TEXTURE_TYPE   const&texture  ,
        LEVEL_TYPE     const&level    ,
        XOFFSET_TYPE   const&xoffset  ,
        YOFFSET_TYPE   const&yoffset  ,
        WIDTH_TYPE     const&width    ,
        HEIGHT_TYPE    const&height   ,
        FORMAT_TYPE    const&format   ,
        IMAGESIZE_TYPE const&imageSize,
        DATA_TYPE      const&data     ){
        return new CompressedTextureSubImage2D<
          TEXTURE_TYPE  ,
          LEVEL_TYPE    ,
          XOFFSET_TYPE  ,
          YOFFSET_TYPE  ,
          WIDTH_TYPE    ,
          HEIGHT_TYPE   ,
          FORMAT_TYPE   ,
          IMAGESIZE_TYPE,
          DATA_TYPE     >(
              texture  ,
              level    ,
              xoffset  ,
              yoffset  ,
              width    ,
              height   ,
              format   ,
              imageSize,
              data     );
    }
    template<
      typename TEXTURE_TYPE   = GLuint     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename YOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename HEIGHT_TYPE    = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    inline std::shared_ptr<CompressedTextureSubImage2D<
      TEXTURE_TYPE  ,
      LEVEL_TYPE    ,
      XOFFSET_TYPE  ,
      YOFFSET_TYPE  ,
      WIDTH_TYPE    ,
      HEIGHT_TYPE   ,
      FORMAT_TYPE   ,
      IMAGESIZE_TYPE,
      DATA_TYPE     >> sharedCompressedTextureSubImage2D(
        TEXTURE_TYPE   const&texture  ,
        LEVEL_TYPE     const&level    ,
        XOFFSET_TYPE   const&xoffset  ,
        YOFFSET_TYPE   const&yoffset  ,
        WIDTH_TYPE     const&width    ,
        HEIGHT_TYPE    const&height   ,
        FORMAT_TYPE    const&format   ,
        IMAGESIZE_TYPE const&imageSize,
        DATA_TYPE      const&data     ){
        return std::make_shared<CompressedTextureSubImage2D<
          TEXTURE_TYPE  ,
          LEVEL_TYPE    ,
          XOFFSET_TYPE  ,
          YOFFSET_TYPE  ,
          WIDTH_TYPE    ,
          HEIGHT_TYPE   ,
          FORMAT_TYPE   ,
          IMAGESIZE_TYPE,
          DATA_TYPE     >>(
              texture  ,
              level    ,
              xoffset  ,
              yoffset  ,
              width    ,
              height   ,
              format   ,
              imageSize,
              data     );
    }

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline ProgramUniformMatrix2fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix2fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix2fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<ProgramUniformMatrix2fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix2fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix2fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename SAMPLER_TYPE = GLuint      ,
      typename PNAME_TYPE   = GLenum      ,
      typename PARAM_TYPE   = const GLint*>
    inline SamplerParameteriv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >* newSamplerParameteriv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return new SamplerParameteriv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >(
              sampler,
              pname  ,
              param  );
    }
    template<
      typename SAMPLER_TYPE = GLuint      ,
      typename PNAME_TYPE   = GLenum      ,
      typename PARAM_TYPE   = const GLint*>
    inline std::shared_ptr<SamplerParameteriv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >> sharedSamplerParameteriv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return std::make_shared<SamplerParameteriv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >>(
              sampler,
              pname  ,
              param  );
    }

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat,
      typename Y_TYPE     = GLfloat,
      typename Z_TYPE     = GLfloat>
    inline VertexAttrib3f<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    >* newVertexAttrib3f(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ){
        return new VertexAttrib3f<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    >(
              index,
              x    ,
              y    ,
              z    );
    }
    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat,
      typename Y_TYPE     = GLfloat,
      typename Z_TYPE     = GLfloat>
    inline std::shared_ptr<VertexAttrib3f<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    >> sharedVertexAttrib3f(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ){
        return std::make_shared<VertexAttrib3f<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    >>(
              index,
              x    ,
              y    ,
              z    );
    }

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    inline VertexAttrib4uiv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4uiv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4uiv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    inline std::shared_ptr<VertexAttrib4uiv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4uiv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4uiv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint >
    inline PointParameteri<
      PNAME_TYPE,
      PARAM_TYPE>* newPointParameteri(
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return new PointParameteri<
          PNAME_TYPE,
          PARAM_TYPE>(
              pname,
              param);
    }
    template<
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint >
    inline std::shared_ptr<PointParameteri<
      PNAME_TYPE,
      PARAM_TYPE>> sharedPointParameteri(
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return std::make_shared<PointParameteri<
          PNAME_TYPE,
          PARAM_TYPE>>(
              pname,
              param);
    }

    template<
      typename RED_TYPE   = GLfloat,
      typename GREEN_TYPE = GLfloat,
      typename BLUE_TYPE  = GLfloat,
      typename ALPHA_TYPE = GLfloat>
    inline BlendColor<
      RED_TYPE  ,
      GREEN_TYPE,
      BLUE_TYPE ,
      ALPHA_TYPE>* newBlendColor(
        RED_TYPE   const&red  ,
        GREEN_TYPE const&green,
        BLUE_TYPE  const&blue ,
        ALPHA_TYPE const&alpha){
        return new BlendColor<
          RED_TYPE  ,
          GREEN_TYPE,
          BLUE_TYPE ,
          ALPHA_TYPE>(
              red  ,
              green,
              blue ,
              alpha);
    }
    template<
      typename RED_TYPE   = GLfloat,
      typename GREEN_TYPE = GLfloat,
      typename BLUE_TYPE  = GLfloat,
      typename ALPHA_TYPE = GLfloat>
    inline std::shared_ptr<BlendColor<
      RED_TYPE  ,
      GREEN_TYPE,
      BLUE_TYPE ,
      ALPHA_TYPE>> sharedBlendColor(
        RED_TYPE   const&red  ,
        GREEN_TYPE const&green,
        BLUE_TYPE  const&blue ,
        ALPHA_TYPE const&alpha){
        return std::make_shared<BlendColor<
          RED_TYPE  ,
          GREEN_TYPE,
          BLUE_TYPE ,
          ALPHA_TYPE>>(
              red  ,
              green,
              blue ,
              alpha);
    }

    template<
      typename SAMPLER_TYPE = GLuint       ,
      typename PNAME_TYPE   = GLenum       ,
      typename PARAM_TYPE   = const GLuint*>
    inline SamplerParameterIuiv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >* newSamplerParameterIuiv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return new SamplerParameterIuiv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >(
              sampler,
              pname  ,
              param  );
    }
    template<
      typename SAMPLER_TYPE = GLuint       ,
      typename PNAME_TYPE   = GLenum       ,
      typename PARAM_TYPE   = const GLuint*>
    inline std::shared_ptr<SamplerParameterIuiv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >> sharedSamplerParameterIuiv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return std::make_shared<SamplerParameterIuiv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >>(
              sampler,
              pname  ,
              param  );
    }

    template<
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr,
      typename COMMIT_TYPE = GLboolean >
    inline NamedBufferPageCommitmentEXT<
      BUFFER_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  ,
      COMMIT_TYPE>* newNamedBufferPageCommitmentEXT(
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ,
        COMMIT_TYPE const&commit){
        return new NamedBufferPageCommitmentEXT<
          BUFFER_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  ,
          COMMIT_TYPE>(
              buffer,
              offset,
              size  ,
              commit);
    }
    template<
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr,
      typename COMMIT_TYPE = GLboolean >
    inline std::shared_ptr<NamedBufferPageCommitmentEXT<
      BUFFER_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  ,
      COMMIT_TYPE>> sharedNamedBufferPageCommitmentEXT(
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ,
        COMMIT_TYPE const&commit){
        return std::make_shared<NamedBufferPageCommitmentEXT<
          BUFFER_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  ,
          COMMIT_TYPE>>(
              buffer,
              offset,
              size  ,
              commit);
    }

    template<
      typename RET_TYPE         = GLenum,
      typename FRAMEBUFFER_TYPE = GLuint,
      typename TARGET_TYPE      = GLenum>
    inline CheckNamedFramebufferStatus<
      RET_TYPE        ,
      FRAMEBUFFER_TYPE,
      TARGET_TYPE     >* newCheckNamedFramebufferStatus(
        RET_TYPE         const&ret        ,
        FRAMEBUFFER_TYPE const&framebuffer,
        TARGET_TYPE      const&target     ){
        return new CheckNamedFramebufferStatus<
          RET_TYPE        ,
          FRAMEBUFFER_TYPE,
          TARGET_TYPE     >(
              ret        ,
              framebuffer,
              target     );
    }
    template<
      typename RET_TYPE         = GLenum,
      typename FRAMEBUFFER_TYPE = GLuint,
      typename TARGET_TYPE      = GLenum>
    inline std::shared_ptr<CheckNamedFramebufferStatus<
      RET_TYPE        ,
      FRAMEBUFFER_TYPE,
      TARGET_TYPE     >> sharedCheckNamedFramebufferStatus(
        RET_TYPE         const&ret        ,
        FRAMEBUFFER_TYPE const&framebuffer,
        TARGET_TYPE      const&target     ){
        return std::make_shared<CheckNamedFramebufferStatus<
          RET_TYPE        ,
          FRAMEBUFFER_TYPE,
          TARGET_TYPE     >>(
              ret        ,
              framebuffer,
              target     );
    }

    template<
      typename RET_TYPE    = GLboolean,
      typename TARGET_TYPE = GLenum   >
    inline UnmapBuffer<
      RET_TYPE   ,
      TARGET_TYPE>* newUnmapBuffer(
        RET_TYPE    const&ret   ,
        TARGET_TYPE const&target){
        return new UnmapBuffer<
          RET_TYPE   ,
          TARGET_TYPE>(
              ret   ,
              target);
    }
    template<
      typename RET_TYPE    = GLboolean,
      typename TARGET_TYPE = GLenum   >
    inline std::shared_ptr<UnmapBuffer<
      RET_TYPE   ,
      TARGET_TYPE>> sharedUnmapBuffer(
        RET_TYPE    const&ret   ,
        TARGET_TYPE const&target){
        return std::make_shared<UnmapBuffer<
          RET_TYPE   ,
          TARGET_TYPE>>(
              ret   ,
              target);
    }

    template<
      typename PNAME_TYPE = GLenum ,
      typename PARAM_TYPE = GLfloat>
    inline PointParameterf<
      PNAME_TYPE,
      PARAM_TYPE>* newPointParameterf(
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return new PointParameterf<
          PNAME_TYPE,
          PARAM_TYPE>(
              pname,
              param);
    }
    template<
      typename PNAME_TYPE = GLenum ,
      typename PARAM_TYPE = GLfloat>
    inline std::shared_ptr<PointParameterf<
      PNAME_TYPE,
      PARAM_TYPE>> sharedPointParameterf(
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return std::make_shared<PointParameterf<
          PNAME_TYPE,
          PARAM_TYPE>>(
              pname,
              param);
    }

    template<
      typename PROGRAM_TYPE  = GLuint      ,
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline ProgramUniform1iv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform1iv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform1iv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint      ,
      typename LOCATION_TYPE = GLint       ,
      typename COUNT_TYPE    = GLsizei     ,
      typename VALUE_TYPE    = const GLint*>
    inline std::shared_ptr<ProgramUniform1iv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform1iv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform1iv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    inline VertexAttrib4sv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4sv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4sv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    inline std::shared_ptr<VertexAttrib4sv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4sv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4sv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLshort,
      typename Y_TYPE     = GLshort,
      typename Z_TYPE     = GLshort>
    inline VertexAttrib3s<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    >* newVertexAttrib3s(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ){
        return new VertexAttrib3s<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    >(
              index,
              x    ,
              y    ,
              z    );
    }
    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLshort,
      typename Y_TYPE     = GLshort,
      typename Z_TYPE     = GLshort>
    inline std::shared_ptr<VertexAttrib3s<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    >> sharedVertexAttrib3s(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ){
        return std::make_shared<VertexAttrib3s<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    >>(
              index,
              x    ,
              y    ,
              z    );
    }

    template<
      typename TARGET_TYPE       = GLenum,
      typename RENDERBUFFER_TYPE = GLuint>
    inline BindRenderbuffer<
      TARGET_TYPE      ,
      RENDERBUFFER_TYPE>* newBindRenderbuffer(
        TARGET_TYPE       const&target      ,
        RENDERBUFFER_TYPE const&renderbuffer){
        return new BindRenderbuffer<
          TARGET_TYPE      ,
          RENDERBUFFER_TYPE>(
              target      ,
              renderbuffer);
    }
    template<
      typename TARGET_TYPE       = GLenum,
      typename RENDERBUFFER_TYPE = GLuint>
    inline std::shared_ptr<BindRenderbuffer<
      TARGET_TYPE      ,
      RENDERBUFFER_TYPE>> sharedBindRenderbuffer(
        TARGET_TYPE       const&target      ,
        RENDERBUFFER_TYPE const&renderbuffer){
        return std::make_shared<BindRenderbuffer<
          TARGET_TYPE      ,
          RENDERBUFFER_TYPE>>(
              target      ,
              renderbuffer);
    }

    template<
      typename INDEX_TYPE      = GLuint       ,
      typename TYPE_TYPE       = GLenum       ,
      typename NORMALIZED_TYPE = GLboolean    ,
      typename VALUE_TYPE      = const GLuint*>
    inline VertexAttribP4uiv<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >* newVertexAttribP4uiv(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return new VertexAttribP4uiv<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >(
              index     ,
              type      ,
              normalized,
              value     );
    }
    template<
      typename INDEX_TYPE      = GLuint       ,
      typename TYPE_TYPE       = GLenum       ,
      typename NORMALIZED_TYPE = GLboolean    ,
      typename VALUE_TYPE      = const GLuint*>
    inline std::shared_ptr<VertexAttribP4uiv<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >> sharedVertexAttribP4uiv(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return std::make_shared<VertexAttribP4uiv<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >>(
              index     ,
              type      ,
              normalized,
              value     );
    }

    template<
      typename PROGRAM_TYPE    = GLuint,
      typename SHADERTYPE_TYPE = GLenum,
      typename PNAME_TYPE      = GLenum,
      typename VALUES_TYPE     = GLint*>
    inline GetProgramStageiv<
      PROGRAM_TYPE   ,
      SHADERTYPE_TYPE,
      PNAME_TYPE     ,
      VALUES_TYPE    >* newGetProgramStageiv(
        PROGRAM_TYPE    const&program   ,
        SHADERTYPE_TYPE const&shadertype,
        PNAME_TYPE      const&pname     ,
        VALUES_TYPE     const&values    ){
        return new GetProgramStageiv<
          PROGRAM_TYPE   ,
          SHADERTYPE_TYPE,
          PNAME_TYPE     ,
          VALUES_TYPE    >(
              program   ,
              shadertype,
              pname     ,
              values    );
    }
    template<
      typename PROGRAM_TYPE    = GLuint,
      typename SHADERTYPE_TYPE = GLenum,
      typename PNAME_TYPE      = GLenum,
      typename VALUES_TYPE     = GLint*>
    inline std::shared_ptr<GetProgramStageiv<
      PROGRAM_TYPE   ,
      SHADERTYPE_TYPE,
      PNAME_TYPE     ,
      VALUES_TYPE    >> sharedGetProgramStageiv(
        PROGRAM_TYPE    const&program   ,
        SHADERTYPE_TYPE const&shadertype,
        PNAME_TYPE      const&pname     ,
        VALUES_TYPE     const&values    ){
        return std::make_shared<GetProgramStageiv<
          PROGRAM_TYPE   ,
          SHADERTYPE_TYPE,
          PNAME_TYPE     ,
          VALUES_TYPE    >>(
              program   ,
              shadertype,
              pname     ,
              values    );
    }

    template<
      typename RET_TYPE     = GLboolean,
      typename PROGRAM_TYPE = GLuint   >
    inline IsProgram<
      RET_TYPE    ,
      PROGRAM_TYPE>* newIsProgram(
        RET_TYPE     const&ret    ,
        PROGRAM_TYPE const&program){
        return new IsProgram<
          RET_TYPE    ,
          PROGRAM_TYPE>(
              ret    ,
              program);
    }
    template<
      typename RET_TYPE     = GLboolean,
      typename PROGRAM_TYPE = GLuint   >
    inline std::shared_ptr<IsProgram<
      RET_TYPE    ,
      PROGRAM_TYPE>> sharedIsProgram(
        RET_TYPE     const&ret    ,
        PROGRAM_TYPE const&program){
        return std::make_shared<IsProgram<
          RET_TYPE    ,
          PROGRAM_TYPE>>(
              ret    ,
              program);
    }

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLbyte*>
    inline VertexAttrib4bv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4bv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4bv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLbyte*>
    inline std::shared_ptr<VertexAttrib4bv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4bv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4bv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename TEXTURE_TYPE        = GLuint ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei,
      typename DEPTH_TYPE          = GLsizei>
    inline TextureStorage3D<
      TEXTURE_TYPE       ,
      LEVELS_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      DEPTH_TYPE         >* newTextureStorage3D(
        TEXTURE_TYPE        const&texture       ,
        LEVELS_TYPE         const&levels        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        DEPTH_TYPE          const&depth         ){
        return new TextureStorage3D<
          TEXTURE_TYPE       ,
          LEVELS_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          DEPTH_TYPE         >(
              texture       ,
              levels        ,
              internalformat,
              width         ,
              height        ,
              depth         );
    }
    template<
      typename TEXTURE_TYPE        = GLuint ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei,
      typename DEPTH_TYPE          = GLsizei>
    inline std::shared_ptr<TextureStorage3D<
      TEXTURE_TYPE       ,
      LEVELS_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      DEPTH_TYPE         >> sharedTextureStorage3D(
        TEXTURE_TYPE        const&texture       ,
        LEVELS_TYPE         const&levels        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        DEPTH_TYPE          const&depth         ){
        return std::make_shared<TextureStorage3D<
          TEXTURE_TYPE       ,
          LEVELS_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          DEPTH_TYPE         >>(
              texture       ,
              levels        ,
              internalformat,
              width         ,
              height        ,
              depth         );
    }

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline UniformMatrix3x2dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix3x2dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix3x2dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<UniformMatrix3x2dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix3x2dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix3x2dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    inline VertexAttrib4fv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4fv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4fv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    inline std::shared_ptr<VertexAttrib4fv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4fv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4fv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline ProgramUniformMatrix2x3dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix2x3dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix2x3dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<ProgramUniformMatrix2x3dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix2x3dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix2x3dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename RET_TYPE = GLboolean,
      typename ID_TYPE  = GLuint   >
    inline IsTransformFeedback<
      RET_TYPE,
      ID_TYPE >* newIsTransformFeedback(
        RET_TYPE const&ret,
        ID_TYPE  const&id ){
        return new IsTransformFeedback<
          RET_TYPE,
          ID_TYPE >(
              ret,
              id );
    }
    template<
      typename RET_TYPE = GLboolean,
      typename ID_TYPE  = GLuint   >
    inline std::shared_ptr<IsTransformFeedback<
      RET_TYPE,
      ID_TYPE >> sharedIsTransformFeedback(
        RET_TYPE const&ret,
        ID_TYPE  const&id ){
        return std::make_shared<IsTransformFeedback<
          RET_TYPE,
          ID_TYPE >>(
              ret,
              id );
    }

    template<
      typename LOCATION_TYPE = GLint,
      typename V0_TYPE       = GLint,
      typename V1_TYPE       = GLint,
      typename V2_TYPE       = GLint,
      typename V3_TYPE       = GLint>
    inline Uniform4i<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >* newUniform4i(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return new Uniform4i<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >(
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }
    template<
      typename LOCATION_TYPE = GLint,
      typename V0_TYPE       = GLint,
      typename V1_TYPE       = GLint,
      typename V2_TYPE       = GLint,
      typename V3_TYPE       = GLint>
    inline std::shared_ptr<Uniform4i<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >> sharedUniform4i(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return std::make_shared<Uniform4i<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >>(
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }

    template<
      typename TEXTURE_TYPE = GLenum>
    inline ActiveTexture<
      TEXTURE_TYPE>* newActiveTexture(
        TEXTURE_TYPE const&texture){
        return new ActiveTexture<
          TEXTURE_TYPE>(
              texture);
    }
    template<
      typename TEXTURE_TYPE = GLenum>
    inline std::shared_ptr<ActiveTexture<
      TEXTURE_TYPE>> sharedActiveTexture(
        TEXTURE_TYPE const&texture){
        return std::make_shared<ActiveTexture<
          TEXTURE_TYPE>>(
              texture);
    }

    template<
      typename INDEX_TYPE = GLuint>
    inline EnableVertexAttribArray<
      INDEX_TYPE>* newEnableVertexAttribArray(
        INDEX_TYPE const&index){
        return new EnableVertexAttribArray<
          INDEX_TYPE>(
              index);
    }
    template<
      typename INDEX_TYPE = GLuint>
    inline std::shared_ptr<EnableVertexAttribArray<
      INDEX_TYPE>> sharedEnableVertexAttribArray(
        INDEX_TYPE const&index){
        return std::make_shared<EnableVertexAttribArray<
          INDEX_TYPE>>(
              index);
    }

    template<
      typename RET_TYPE      = GLboolean,
      typename PIPELINE_TYPE = GLuint   >
    inline IsProgramPipeline<
      RET_TYPE     ,
      PIPELINE_TYPE>* newIsProgramPipeline(
        RET_TYPE      const&ret     ,
        PIPELINE_TYPE const&pipeline){
        return new IsProgramPipeline<
          RET_TYPE     ,
          PIPELINE_TYPE>(
              ret     ,
              pipeline);
    }
    template<
      typename RET_TYPE      = GLboolean,
      typename PIPELINE_TYPE = GLuint   >
    inline std::shared_ptr<IsProgramPipeline<
      RET_TYPE     ,
      PIPELINE_TYPE>> sharedIsProgramPipeline(
        RET_TYPE      const&ret     ,
        PIPELINE_TYPE const&pipeline){
        return std::make_shared<IsProgramPipeline<
          RET_TYPE     ,
          PIPELINE_TYPE>>(
              ret     ,
              pipeline);
    }

    template<
      typename X_TYPE      = GLint  ,
      typename Y_TYPE      = GLint  ,
      typename WIDTH_TYPE  = GLsizei,
      typename HEIGHT_TYPE = GLsizei,
      typename FORMAT_TYPE = GLenum ,
      typename TYPE_TYPE   = GLenum ,
      typename PIXELS_TYPE = void*  >
    inline ReadPixels<
      X_TYPE     ,
      Y_TYPE     ,
      WIDTH_TYPE ,
      HEIGHT_TYPE,
      FORMAT_TYPE,
      TYPE_TYPE  ,
      PIXELS_TYPE>* newReadPixels(
        X_TYPE      const&x     ,
        Y_TYPE      const&y     ,
        WIDTH_TYPE  const&width ,
        HEIGHT_TYPE const&height,
        FORMAT_TYPE const&format,
        TYPE_TYPE   const&type  ,
        PIXELS_TYPE const&pixels){
        return new ReadPixels<
          X_TYPE     ,
          Y_TYPE     ,
          WIDTH_TYPE ,
          HEIGHT_TYPE,
          FORMAT_TYPE,
          TYPE_TYPE  ,
          PIXELS_TYPE>(
              x     ,
              y     ,
              width ,
              height,
              format,
              type  ,
              pixels);
    }
    template<
      typename X_TYPE      = GLint  ,
      typename Y_TYPE      = GLint  ,
      typename WIDTH_TYPE  = GLsizei,
      typename HEIGHT_TYPE = GLsizei,
      typename FORMAT_TYPE = GLenum ,
      typename TYPE_TYPE   = GLenum ,
      typename PIXELS_TYPE = void*  >
    inline std::shared_ptr<ReadPixels<
      X_TYPE     ,
      Y_TYPE     ,
      WIDTH_TYPE ,
      HEIGHT_TYPE,
      FORMAT_TYPE,
      TYPE_TYPE  ,
      PIXELS_TYPE>> sharedReadPixels(
        X_TYPE      const&x     ,
        Y_TYPE      const&y     ,
        WIDTH_TYPE  const&width ,
        HEIGHT_TYPE const&height,
        FORMAT_TYPE const&format,
        TYPE_TYPE   const&type  ,
        PIXELS_TYPE const&pixels){
        return std::make_shared<ReadPixels<
          X_TYPE     ,
          Y_TYPE     ,
          WIDTH_TYPE ,
          HEIGHT_TYPE,
          FORMAT_TYPE,
          TYPE_TYPE  ,
          PIXELS_TYPE>>(
              x     ,
              y     ,
              width ,
              height,
              format,
              type  ,
              pixels);
    }

    template<
      typename LOCATION_TYPE = GLint   ,
      typename X_TYPE        = GLdouble,
      typename Y_TYPE        = GLdouble,
      typename Z_TYPE        = GLdouble,
      typename W_TYPE        = GLdouble>
    inline Uniform4d<
      LOCATION_TYPE,
      X_TYPE       ,
      Y_TYPE       ,
      Z_TYPE       ,
      W_TYPE       >* newUniform4d(
        LOCATION_TYPE const&location,
        X_TYPE        const&x       ,
        Y_TYPE        const&y       ,
        Z_TYPE        const&z       ,
        W_TYPE        const&w       ){
        return new Uniform4d<
          LOCATION_TYPE,
          X_TYPE       ,
          Y_TYPE       ,
          Z_TYPE       ,
          W_TYPE       >(
              location,
              x       ,
              y       ,
              z       ,
              w       );
    }
    template<
      typename LOCATION_TYPE = GLint   ,
      typename X_TYPE        = GLdouble,
      typename Y_TYPE        = GLdouble,
      typename Z_TYPE        = GLdouble,
      typename W_TYPE        = GLdouble>
    inline std::shared_ptr<Uniform4d<
      LOCATION_TYPE,
      X_TYPE       ,
      Y_TYPE       ,
      Z_TYPE       ,
      W_TYPE       >> sharedUniform4d(
        LOCATION_TYPE const&location,
        X_TYPE        const&x       ,
        Y_TYPE        const&y       ,
        Z_TYPE        const&z       ,
        W_TYPE        const&w       ){
        return std::make_shared<Uniform4d<
          LOCATION_TYPE,
          X_TYPE       ,
          Y_TYPE       ,
          Z_TYPE       ,
          W_TYPE       >>(
              location,
              x       ,
              y       ,
              z       ,
              w       );
    }

    template<
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat,
      typename V2_TYPE       = GLfloat,
      typename V3_TYPE       = GLfloat>
    inline Uniform4f<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >* newUniform4f(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return new Uniform4f<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >(
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }
    template<
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat,
      typename V2_TYPE       = GLfloat,
      typename V3_TYPE       = GLfloat>
    inline std::shared_ptr<Uniform4f<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >> sharedUniform4f(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return std::make_shared<Uniform4f<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >>(
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }

    template<
      typename TARGET_TYPE         = GLenum ,
      typename SAMPLES_TYPE        = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    inline RenderbufferStorageMultisample<
      TARGET_TYPE        ,
      SAMPLES_TYPE       ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >* newRenderbufferStorageMultisample(
        TARGET_TYPE         const&target        ,
        SAMPLES_TYPE        const&samples       ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return new RenderbufferStorageMultisample<
          TARGET_TYPE        ,
          SAMPLES_TYPE       ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >(
              target        ,
              samples       ,
              internalformat,
              width         ,
              height        );
    }
    template<
      typename TARGET_TYPE         = GLenum ,
      typename SAMPLES_TYPE        = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    inline std::shared_ptr<RenderbufferStorageMultisample<
      TARGET_TYPE        ,
      SAMPLES_TYPE       ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >> sharedRenderbufferStorageMultisample(
        TARGET_TYPE         const&target        ,
        SAMPLES_TYPE        const&samples       ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return std::make_shared<RenderbufferStorageMultisample<
          TARGET_TYPE        ,
          SAMPLES_TYPE       ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >>(
              target        ,
              samples       ,
              internalformat,
              width         ,
              height        );
    }

    template<
      typename N_TYPE         = GLsizei,
      typename PIPELINES_TYPE = GLuint*>
    inline CreateProgramPipelines<
      N_TYPE        ,
      PIPELINES_TYPE>* newCreateProgramPipelines(
        N_TYPE         const&n        ,
        PIPELINES_TYPE const&pipelines){
        return new CreateProgramPipelines<
          N_TYPE        ,
          PIPELINES_TYPE>(
              n        ,
              pipelines);
    }
    template<
      typename N_TYPE         = GLsizei,
      typename PIPELINES_TYPE = GLuint*>
    inline std::shared_ptr<CreateProgramPipelines<
      N_TYPE        ,
      PIPELINES_TYPE>> sharedCreateProgramPipelines(
        N_TYPE         const&n        ,
        PIPELINES_TYPE const&pipelines){
        return std::make_shared<CreateProgramPipelines<
          N_TYPE        ,
          PIPELINES_TYPE>>(
              n        ,
              pipelines);
    }

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline UniformMatrix3fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix3fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix3fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<UniformMatrix3fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix3fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix3fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename INDEX_TYPE   = GLuint     ,
      typename SIZE_TYPE    = GLint      ,
      typename TYPE_TYPE    = GLenum     ,
      typename STRIDE_TYPE  = GLsizei    ,
      typename POINTER_TYPE = const void*>
    inline VertexAttribLPointer<
      INDEX_TYPE  ,
      SIZE_TYPE   ,
      TYPE_TYPE   ,
      STRIDE_TYPE ,
      POINTER_TYPE>* newVertexAttribLPointer(
        INDEX_TYPE   const&index  ,
        SIZE_TYPE    const&size   ,
        TYPE_TYPE    const&type   ,
        STRIDE_TYPE  const&stride ,
        POINTER_TYPE const&pointer){
        return new VertexAttribLPointer<
          INDEX_TYPE  ,
          SIZE_TYPE   ,
          TYPE_TYPE   ,
          STRIDE_TYPE ,
          POINTER_TYPE>(
              index  ,
              size   ,
              type   ,
              stride ,
              pointer);
    }
    template<
      typename INDEX_TYPE   = GLuint     ,
      typename SIZE_TYPE    = GLint      ,
      typename TYPE_TYPE    = GLenum     ,
      typename STRIDE_TYPE  = GLsizei    ,
      typename POINTER_TYPE = const void*>
    inline std::shared_ptr<VertexAttribLPointer<
      INDEX_TYPE  ,
      SIZE_TYPE   ,
      TYPE_TYPE   ,
      STRIDE_TYPE ,
      POINTER_TYPE>> sharedVertexAttribLPointer(
        INDEX_TYPE   const&index  ,
        SIZE_TYPE    const&size   ,
        TYPE_TYPE    const&type   ,
        STRIDE_TYPE  const&stride ,
        POINTER_TYPE const&pointer){
        return std::make_shared<VertexAttribLPointer<
          INDEX_TYPE  ,
          SIZE_TYPE   ,
          TYPE_TYPE   ,
          STRIDE_TYPE ,
          POINTER_TYPE>>(
              index  ,
              size   ,
              type   ,
              stride ,
              pointer);
    }

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename BUFSIZE_TYPE  = GLsizei ,
      typename PARAMS_TYPE   = GLfloat*>
    inline GetnUniformfv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      BUFSIZE_TYPE ,
      PARAMS_TYPE  >* newGetnUniformfv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        BUFSIZE_TYPE  const&bufSize ,
        PARAMS_TYPE   const&params  ){
        return new GetnUniformfv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          BUFSIZE_TYPE ,
          PARAMS_TYPE  >(
              program ,
              location,
              bufSize ,
              params  );
    }
    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename BUFSIZE_TYPE  = GLsizei ,
      typename PARAMS_TYPE   = GLfloat*>
    inline std::shared_ptr<GetnUniformfv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      BUFSIZE_TYPE ,
      PARAMS_TYPE  >> sharedGetnUniformfv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        BUFSIZE_TYPE  const&bufSize ,
        PARAMS_TYPE   const&params  ){
        return std::make_shared<GetnUniformfv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          BUFSIZE_TYPE ,
          PARAMS_TYPE  >>(
              program ,
              location,
              bufSize ,
              params  );
    }

    template<
      typename MODE_TYPE          = GLenum     ,
      typename COUNT_TYPE         = GLsizei    ,
      typename TYPE_TYPE          = GLenum     ,
      typename INDICES_TYPE       = const void*,
      typename INSTANCECOUNT_TYPE = GLsizei    ,
      typename BASEVERTEX_TYPE    = GLint      >
    inline DrawElementsInstancedBaseVertex<
      MODE_TYPE         ,
      COUNT_TYPE        ,
      TYPE_TYPE         ,
      INDICES_TYPE      ,
      INSTANCECOUNT_TYPE,
      BASEVERTEX_TYPE   >* newDrawElementsInstancedBaseVertex(
        MODE_TYPE          const&mode         ,
        COUNT_TYPE         const&count        ,
        TYPE_TYPE          const&type         ,
        INDICES_TYPE       const&indices      ,
        INSTANCECOUNT_TYPE const&instancecount,
        BASEVERTEX_TYPE    const&basevertex   ){
        return new DrawElementsInstancedBaseVertex<
          MODE_TYPE         ,
          COUNT_TYPE        ,
          TYPE_TYPE         ,
          INDICES_TYPE      ,
          INSTANCECOUNT_TYPE,
          BASEVERTEX_TYPE   >(
              mode         ,
              count        ,
              type         ,
              indices      ,
              instancecount,
              basevertex   );
    }
    template<
      typename MODE_TYPE          = GLenum     ,
      typename COUNT_TYPE         = GLsizei    ,
      typename TYPE_TYPE          = GLenum     ,
      typename INDICES_TYPE       = const void*,
      typename INSTANCECOUNT_TYPE = GLsizei    ,
      typename BASEVERTEX_TYPE    = GLint      >
    inline std::shared_ptr<DrawElementsInstancedBaseVertex<
      MODE_TYPE         ,
      COUNT_TYPE        ,
      TYPE_TYPE         ,
      INDICES_TYPE      ,
      INSTANCECOUNT_TYPE,
      BASEVERTEX_TYPE   >> sharedDrawElementsInstancedBaseVertex(
        MODE_TYPE          const&mode         ,
        COUNT_TYPE         const&count        ,
        TYPE_TYPE          const&type         ,
        INDICES_TYPE       const&indices      ,
        INSTANCECOUNT_TYPE const&instancecount,
        BASEVERTEX_TYPE    const&basevertex   ){
        return std::make_shared<DrawElementsInstancedBaseVertex<
          MODE_TYPE         ,
          COUNT_TYPE        ,
          TYPE_TYPE         ,
          INDICES_TYPE      ,
          INSTANCECOUNT_TYPE,
          BASEVERTEX_TYPE   >>(
              mode         ,
              count        ,
              type         ,
              indices      ,
              instancecount,
              basevertex   );
    }

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline VertexAttribL2dv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribL2dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribL2dv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline std::shared_ptr<VertexAttribL2dv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribL2dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribL2dv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename MODE_TYPE          = GLenum ,
      typename ID_TYPE            = GLuint ,
      typename STREAM_TYPE        = GLuint ,
      typename INSTANCECOUNT_TYPE = GLsizei>
    inline DrawTransformFeedbackStreamInstanced<
      MODE_TYPE         ,
      ID_TYPE           ,
      STREAM_TYPE       ,
      INSTANCECOUNT_TYPE>* newDrawTransformFeedbackStreamInstanced(
        MODE_TYPE          const&mode         ,
        ID_TYPE            const&id           ,
        STREAM_TYPE        const&stream       ,
        INSTANCECOUNT_TYPE const&instancecount){
        return new DrawTransformFeedbackStreamInstanced<
          MODE_TYPE         ,
          ID_TYPE           ,
          STREAM_TYPE       ,
          INSTANCECOUNT_TYPE>(
              mode         ,
              id           ,
              stream       ,
              instancecount);
    }
    template<
      typename MODE_TYPE          = GLenum ,
      typename ID_TYPE            = GLuint ,
      typename STREAM_TYPE        = GLuint ,
      typename INSTANCECOUNT_TYPE = GLsizei>
    inline std::shared_ptr<DrawTransformFeedbackStreamInstanced<
      MODE_TYPE         ,
      ID_TYPE           ,
      STREAM_TYPE       ,
      INSTANCECOUNT_TYPE>> sharedDrawTransformFeedbackStreamInstanced(
        MODE_TYPE          const&mode         ,
        ID_TYPE            const&id           ,
        STREAM_TYPE        const&stream       ,
        INSTANCECOUNT_TYPE const&instancecount){
        return std::make_shared<DrawTransformFeedbackStreamInstanced<
          MODE_TYPE         ,
          ID_TYPE           ,
          STREAM_TYPE       ,
          INSTANCECOUNT_TYPE>>(
              mode         ,
              id           ,
              stream       ,
              instancecount);
    }

    template<
      typename PROGRAM_TYPE    = GLuint  ,
      typename SHADERTYPE_TYPE = GLenum  ,
      typename INDEX_TYPE      = GLuint  ,
      typename BUFSIZE_TYPE    = GLsizei ,
      typename LENGTH_TYPE     = GLsizei*,
      typename NAME_TYPE       = GLchar* >
    inline GetActiveSubroutineName<
      PROGRAM_TYPE   ,
      SHADERTYPE_TYPE,
      INDEX_TYPE     ,
      BUFSIZE_TYPE   ,
      LENGTH_TYPE    ,
      NAME_TYPE      >* newGetActiveSubroutineName(
        PROGRAM_TYPE    const&program   ,
        SHADERTYPE_TYPE const&shadertype,
        INDEX_TYPE      const&index     ,
        BUFSIZE_TYPE    const&bufsize   ,
        LENGTH_TYPE     const&length    ,
        NAME_TYPE       const&name      ){
        return new GetActiveSubroutineName<
          PROGRAM_TYPE   ,
          SHADERTYPE_TYPE,
          INDEX_TYPE     ,
          BUFSIZE_TYPE   ,
          LENGTH_TYPE    ,
          NAME_TYPE      >(
              program   ,
              shadertype,
              index     ,
              bufsize   ,
              length    ,
              name      );
    }
    template<
      typename PROGRAM_TYPE    = GLuint  ,
      typename SHADERTYPE_TYPE = GLenum  ,
      typename INDEX_TYPE      = GLuint  ,
      typename BUFSIZE_TYPE    = GLsizei ,
      typename LENGTH_TYPE     = GLsizei*,
      typename NAME_TYPE       = GLchar* >
    inline std::shared_ptr<GetActiveSubroutineName<
      PROGRAM_TYPE   ,
      SHADERTYPE_TYPE,
      INDEX_TYPE     ,
      BUFSIZE_TYPE   ,
      LENGTH_TYPE    ,
      NAME_TYPE      >> sharedGetActiveSubroutineName(
        PROGRAM_TYPE    const&program   ,
        SHADERTYPE_TYPE const&shadertype,
        INDEX_TYPE      const&index     ,
        BUFSIZE_TYPE    const&bufsize   ,
        LENGTH_TYPE     const&length    ,
        NAME_TYPE       const&name      ){
        return std::make_shared<GetActiveSubroutineName<
          PROGRAM_TYPE   ,
          SHADERTYPE_TYPE,
          INDEX_TYPE     ,
          BUFSIZE_TYPE   ,
          LENGTH_TYPE    ,
          NAME_TYPE      >>(
              program   ,
              shadertype,
              index     ,
              bufsize   ,
              length    ,
              name      );
    }

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble>
    inline VertexAttribL2d<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    >* newVertexAttribL2d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ){
        return new VertexAttribL2d<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    >(
              index,
              x    ,
              y    );
    }
    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble>
    inline std::shared_ptr<VertexAttribL2d<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    >> sharedVertexAttribL2d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ){
        return std::make_shared<VertexAttribL2d<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    >>(
              index,
              x    ,
              y    );
    }

    template<
      typename FUNC_TYPE = GLenum,
      typename REF_TYPE  = GLint ,
      typename MASK_TYPE = GLuint>
    inline StencilFunc<
      FUNC_TYPE,
      REF_TYPE ,
      MASK_TYPE>* newStencilFunc(
        FUNC_TYPE const&func,
        REF_TYPE  const&ref ,
        MASK_TYPE const&mask){
        return new StencilFunc<
          FUNC_TYPE,
          REF_TYPE ,
          MASK_TYPE>(
              func,
              ref ,
              mask);
    }
    template<
      typename FUNC_TYPE = GLenum,
      typename REF_TYPE  = GLint ,
      typename MASK_TYPE = GLuint>
    inline std::shared_ptr<StencilFunc<
      FUNC_TYPE,
      REF_TYPE ,
      MASK_TYPE>> sharedStencilFunc(
        FUNC_TYPE const&func,
        REF_TYPE  const&ref ,
        MASK_TYPE const&mask){
        return std::make_shared<StencilFunc<
          FUNC_TYPE,
          REF_TYPE ,
          MASK_TYPE>>(
              func,
              ref ,
              mask);
    }

    template<
      typename FRAMEBUFFER_TYPE    = GLuint       ,
      typename NUMATTACHMENTS_TYPE = GLsizei      ,
      typename ATTACHMENTS_TYPE    = const GLenum*>
    inline InvalidateNamedFramebufferData<
      FRAMEBUFFER_TYPE   ,
      NUMATTACHMENTS_TYPE,
      ATTACHMENTS_TYPE   >* newInvalidateNamedFramebufferData(
        FRAMEBUFFER_TYPE    const&framebuffer   ,
        NUMATTACHMENTS_TYPE const&numAttachments,
        ATTACHMENTS_TYPE    const&attachments   ){
        return new InvalidateNamedFramebufferData<
          FRAMEBUFFER_TYPE   ,
          NUMATTACHMENTS_TYPE,
          ATTACHMENTS_TYPE   >(
              framebuffer   ,
              numAttachments,
              attachments   );
    }
    template<
      typename FRAMEBUFFER_TYPE    = GLuint       ,
      typename NUMATTACHMENTS_TYPE = GLsizei      ,
      typename ATTACHMENTS_TYPE    = const GLenum*>
    inline std::shared_ptr<InvalidateNamedFramebufferData<
      FRAMEBUFFER_TYPE   ,
      NUMATTACHMENTS_TYPE,
      ATTACHMENTS_TYPE   >> sharedInvalidateNamedFramebufferData(
        FRAMEBUFFER_TYPE    const&framebuffer   ,
        NUMATTACHMENTS_TYPE const&numAttachments,
        ATTACHMENTS_TYPE    const&attachments   ){
        return std::make_shared<InvalidateNamedFramebufferData<
          FRAMEBUFFER_TYPE   ,
          NUMATTACHMENTS_TYPE,
          ATTACHMENTS_TYPE   >>(
              framebuffer   ,
              numAttachments,
              attachments   );
    }


    template<
      typename PROGRAM_TYPE             = GLuint,
      typename UNIFORMBLOCKINDEX_TYPE   = GLuint,
      typename UNIFORMBLOCKBINDING_TYPE = GLuint>
    inline UniformBlockBinding<
      PROGRAM_TYPE            ,
      UNIFORMBLOCKINDEX_TYPE  ,
      UNIFORMBLOCKBINDING_TYPE>* newUniformBlockBinding(
        PROGRAM_TYPE             const&program            ,
        UNIFORMBLOCKINDEX_TYPE   const&uniformBlockIndex  ,
        UNIFORMBLOCKBINDING_TYPE const&uniformBlockBinding){
        return new UniformBlockBinding<
          PROGRAM_TYPE            ,
          UNIFORMBLOCKINDEX_TYPE  ,
          UNIFORMBLOCKBINDING_TYPE>(
              program            ,
              uniformBlockIndex  ,
              uniformBlockBinding);
    }
    template<
      typename PROGRAM_TYPE             = GLuint,
      typename UNIFORMBLOCKINDEX_TYPE   = GLuint,
      typename UNIFORMBLOCKBINDING_TYPE = GLuint>
    inline std::shared_ptr<UniformBlockBinding<
      PROGRAM_TYPE            ,
      UNIFORMBLOCKINDEX_TYPE  ,
      UNIFORMBLOCKBINDING_TYPE>> sharedUniformBlockBinding(
        PROGRAM_TYPE             const&program            ,
        UNIFORMBLOCKINDEX_TYPE   const&uniformBlockIndex  ,
        UNIFORMBLOCKBINDING_TYPE const&uniformBlockBinding){
        return std::make_shared<UniformBlockBinding<
          PROGRAM_TYPE            ,
          UNIFORMBLOCKINDEX_TYPE  ,
          UNIFORMBLOCKBINDING_TYPE>>(
              program            ,
              uniformBlockIndex  ,
              uniformBlockBinding);
    }

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLint ,
      typename V1_TYPE       = GLint ,
      typename V2_TYPE       = GLint >
    inline ProgramUniform3i<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >* newProgramUniform3i(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return new ProgramUniform3i<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >(
              program ,
              location,
              v0      ,
              v1      ,
              v2      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLint ,
      typename V1_TYPE       = GLint ,
      typename V2_TYPE       = GLint >
    inline std::shared_ptr<ProgramUniform3i<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >> sharedProgramUniform3i(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return std::make_shared<ProgramUniform3i<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >>(
              program ,
              location,
              v0      ,
              v1      ,
              v2      );
    }

    template<
      typename PIPELINE_TYPE = GLuint    ,
      typename STAGES_TYPE   = GLbitfield,
      typename PROGRAM_TYPE  = GLuint    >
    inline UseProgramStages<
      PIPELINE_TYPE,
      STAGES_TYPE  ,
      PROGRAM_TYPE >* newUseProgramStages(
        PIPELINE_TYPE const&pipeline,
        STAGES_TYPE   const&stages  ,
        PROGRAM_TYPE  const&program ){
        return new UseProgramStages<
          PIPELINE_TYPE,
          STAGES_TYPE  ,
          PROGRAM_TYPE >(
              pipeline,
              stages  ,
              program );
    }
    template<
      typename PIPELINE_TYPE = GLuint    ,
      typename STAGES_TYPE   = GLbitfield,
      typename PROGRAM_TYPE  = GLuint    >
    inline std::shared_ptr<UseProgramStages<
      PIPELINE_TYPE,
      STAGES_TYPE  ,
      PROGRAM_TYPE >> sharedUseProgramStages(
        PIPELINE_TYPE const&pipeline,
        STAGES_TYPE   const&stages  ,
        PROGRAM_TYPE  const&program ){
        return std::make_shared<UseProgramStages<
          PIPELINE_TYPE,
          STAGES_TYPE  ,
          PROGRAM_TYPE >>(
              pipeline,
              stages  ,
              program );
    }

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline ProgramUniformMatrix3x2fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix3x2fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix3x2fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<ProgramUniformMatrix3x2fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix3x2fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix3x2fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename V0_TYPE       = GLdouble,
      typename V1_TYPE       = GLdouble,
      typename V2_TYPE       = GLdouble>
    inline ProgramUniform3d<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >* newProgramUniform3d(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return new ProgramUniform3d<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >(
              program ,
              location,
              v0      ,
              v1      ,
              v2      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename V0_TYPE       = GLdouble,
      typename V1_TYPE       = GLdouble,
      typename V2_TYPE       = GLdouble>
    inline std::shared_ptr<ProgramUniform3d<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >> sharedProgramUniform3d(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return std::make_shared<ProgramUniform3d<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >>(
              program ,
              location,
              v0      ,
              v1      ,
              v2      );
    }

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline VertexAttribI4iv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribI4iv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribI4iv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline std::shared_ptr<VertexAttribI4iv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribI4iv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribI4iv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename PIPELINE_TYPE = GLuint,
      typename PNAME_TYPE    = GLenum,
      typename PARAMS_TYPE   = GLint*>
    inline GetProgramPipelineiv<
      PIPELINE_TYPE,
      PNAME_TYPE   ,
      PARAMS_TYPE  >* newGetProgramPipelineiv(
        PIPELINE_TYPE const&pipeline,
        PNAME_TYPE    const&pname   ,
        PARAMS_TYPE   const&params  ){
        return new GetProgramPipelineiv<
          PIPELINE_TYPE,
          PNAME_TYPE   ,
          PARAMS_TYPE  >(
              pipeline,
              pname   ,
              params  );
    }
    template<
      typename PIPELINE_TYPE = GLuint,
      typename PNAME_TYPE    = GLenum,
      typename PARAMS_TYPE   = GLint*>
    inline std::shared_ptr<GetProgramPipelineiv<
      PIPELINE_TYPE,
      PNAME_TYPE   ,
      PARAMS_TYPE  >> sharedGetProgramPipelineiv(
        PIPELINE_TYPE const&pipeline,
        PNAME_TYPE    const&pname   ,
        PARAMS_TYPE   const&params  ){
        return std::make_shared<GetProgramPipelineiv<
          PIPELINE_TYPE,
          PNAME_TYPE   ,
          PARAMS_TYPE  >>(
              pipeline,
              pname   ,
              params  );
    }

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble,
      typename Z_TYPE     = GLdouble,
      typename W_TYPE     = GLdouble>
    inline VertexAttribL4d<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >* newVertexAttribL4d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return new VertexAttribL4d<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }
    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble,
      typename Z_TYPE     = GLdouble,
      typename W_TYPE     = GLdouble>
    inline std::shared_ptr<VertexAttribL4d<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >> sharedVertexAttribL4d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return std::make_shared<VertexAttribL4d<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >>(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename BUF_TYPE         = GLenum>
    inline NamedFramebufferDrawBuffer<
      FRAMEBUFFER_TYPE,
      BUF_TYPE        >* newNamedFramebufferDrawBuffer(
        FRAMEBUFFER_TYPE const&framebuffer,
        BUF_TYPE         const&buf        ){
        return new NamedFramebufferDrawBuffer<
          FRAMEBUFFER_TYPE,
          BUF_TYPE        >(
              framebuffer,
              buf        );
    }
    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename BUF_TYPE         = GLenum>
    inline std::shared_ptr<NamedFramebufferDrawBuffer<
      FRAMEBUFFER_TYPE,
      BUF_TYPE        >> sharedNamedFramebufferDrawBuffer(
        FRAMEBUFFER_TYPE const&framebuffer,
        BUF_TYPE         const&buf        ){
        return std::make_shared<NamedFramebufferDrawBuffer<
          FRAMEBUFFER_TYPE,
          BUF_TYPE        >>(
              framebuffer,
              buf        );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetQueryIndexediv<
      TARGET_TYPE,
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetQueryIndexediv(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetQueryIndexediv<
          TARGET_TYPE,
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              index ,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetQueryIndexediv<
      TARGET_TYPE,
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetQueryIndexediv(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetQueryIndexediv<
          TARGET_TYPE,
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              index ,
              pname ,
              params);
    }

    template<
      typename SHADER_TYPE  = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename INFOLOG_TYPE = GLchar* >
    inline GetShaderInfoLog<
      SHADER_TYPE ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      INFOLOG_TYPE>* newGetShaderInfoLog(
        SHADER_TYPE  const&shader ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        INFOLOG_TYPE const&infoLog){
        return new GetShaderInfoLog<
          SHADER_TYPE ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          INFOLOG_TYPE>(
              shader ,
              bufSize,
              length ,
              infoLog);
    }
    template<
      typename SHADER_TYPE  = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename INFOLOG_TYPE = GLchar* >
    inline std::shared_ptr<GetShaderInfoLog<
      SHADER_TYPE ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      INFOLOG_TYPE>> sharedGetShaderInfoLog(
        SHADER_TYPE  const&shader ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        INFOLOG_TYPE const&infoLog){
        return std::make_shared<GetShaderInfoLog<
          SHADER_TYPE ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          INFOLOG_TYPE>>(
              shader ,
              bufSize,
              length ,
              infoLog);
    }

    template<
      typename IDENTIFIER_TYPE = GLenum       ,
      typename NAME_TYPE       = GLuint       ,
      typename LENGTH_TYPE     = GLsizei      ,
      typename LABEL_TYPE      = const GLchar*>
    inline ObjectLabel<
      IDENTIFIER_TYPE,
      NAME_TYPE      ,
      LENGTH_TYPE    ,
      LABEL_TYPE     >* newObjectLabel(
        IDENTIFIER_TYPE const&identifier,
        NAME_TYPE       const&name      ,
        LENGTH_TYPE     const&length    ,
        LABEL_TYPE      const&label     ){
        return new ObjectLabel<
          IDENTIFIER_TYPE,
          NAME_TYPE      ,
          LENGTH_TYPE    ,
          LABEL_TYPE     >(
              identifier,
              name      ,
              length    ,
              label     );
    }
    template<
      typename IDENTIFIER_TYPE = GLenum       ,
      typename NAME_TYPE       = GLuint       ,
      typename LENGTH_TYPE     = GLsizei      ,
      typename LABEL_TYPE      = const GLchar*>
    inline std::shared_ptr<ObjectLabel<
      IDENTIFIER_TYPE,
      NAME_TYPE      ,
      LENGTH_TYPE    ,
      LABEL_TYPE     >> sharedObjectLabel(
        IDENTIFIER_TYPE const&identifier,
        NAME_TYPE       const&name      ,
        LENGTH_TYPE     const&length    ,
        LABEL_TYPE      const&label     ){
        return std::make_shared<ObjectLabel<
          IDENTIFIER_TYPE,
          NAME_TYPE      ,
          LENGTH_TYPE    ,
          LABEL_TYPE     >>(
              identifier,
              name      ,
              length    ,
              label     );
    }

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLint ,
      typename Y_TYPE     = GLint ,
      typename Z_TYPE     = GLint ,
      typename W_TYPE     = GLint >
    inline VertexAttribI4i<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >* newVertexAttribI4i(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return new VertexAttribI4i<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }
    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLint ,
      typename Y_TYPE     = GLint ,
      typename Z_TYPE     = GLint ,
      typename W_TYPE     = GLint >
    inline std::shared_ptr<VertexAttribI4i<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >> sharedVertexAttribI4i(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return std::make_shared<VertexAttribI4i<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >>(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }

    template<
      typename TARGET_TYPE = GLenum    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr,
      typename DATA_TYPE   = void*     >
    inline GetBufferSubData<
      TARGET_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  >* newGetBufferSubData(
        TARGET_TYPE const&target,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ){
        return new GetBufferSubData<
          TARGET_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  >(
              target,
              offset,
              size  ,
              data  );
    }
    template<
      typename TARGET_TYPE = GLenum    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr,
      typename DATA_TYPE   = void*     >
    inline std::shared_ptr<GetBufferSubData<
      TARGET_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  >> sharedGetBufferSubData(
        TARGET_TYPE const&target,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ){
        return std::make_shared<GetBufferSubData<
          TARGET_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  >>(
              target,
              offset,
              size  ,
              data  );
    }

    template<
      typename INDEX_TYPE  = GLuint   ,
      typename PNAME_TYPE  = GLenum   ,
      typename PARAMS_TYPE = GLdouble*>
    inline GetVertexAttribLdv<
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetVertexAttribLdv(
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetVertexAttribLdv<
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              index ,
              pname ,
              params);
    }
    template<
      typename INDEX_TYPE  = GLuint   ,
      typename PNAME_TYPE  = GLenum   ,
      typename PARAMS_TYPE = GLdouble*>
    inline std::shared_ptr<GetVertexAttribLdv<
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetVertexAttribLdv(
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetVertexAttribLdv<
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              index ,
              pname ,
              params);
    }

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename BUFSIZE_TYPE  = GLsizei,
      typename PARAMS_TYPE   = GLuint*>
    inline GetnUniformuiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      BUFSIZE_TYPE ,
      PARAMS_TYPE  >* newGetnUniformuiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        BUFSIZE_TYPE  const&bufSize ,
        PARAMS_TYPE   const&params  ){
        return new GetnUniformuiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          BUFSIZE_TYPE ,
          PARAMS_TYPE  >(
              program ,
              location,
              bufSize ,
              params  );
    }
    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename BUFSIZE_TYPE  = GLsizei,
      typename PARAMS_TYPE   = GLuint*>
    inline std::shared_ptr<GetnUniformuiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      BUFSIZE_TYPE ,
      PARAMS_TYPE  >> sharedGetnUniformuiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        BUFSIZE_TYPE  const&bufSize ,
        PARAMS_TYPE   const&params  ){
        return std::make_shared<GetnUniformuiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          BUFSIZE_TYPE ,
          PARAMS_TYPE  >>(
              program ,
              location,
              bufSize ,
              params  );
    }

    template<
      typename MODERGB_TYPE   = GLenum,
      typename MODEALPHA_TYPE = GLenum>
    inline BlendEquationSeparate<
      MODERGB_TYPE  ,
      MODEALPHA_TYPE>* newBlendEquationSeparate(
        MODERGB_TYPE   const&modeRGB  ,
        MODEALPHA_TYPE const&modeAlpha){
        return new BlendEquationSeparate<
          MODERGB_TYPE  ,
          MODEALPHA_TYPE>(
              modeRGB  ,
              modeAlpha);
    }
    template<
      typename MODERGB_TYPE   = GLenum,
      typename MODEALPHA_TYPE = GLenum>
    inline std::shared_ptr<BlendEquationSeparate<
      MODERGB_TYPE  ,
      MODEALPHA_TYPE>> sharedBlendEquationSeparate(
        MODERGB_TYPE   const&modeRGB  ,
        MODEALPHA_TYPE const&modeAlpha){
        return std::make_shared<BlendEquationSeparate<
          MODERGB_TYPE  ,
          MODEALPHA_TYPE>>(
              modeRGB  ,
              modeAlpha);
    }

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLuint>
    inline VertexAttribI1ui<
      INDEX_TYPE,
      X_TYPE    >* newVertexAttribI1ui(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ){
        return new VertexAttribI1ui<
          INDEX_TYPE,
          X_TYPE    >(
              index,
              x    );
    }
    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLuint>
    inline std::shared_ptr<VertexAttribI1ui<
      INDEX_TYPE,
      X_TYPE    >> sharedVertexAttribI1ui(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ){
        return std::make_shared<VertexAttribI1ui<
          INDEX_TYPE,
          X_TYPE    >>(
              index,
              x    );
    }

    template<
      typename N_TYPE       = GLsizei,
      typename BUFFERS_TYPE = GLuint*>
    inline GenBuffers<
      N_TYPE      ,
      BUFFERS_TYPE>* newGenBuffers(
        N_TYPE       const&n      ,
        BUFFERS_TYPE const&buffers){
        return new GenBuffers<
          N_TYPE      ,
          BUFFERS_TYPE>(
              n      ,
              buffers);
    }
    template<
      typename N_TYPE       = GLsizei,
      typename BUFFERS_TYPE = GLuint*>
    inline std::shared_ptr<GenBuffers<
      N_TYPE      ,
      BUFFERS_TYPE>> sharedGenBuffers(
        N_TYPE       const&n      ,
        BUFFERS_TYPE const&buffers){
        return std::make_shared<GenBuffers<
          N_TYPE      ,
          BUFFERS_TYPE>>(
              n      ,
              buffers);
    }

    template<
      typename RET_TYPE        = GLuint       ,
      typename PROGRAM_TYPE    = GLuint       ,
      typename SHADERTYPE_TYPE = GLenum       ,
      typename NAME_TYPE       = const GLchar*>
    inline GetSubroutineIndex<
      RET_TYPE       ,
      PROGRAM_TYPE   ,
      SHADERTYPE_TYPE,
      NAME_TYPE      >* newGetSubroutineIndex(
        RET_TYPE        const&ret       ,
        PROGRAM_TYPE    const&program   ,
        SHADERTYPE_TYPE const&shadertype,
        NAME_TYPE       const&name      ){
        return new GetSubroutineIndex<
          RET_TYPE       ,
          PROGRAM_TYPE   ,
          SHADERTYPE_TYPE,
          NAME_TYPE      >(
              ret       ,
              program   ,
              shadertype,
              name      );
    }
    template<
      typename RET_TYPE        = GLuint       ,
      typename PROGRAM_TYPE    = GLuint       ,
      typename SHADERTYPE_TYPE = GLenum       ,
      typename NAME_TYPE       = const GLchar*>
    inline std::shared_ptr<GetSubroutineIndex<
      RET_TYPE       ,
      PROGRAM_TYPE   ,
      SHADERTYPE_TYPE,
      NAME_TYPE      >> sharedGetSubroutineIndex(
        RET_TYPE        const&ret       ,
        PROGRAM_TYPE    const&program   ,
        SHADERTYPE_TYPE const&shadertype,
        NAME_TYPE       const&name      ){
        return std::make_shared<GetSubroutineIndex<
          RET_TYPE       ,
          PROGRAM_TYPE   ,
          SHADERTYPE_TYPE,
          NAME_TYPE      >>(
              ret       ,
              program   ,
              shadertype,
              name      );
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    inline VertexAttrib2sv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib2sv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib2sv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLshort*>
    inline std::shared_ptr<VertexAttrib2sv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib2sv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib2sv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename SFACTOR_TYPE = GLenum,
      typename DFACTOR_TYPE = GLenum>
    inline BlendFunc<
      SFACTOR_TYPE,
      DFACTOR_TYPE>* newBlendFunc(
        SFACTOR_TYPE const&sfactor,
        DFACTOR_TYPE const&dfactor){
        return new BlendFunc<
          SFACTOR_TYPE,
          DFACTOR_TYPE>(
              sfactor,
              dfactor);
    }
    template<
      typename SFACTOR_TYPE = GLenum,
      typename DFACTOR_TYPE = GLenum>
    inline std::shared_ptr<BlendFunc<
      SFACTOR_TYPE,
      DFACTOR_TYPE>> sharedBlendFunc(
        SFACTOR_TYPE const&sfactor,
        DFACTOR_TYPE const&dfactor){
        return std::make_shared<BlendFunc<
          SFACTOR_TYPE,
          DFACTOR_TYPE>>(
              sfactor,
              dfactor);
    }

    template<
      typename FRAMEBUFFER_TYPE = GLuint      ,
      typename BUFFER_TYPE      = GLenum      ,
      typename DRAWBUFFER_TYPE  = GLint       ,
      typename VALUE_TYPE       = const GLint*>
    inline ClearNamedFramebufferiv<
      FRAMEBUFFER_TYPE,
      BUFFER_TYPE     ,
      DRAWBUFFER_TYPE ,
      VALUE_TYPE      >* newClearNamedFramebufferiv(
        FRAMEBUFFER_TYPE const&framebuffer,
        BUFFER_TYPE      const&buffer     ,
        DRAWBUFFER_TYPE  const&drawbuffer ,
        VALUE_TYPE       const&value      ){
        return new ClearNamedFramebufferiv<
          FRAMEBUFFER_TYPE,
          BUFFER_TYPE     ,
          DRAWBUFFER_TYPE ,
          VALUE_TYPE      >(
              framebuffer,
              buffer     ,
              drawbuffer ,
              value      );
    }
    template<
      typename FRAMEBUFFER_TYPE = GLuint      ,
      typename BUFFER_TYPE      = GLenum      ,
      typename DRAWBUFFER_TYPE  = GLint       ,
      typename VALUE_TYPE       = const GLint*>
    inline std::shared_ptr<ClearNamedFramebufferiv<
      FRAMEBUFFER_TYPE,
      BUFFER_TYPE     ,
      DRAWBUFFER_TYPE ,
      VALUE_TYPE      >> sharedClearNamedFramebufferiv(
        FRAMEBUFFER_TYPE const&framebuffer,
        BUFFER_TYPE      const&buffer     ,
        DRAWBUFFER_TYPE  const&drawbuffer ,
        VALUE_TYPE       const&value      ){
        return std::make_shared<ClearNamedFramebufferiv<
          FRAMEBUFFER_TYPE,
          BUFFER_TYPE     ,
          DRAWBUFFER_TYPE ,
          VALUE_TYPE      >>(
              framebuffer,
              buffer     ,
              drawbuffer ,
              value      );
    }

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLint      ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename HEIGHT_TYPE         = GLsizei    ,
      typename DEPTH_TYPE          = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename PIXELS_TYPE         = const void*>
    inline TexImage3D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      DEPTH_TYPE         ,
      BORDER_TYPE        ,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      PIXELS_TYPE        >* newTexImage3D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        DEPTH_TYPE          const&depth         ,
        BORDER_TYPE         const&border        ,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        PIXELS_TYPE         const&pixels        ){
        return new TexImage3D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          DEPTH_TYPE         ,
          BORDER_TYPE        ,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          PIXELS_TYPE        >(
              target        ,
              level         ,
              internalformat,
              width         ,
              height        ,
              depth         ,
              border        ,
              format        ,
              type          ,
              pixels        );
    }
    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLint      ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename HEIGHT_TYPE         = GLsizei    ,
      typename DEPTH_TYPE          = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename PIXELS_TYPE         = const void*>
    inline std::shared_ptr<TexImage3D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      DEPTH_TYPE         ,
      BORDER_TYPE        ,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      PIXELS_TYPE        >> sharedTexImage3D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        DEPTH_TYPE          const&depth         ,
        BORDER_TYPE         const&border        ,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        PIXELS_TYPE         const&pixels        ){
        return std::make_shared<TexImage3D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          DEPTH_TYPE         ,
          BORDER_TYPE        ,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          PIXELS_TYPE        >>(
              target        ,
              level         ,
              internalformat,
              width         ,
              height        ,
              depth         ,
              border        ,
              format        ,
              type          ,
              pixels        );
    }

    template<
      typename RET_TYPE         = GLboolean,
      typename FRAMEBUFFER_TYPE = GLuint   >
    inline IsFramebuffer<
      RET_TYPE        ,
      FRAMEBUFFER_TYPE>* newIsFramebuffer(
        RET_TYPE         const&ret        ,
        FRAMEBUFFER_TYPE const&framebuffer){
        return new IsFramebuffer<
          RET_TYPE        ,
          FRAMEBUFFER_TYPE>(
              ret        ,
              framebuffer);
    }
    template<
      typename RET_TYPE         = GLboolean,
      typename FRAMEBUFFER_TYPE = GLuint   >
    inline std::shared_ptr<IsFramebuffer<
      RET_TYPE        ,
      FRAMEBUFFER_TYPE>> sharedIsFramebuffer(
        RET_TYPE         const&ret        ,
        FRAMEBUFFER_TYPE const&framebuffer){
        return std::make_shared<IsFramebuffer<
          RET_TYPE        ,
          FRAMEBUFFER_TYPE>>(
              ret        ,
              framebuffer);
    }

    template<
      typename INDEX_TYPE = GLuint>
    inline PrimitiveRestartIndex<
      INDEX_TYPE>* newPrimitiveRestartIndex(
        INDEX_TYPE const&index){
        return new PrimitiveRestartIndex<
          INDEX_TYPE>(
              index);
    }
    template<
      typename INDEX_TYPE = GLuint>
    inline std::shared_ptr<PrimitiveRestartIndex<
      INDEX_TYPE>> sharedPrimitiveRestartIndex(
        INDEX_TYPE const&index){
        return std::make_shared<PrimitiveRestartIndex<
          INDEX_TYPE>>(
              index);
    }

    template<
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr>
    inline FlushMappedNamedBufferRange<
      BUFFER_TYPE,
      OFFSET_TYPE,
      LENGTH_TYPE>* newFlushMappedNamedBufferRange(
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        LENGTH_TYPE const&length){
        return new FlushMappedNamedBufferRange<
          BUFFER_TYPE,
          OFFSET_TYPE,
          LENGTH_TYPE>(
              buffer,
              offset,
              length);
    }
    template<
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename LENGTH_TYPE = GLsizeiptr>
    inline std::shared_ptr<FlushMappedNamedBufferRange<
      BUFFER_TYPE,
      OFFSET_TYPE,
      LENGTH_TYPE>> sharedFlushMappedNamedBufferRange(
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        LENGTH_TYPE const&length){
        return std::make_shared<FlushMappedNamedBufferRange<
          BUFFER_TYPE,
          OFFSET_TYPE,
          LENGTH_TYPE>>(
              buffer,
              offset,
              length);
    }

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei,
      typename DEPTH_TYPE   = GLsizei>
    inline InvalidateTexSubImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      DEPTH_TYPE  >* newInvalidateTexSubImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        DEPTH_TYPE   const&depth  ){
        return new InvalidateTexSubImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          DEPTH_TYPE  >(
              texture,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              width  ,
              height ,
              depth  );
    }
    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei,
      typename DEPTH_TYPE   = GLsizei>
    inline std::shared_ptr<InvalidateTexSubImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      DEPTH_TYPE  >> sharedInvalidateTexSubImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        DEPTH_TYPE   const&depth  ){
        return std::make_shared<InvalidateTexSubImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          DEPTH_TYPE  >>(
              texture,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              width  ,
              height ,
              depth  );
    }

    template<
      typename PNAME_TYPE = GLenum  ,
      typename DATA_TYPE  = GLint64*>
    inline GetInteger64v<
      PNAME_TYPE,
      DATA_TYPE >* newGetInteger64v(
        PNAME_TYPE const&pname,
        DATA_TYPE  const&data ){
        return new GetInteger64v<
          PNAME_TYPE,
          DATA_TYPE >(
              pname,
              data );
    }
    template<
      typename PNAME_TYPE = GLenum  ,
      typename DATA_TYPE  = GLint64*>
    inline std::shared_ptr<GetInteger64v<
      PNAME_TYPE,
      DATA_TYPE >> sharedGetInteger64v(
        PNAME_TYPE const&pname,
        DATA_TYPE  const&data ){
        return std::make_shared<GetInteger64v<
          PNAME_TYPE,
          DATA_TYPE >>(
              pname,
              data );
    }

    template<
      typename PIPELINE_TYPE = GLuint>
    inline BindProgramPipeline<
      PIPELINE_TYPE>* newBindProgramPipeline(
        PIPELINE_TYPE const&pipeline){
        return new BindProgramPipeline<
          PIPELINE_TYPE>(
              pipeline);
    }
    template<
      typename PIPELINE_TYPE = GLuint>
    inline std::shared_ptr<BindProgramPipeline<
      PIPELINE_TYPE>> sharedBindProgramPipeline(
        PIPELINE_TYPE const&pipeline){
        return std::make_shared<BindProgramPipeline<
          PIPELINE_TYPE>>(
              pipeline);
    }

    template<
      typename X_TYPE      = GLint  ,
      typename Y_TYPE      = GLint  ,
      typename WIDTH_TYPE  = GLsizei,
      typename HEIGHT_TYPE = GLsizei>
    inline Scissor<
      X_TYPE     ,
      Y_TYPE     ,
      WIDTH_TYPE ,
      HEIGHT_TYPE>* newScissor(
        X_TYPE      const&x     ,
        Y_TYPE      const&y     ,
        WIDTH_TYPE  const&width ,
        HEIGHT_TYPE const&height){
        return new Scissor<
          X_TYPE     ,
          Y_TYPE     ,
          WIDTH_TYPE ,
          HEIGHT_TYPE>(
              x     ,
              y     ,
              width ,
              height);
    }
    template<
      typename X_TYPE      = GLint  ,
      typename Y_TYPE      = GLint  ,
      typename WIDTH_TYPE  = GLsizei,
      typename HEIGHT_TYPE = GLsizei>
    inline std::shared_ptr<Scissor<
      X_TYPE     ,
      Y_TYPE     ,
      WIDTH_TYPE ,
      HEIGHT_TYPE>> sharedScissor(
        X_TYPE      const&x     ,
        Y_TYPE      const&y     ,
        WIDTH_TYPE  const&width ,
        HEIGHT_TYPE const&height){
        return std::make_shared<Scissor<
          X_TYPE     ,
          Y_TYPE     ,
          WIDTH_TYPE ,
          HEIGHT_TYPE>>(
              x     ,
              y     ,
              width ,
              height);
    }

    template<
      typename PNAME_TYPE = GLenum    ,
      typename DATA_TYPE  = GLboolean*>
    inline GetBooleanv<
      PNAME_TYPE,
      DATA_TYPE >* newGetBooleanv(
        PNAME_TYPE const&pname,
        DATA_TYPE  const&data ){
        return new GetBooleanv<
          PNAME_TYPE,
          DATA_TYPE >(
              pname,
              data );
    }
    template<
      typename PNAME_TYPE = GLenum    ,
      typename DATA_TYPE  = GLboolean*>
    inline std::shared_ptr<GetBooleanv<
      PNAME_TYPE,
      DATA_TYPE >> sharedGetBooleanv(
        PNAME_TYPE const&pname,
        DATA_TYPE  const&data ){
        return std::make_shared<GetBooleanv<
          PNAME_TYPE,
          DATA_TYPE >>(
              pname,
              data );
    }

    template<
      typename FRAMEBUFFER_TYPE        = GLuint,
      typename ATTACHMENT_TYPE         = GLenum,
      typename RENDERBUFFERTARGET_TYPE = GLenum,
      typename RENDERBUFFER_TYPE       = GLuint>
    inline NamedFramebufferRenderbuffer<
      FRAMEBUFFER_TYPE       ,
      ATTACHMENT_TYPE        ,
      RENDERBUFFERTARGET_TYPE,
      RENDERBUFFER_TYPE      >* newNamedFramebufferRenderbuffer(
        FRAMEBUFFER_TYPE        const&framebuffer       ,
        ATTACHMENT_TYPE         const&attachment        ,
        RENDERBUFFERTARGET_TYPE const&renderbuffertarget,
        RENDERBUFFER_TYPE       const&renderbuffer      ){
        return new NamedFramebufferRenderbuffer<
          FRAMEBUFFER_TYPE       ,
          ATTACHMENT_TYPE        ,
          RENDERBUFFERTARGET_TYPE,
          RENDERBUFFER_TYPE      >(
              framebuffer       ,
              attachment        ,
              renderbuffertarget,
              renderbuffer      );
    }
    template<
      typename FRAMEBUFFER_TYPE        = GLuint,
      typename ATTACHMENT_TYPE         = GLenum,
      typename RENDERBUFFERTARGET_TYPE = GLenum,
      typename RENDERBUFFER_TYPE       = GLuint>
    inline std::shared_ptr<NamedFramebufferRenderbuffer<
      FRAMEBUFFER_TYPE       ,
      ATTACHMENT_TYPE        ,
      RENDERBUFFERTARGET_TYPE,
      RENDERBUFFER_TYPE      >> sharedNamedFramebufferRenderbuffer(
        FRAMEBUFFER_TYPE        const&framebuffer       ,
        ATTACHMENT_TYPE         const&attachment        ,
        RENDERBUFFERTARGET_TYPE const&renderbuffertarget,
        RENDERBUFFER_TYPE       const&renderbuffer      ){
        return std::make_shared<NamedFramebufferRenderbuffer<
          FRAMEBUFFER_TYPE       ,
          ATTACHMENT_TYPE        ,
          RENDERBUFFERTARGET_TYPE,
          RENDERBUFFER_TYPE      >>(
              framebuffer       ,
              attachment        ,
              renderbuffertarget,
              renderbuffer      );
    }

    template<
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline Uniform3uiv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform3uiv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform3uiv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline std::shared_ptr<Uniform3uiv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform3uiv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform3uiv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename RED_TYPE   = GLfloat,
      typename GREEN_TYPE = GLfloat,
      typename BLUE_TYPE  = GLfloat,
      typename ALPHA_TYPE = GLfloat>
    inline ClearColor<
      RED_TYPE  ,
      GREEN_TYPE,
      BLUE_TYPE ,
      ALPHA_TYPE>* newClearColor(
        RED_TYPE   const&red  ,
        GREEN_TYPE const&green,
        BLUE_TYPE  const&blue ,
        ALPHA_TYPE const&alpha){
        return new ClearColor<
          RED_TYPE  ,
          GREEN_TYPE,
          BLUE_TYPE ,
          ALPHA_TYPE>(
              red  ,
              green,
              blue ,
              alpha);
    }
    template<
      typename RED_TYPE   = GLfloat,
      typename GREEN_TYPE = GLfloat,
      typename BLUE_TYPE  = GLfloat,
      typename ALPHA_TYPE = GLfloat>
    inline std::shared_ptr<ClearColor<
      RED_TYPE  ,
      GREEN_TYPE,
      BLUE_TYPE ,
      ALPHA_TYPE>> sharedClearColor(
        RED_TYPE   const&red  ,
        GREEN_TYPE const&green,
        BLUE_TYPE  const&blue ,
        ALPHA_TYPE const&alpha){
        return std::make_shared<ClearColor<
          RED_TYPE  ,
          GREEN_TYPE,
          BLUE_TYPE ,
          ALPHA_TYPE>>(
              red  ,
              green,
              blue ,
              alpha);
    }

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline VertexAttrib4Niv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4Niv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4Niv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline std::shared_ptr<VertexAttrib4Niv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4Niv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4Niv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename BUFFER_TYPE     = GLenum      ,
      typename DRAWBUFFER_TYPE = GLint       ,
      typename VALUE_TYPE      = const GLint*>
    inline ClearBufferiv<
      BUFFER_TYPE    ,
      DRAWBUFFER_TYPE,
      VALUE_TYPE     >* newClearBufferiv(
        BUFFER_TYPE     const&buffer    ,
        DRAWBUFFER_TYPE const&drawbuffer,
        VALUE_TYPE      const&value     ){
        return new ClearBufferiv<
          BUFFER_TYPE    ,
          DRAWBUFFER_TYPE,
          VALUE_TYPE     >(
              buffer    ,
              drawbuffer,
              value     );
    }
    template<
      typename BUFFER_TYPE     = GLenum      ,
      typename DRAWBUFFER_TYPE = GLint       ,
      typename VALUE_TYPE      = const GLint*>
    inline std::shared_ptr<ClearBufferiv<
      BUFFER_TYPE    ,
      DRAWBUFFER_TYPE,
      VALUE_TYPE     >> sharedClearBufferiv(
        BUFFER_TYPE     const&buffer    ,
        DRAWBUFFER_TYPE const&drawbuffer,
        VALUE_TYPE      const&value     ){
        return std::make_shared<ClearBufferiv<
          BUFFER_TYPE    ,
          DRAWBUFFER_TYPE,
          VALUE_TYPE     >>(
              buffer    ,
              drawbuffer,
              value     );
    }

    template<
      typename TARGET_TYPE = GLenum  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLint64*>
    inline GetBufferParameteri64v<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetBufferParameteri64v(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetBufferParameteri64v<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLint64*>
    inline std::shared_ptr<GetBufferParameteri64v<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetBufferParameteri64v(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetBufferParameteri64v<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename PROGRAM_TYPE  = GLuint         ,
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline ProgramUniform4dv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform4dv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform4dv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint         ,
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline std::shared_ptr<ProgramUniform4dv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform4dv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform4dv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename TEXTURE_TYPE = GLuint,
      typename LEVEL_TYPE   = GLint ,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    inline GetTextureLevelParameteriv<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newGetTextureLevelParameteriv(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new GetTextureLevelParameteriv<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              texture,
              level  ,
              pname  ,
              params );
    }
    template<
      typename TEXTURE_TYPE = GLuint,
      typename LEVEL_TYPE   = GLint ,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    inline std::shared_ptr<GetTextureLevelParameteriv<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedGetTextureLevelParameteriv(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<GetTextureLevelParameteriv<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              texture,
              level  ,
              pname  ,
              params );
    }

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename BUFSIZE_TYPE  = GLsizei,
      typename PARAMS_TYPE   = GLint* >
    inline GetnUniformiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      BUFSIZE_TYPE ,
      PARAMS_TYPE  >* newGetnUniformiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        BUFSIZE_TYPE  const&bufSize ,
        PARAMS_TYPE   const&params  ){
        return new GetnUniformiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          BUFSIZE_TYPE ,
          PARAMS_TYPE  >(
              program ,
              location,
              bufSize ,
              params  );
    }
    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename BUFSIZE_TYPE  = GLsizei,
      typename PARAMS_TYPE   = GLint* >
    inline std::shared_ptr<GetnUniformiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      BUFSIZE_TYPE ,
      PARAMS_TYPE  >> sharedGetnUniformiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        BUFSIZE_TYPE  const&bufSize ,
        PARAMS_TYPE   const&params  ){
        return std::make_shared<GetnUniformiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          BUFSIZE_TYPE ,
          PARAMS_TYPE  >>(
              program ,
              location,
              bufSize ,
              params  );
    }

    template<
      typename RET_TYPE   = const GLubyte*,
      typename NAME_TYPE  = GLenum        ,
      typename INDEX_TYPE = GLuint        >
    inline GetStringi<
      RET_TYPE  ,
      NAME_TYPE ,
      INDEX_TYPE>* newGetStringi(
        RET_TYPE   const&ret  ,
        NAME_TYPE  const&name ,
        INDEX_TYPE const&index){
        return new GetStringi<
          RET_TYPE  ,
          NAME_TYPE ,
          INDEX_TYPE>(
              ret  ,
              name ,
              index);
    }
    template<
      typename RET_TYPE   = const GLubyte*,
      typename NAME_TYPE  = GLenum        ,
      typename INDEX_TYPE = GLuint        >
    inline std::shared_ptr<GetStringi<
      RET_TYPE  ,
      NAME_TYPE ,
      INDEX_TYPE>> sharedGetStringi(
        RET_TYPE   const&ret  ,
        NAME_TYPE  const&name ,
        INDEX_TYPE const&index){
        return std::make_shared<GetStringi<
          RET_TYPE  ,
          NAME_TYPE ,
          INDEX_TYPE>>(
              ret  ,
              name ,
              index);
    }

    template<
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint,
      typename V2_TYPE       = GLuint>
    inline Uniform3ui<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >* newUniform3ui(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return new Uniform3ui<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >(
              location,
              v0      ,
              v1      ,
              v2      );
    }
    template<
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint,
      typename V2_TYPE       = GLuint>
    inline std::shared_ptr<Uniform3ui<
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      >> sharedUniform3ui(
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ){
        return std::make_shared<Uniform3ui<
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      >>(
              location,
              v0      ,
              v1      ,
              v2      );
    }

    template<
      typename VAOBJ_TYPE = GLuint,
      typename INDEX_TYPE = GLuint,
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint*>
    inline GetVertexArrayIndexediv<
      VAOBJ_TYPE,
      INDEX_TYPE,
      PNAME_TYPE,
      PARAM_TYPE>* newGetVertexArrayIndexediv(
        VAOBJ_TYPE const&vaobj,
        INDEX_TYPE const&index,
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return new GetVertexArrayIndexediv<
          VAOBJ_TYPE,
          INDEX_TYPE,
          PNAME_TYPE,
          PARAM_TYPE>(
              vaobj,
              index,
              pname,
              param);
    }
    template<
      typename VAOBJ_TYPE = GLuint,
      typename INDEX_TYPE = GLuint,
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint*>
    inline std::shared_ptr<GetVertexArrayIndexediv<
      VAOBJ_TYPE,
      INDEX_TYPE,
      PNAME_TYPE,
      PARAM_TYPE>> sharedGetVertexArrayIndexediv(
        VAOBJ_TYPE const&vaobj,
        INDEX_TYPE const&index,
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return std::make_shared<GetVertexArrayIndexediv<
          VAOBJ_TYPE,
          INDEX_TYPE,
          PNAME_TYPE,
          PARAM_TYPE>>(
              vaobj,
              index,
              pname,
              param);
    }

    template<
      typename PNAME_TYPE  = GLenum        ,
      typename PARAMS_TYPE = const GLfloat*>
    inline PointParameterfv<
      PNAME_TYPE ,
      PARAMS_TYPE>* newPointParameterfv(
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new PointParameterfv<
          PNAME_TYPE ,
          PARAMS_TYPE>(
              pname ,
              params);
    }
    template<
      typename PNAME_TYPE  = GLenum        ,
      typename PARAMS_TYPE = const GLfloat*>
    inline std::shared_ptr<PointParameterfv<
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedPointParameterfv(
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<PointParameterfv<
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              pname ,
              params);
    }

    template<
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline Uniform2fv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform2fv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform2fv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline std::shared_ptr<Uniform2fv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform2fv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform2fv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename PROGRAM_TYPE    = GLuint  ,
      typename SHADERTYPE_TYPE = GLenum  ,
      typename INDEX_TYPE      = GLuint  ,
      typename BUFSIZE_TYPE    = GLsizei ,
      typename LENGTH_TYPE     = GLsizei*,
      typename NAME_TYPE       = GLchar* >
    inline GetActiveSubroutineUniformName<
      PROGRAM_TYPE   ,
      SHADERTYPE_TYPE,
      INDEX_TYPE     ,
      BUFSIZE_TYPE   ,
      LENGTH_TYPE    ,
      NAME_TYPE      >* newGetActiveSubroutineUniformName(
        PROGRAM_TYPE    const&program   ,
        SHADERTYPE_TYPE const&shadertype,
        INDEX_TYPE      const&index     ,
        BUFSIZE_TYPE    const&bufsize   ,
        LENGTH_TYPE     const&length    ,
        NAME_TYPE       const&name      ){
        return new GetActiveSubroutineUniformName<
          PROGRAM_TYPE   ,
          SHADERTYPE_TYPE,
          INDEX_TYPE     ,
          BUFSIZE_TYPE   ,
          LENGTH_TYPE    ,
          NAME_TYPE      >(
              program   ,
              shadertype,
              index     ,
              bufsize   ,
              length    ,
              name      );
    }
    template<
      typename PROGRAM_TYPE    = GLuint  ,
      typename SHADERTYPE_TYPE = GLenum  ,
      typename INDEX_TYPE      = GLuint  ,
      typename BUFSIZE_TYPE    = GLsizei ,
      typename LENGTH_TYPE     = GLsizei*,
      typename NAME_TYPE       = GLchar* >
    inline std::shared_ptr<GetActiveSubroutineUniformName<
      PROGRAM_TYPE   ,
      SHADERTYPE_TYPE,
      INDEX_TYPE     ,
      BUFSIZE_TYPE   ,
      LENGTH_TYPE    ,
      NAME_TYPE      >> sharedGetActiveSubroutineUniformName(
        PROGRAM_TYPE    const&program   ,
        SHADERTYPE_TYPE const&shadertype,
        INDEX_TYPE      const&index     ,
        BUFSIZE_TYPE    const&bufsize   ,
        LENGTH_TYPE     const&length    ,
        NAME_TYPE       const&name      ){
        return std::make_shared<GetActiveSubroutineUniformName<
          PROGRAM_TYPE   ,
          SHADERTYPE_TYPE,
          INDEX_TYPE     ,
          BUFSIZE_TYPE   ,
          LENGTH_TYPE    ,
          NAME_TYPE      >>(
              program   ,
              shadertype,
              index     ,
              bufsize   ,
              length    ,
              name      );
    }

    template<
      typename RET_TYPE              = GLuint       ,
      typename PROGRAM_TYPE          = GLuint       ,
      typename PROGRAMINTERFACE_TYPE = GLenum       ,
      typename NAME_TYPE             = const GLchar*>
    inline GetProgramResourceIndex<
      RET_TYPE             ,
      PROGRAM_TYPE         ,
      PROGRAMINTERFACE_TYPE,
      NAME_TYPE            >* newGetProgramResourceIndex(
        RET_TYPE              const&ret             ,
        PROGRAM_TYPE          const&program         ,
        PROGRAMINTERFACE_TYPE const&programInterface,
        NAME_TYPE             const&name            ){
        return new GetProgramResourceIndex<
          RET_TYPE             ,
          PROGRAM_TYPE         ,
          PROGRAMINTERFACE_TYPE,
          NAME_TYPE            >(
              ret             ,
              program         ,
              programInterface,
              name            );
    }
    template<
      typename RET_TYPE              = GLuint       ,
      typename PROGRAM_TYPE          = GLuint       ,
      typename PROGRAMINTERFACE_TYPE = GLenum       ,
      typename NAME_TYPE             = const GLchar*>
    inline std::shared_ptr<GetProgramResourceIndex<
      RET_TYPE             ,
      PROGRAM_TYPE         ,
      PROGRAMINTERFACE_TYPE,
      NAME_TYPE            >> sharedGetProgramResourceIndex(
        RET_TYPE              const&ret             ,
        PROGRAM_TYPE          const&program         ,
        PROGRAMINTERFACE_TYPE const&programInterface,
        NAME_TYPE             const&name            ){
        return std::make_shared<GetProgramResourceIndex<
          RET_TYPE             ,
          PROGRAM_TYPE         ,
          PROGRAMINTERFACE_TYPE,
          NAME_TYPE            >>(
              ret             ,
              program         ,
              programInterface,
              name            );
    }

    template<
      typename MODE_TYPE     = GLenum     ,
      typename TYPE_TYPE     = GLenum     ,
      typename INDIRECT_TYPE = const void*>
    inline DrawElementsIndirect<
      MODE_TYPE    ,
      TYPE_TYPE    ,
      INDIRECT_TYPE>* newDrawElementsIndirect(
        MODE_TYPE     const&mode    ,
        TYPE_TYPE     const&type    ,
        INDIRECT_TYPE const&indirect){
        return new DrawElementsIndirect<
          MODE_TYPE    ,
          TYPE_TYPE    ,
          INDIRECT_TYPE>(
              mode    ,
              type    ,
              indirect);
    }
    template<
      typename MODE_TYPE     = GLenum     ,
      typename TYPE_TYPE     = GLenum     ,
      typename INDIRECT_TYPE = const void*>
    inline std::shared_ptr<DrawElementsIndirect<
      MODE_TYPE    ,
      TYPE_TYPE    ,
      INDIRECT_TYPE>> sharedDrawElementsIndirect(
        MODE_TYPE     const&mode    ,
        TYPE_TYPE     const&type    ,
        INDIRECT_TYPE const&indirect){
        return std::make_shared<DrawElementsIndirect<
          MODE_TYPE    ,
          TYPE_TYPE    ,
          INDIRECT_TYPE>>(
              mode    ,
              type    ,
              indirect);
    }

    template<
      typename TEXTURE_TYPE = GLuint  ,
      typename LEVEL_TYPE   = GLint   ,
      typename PNAME_TYPE   = GLenum  ,
      typename PARAMS_TYPE  = GLfloat*>
    inline GetTextureLevelParameterfv<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newGetTextureLevelParameterfv(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new GetTextureLevelParameterfv<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              texture,
              level  ,
              pname  ,
              params );
    }
    template<
      typename TEXTURE_TYPE = GLuint  ,
      typename LEVEL_TYPE   = GLint   ,
      typename PNAME_TYPE   = GLenum  ,
      typename PARAMS_TYPE  = GLfloat*>
    inline std::shared_ptr<GetTextureLevelParameterfv<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedGetTextureLevelParameterfv(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<GetTextureLevelParameterfv<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              texture,
              level  ,
              pname  ,
              params );
    }

    template<
      typename BUFFER_TYPE = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = void**>
    inline GetNamedBufferPointerv<
      BUFFER_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetNamedBufferPointerv(
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetNamedBufferPointerv<
          BUFFER_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              buffer,
              pname ,
              params);
    }
    template<
      typename BUFFER_TYPE = GLuint,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = void**>
    inline std::shared_ptr<GetNamedBufferPointerv<
      BUFFER_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetNamedBufferPointerv(
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetNamedBufferPointerv<
          BUFFER_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              buffer,
              pname ,
              params);
    }

    template<
      typename INDIRECT_TYPE = GLintptr>
    inline DispatchComputeIndirect<
      INDIRECT_TYPE>* newDispatchComputeIndirect(
        INDIRECT_TYPE const&indirect){
        return new DispatchComputeIndirect<
          INDIRECT_TYPE>(
              indirect);
    }
    template<
      typename INDIRECT_TYPE = GLintptr>
    inline std::shared_ptr<DispatchComputeIndirect<
      INDIRECT_TYPE>> sharedDispatchComputeIndirect(
        INDIRECT_TYPE const&indirect){
        return std::make_shared<DispatchComputeIndirect<
          INDIRECT_TYPE>>(
              indirect);
    }

    template<
      typename FRAMEBUFFER_TYPE    = GLuint       ,
      typename NUMATTACHMENTS_TYPE = GLsizei      ,
      typename ATTACHMENTS_TYPE    = const GLenum*,
      typename X_TYPE              = GLint        ,
      typename Y_TYPE              = GLint        ,
      typename WIDTH_TYPE          = GLsizei      ,
      typename HEIGHT_TYPE         = GLsizei      >
    inline InvalidateNamedFramebufferSubData<
      FRAMEBUFFER_TYPE   ,
      NUMATTACHMENTS_TYPE,
      ATTACHMENTS_TYPE   ,
      X_TYPE             ,
      Y_TYPE             ,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >* newInvalidateNamedFramebufferSubData(
        FRAMEBUFFER_TYPE    const&framebuffer   ,
        NUMATTACHMENTS_TYPE const&numAttachments,
        ATTACHMENTS_TYPE    const&attachments   ,
        X_TYPE              const&x             ,
        Y_TYPE              const&y             ,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return new InvalidateNamedFramebufferSubData<
          FRAMEBUFFER_TYPE   ,
          NUMATTACHMENTS_TYPE,
          ATTACHMENTS_TYPE   ,
          X_TYPE             ,
          Y_TYPE             ,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >(
              framebuffer   ,
              numAttachments,
              attachments   ,
              x             ,
              y             ,
              width         ,
              height        );
    }
    template<
      typename FRAMEBUFFER_TYPE    = GLuint       ,
      typename NUMATTACHMENTS_TYPE = GLsizei      ,
      typename ATTACHMENTS_TYPE    = const GLenum*,
      typename X_TYPE              = GLint        ,
      typename Y_TYPE              = GLint        ,
      typename WIDTH_TYPE          = GLsizei      ,
      typename HEIGHT_TYPE         = GLsizei      >
    inline std::shared_ptr<InvalidateNamedFramebufferSubData<
      FRAMEBUFFER_TYPE   ,
      NUMATTACHMENTS_TYPE,
      ATTACHMENTS_TYPE   ,
      X_TYPE             ,
      Y_TYPE             ,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >> sharedInvalidateNamedFramebufferSubData(
        FRAMEBUFFER_TYPE    const&framebuffer   ,
        NUMATTACHMENTS_TYPE const&numAttachments,
        ATTACHMENTS_TYPE    const&attachments   ,
        X_TYPE              const&x             ,
        Y_TYPE              const&y             ,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return std::make_shared<InvalidateNamedFramebufferSubData<
          FRAMEBUFFER_TYPE   ,
          NUMATTACHMENTS_TYPE,
          ATTACHMENTS_TYPE   ,
          X_TYPE             ,
          Y_TYPE             ,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >>(
              framebuffer   ,
              numAttachments,
              attachments   ,
              x             ,
              y             ,
              width         ,
              height        );
    }

    template<
      typename SAMPLER_TYPE = GLuint ,
      typename PNAME_TYPE   = GLenum ,
      typename PARAMS_TYPE  = GLuint*>
    inline GetSamplerParameterIuiv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newGetSamplerParameterIuiv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new GetSamplerParameterIuiv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              sampler,
              pname  ,
              params );
    }
    template<
      typename SAMPLER_TYPE = GLuint ,
      typename PNAME_TYPE   = GLenum ,
      typename PARAMS_TYPE  = GLuint*>
    inline std::shared_ptr<GetSamplerParameterIuiv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedGetSamplerParameterIuiv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<GetSamplerParameterIuiv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              sampler,
              pname  ,
              params );
    }

    template<
      typename TARGET_TYPE = GLenum    ,
      typename INDEX_TYPE  = GLuint    ,
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr>
    inline BindBufferRange<
      TARGET_TYPE,
      INDEX_TYPE ,
      BUFFER_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  >* newBindBufferRange(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ){
        return new BindBufferRange<
          TARGET_TYPE,
          INDEX_TYPE ,
          BUFFER_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  >(
              target,
              index ,
              buffer,
              offset,
              size  );
    }
    template<
      typename TARGET_TYPE = GLenum    ,
      typename INDEX_TYPE  = GLuint    ,
      typename BUFFER_TYPE = GLuint    ,
      typename OFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE   = GLsizeiptr>
    inline std::shared_ptr<BindBufferRange<
      TARGET_TYPE,
      INDEX_TYPE ,
      BUFFER_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  >> sharedBindBufferRange(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        BUFFER_TYPE const&buffer,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ){
        return std::make_shared<BindBufferRange<
          TARGET_TYPE,
          INDEX_TYPE ,
          BUFFER_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  >>(
              target,
              index ,
              buffer,
              offset,
              size  );
    }

    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    inline TextureSubImage1D<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      WIDTH_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      PIXELS_TYPE >* newTextureSubImage1D(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        WIDTH_TYPE   const&width  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        PIXELS_TYPE  const&pixels ){
        return new TextureSubImage1D<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          WIDTH_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          PIXELS_TYPE >(
              texture,
              level  ,
              xoffset,
              width  ,
              format ,
              type   ,
              pixels );
    }
    template<
      typename TEXTURE_TYPE = GLuint     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    inline std::shared_ptr<TextureSubImage1D<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      WIDTH_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      PIXELS_TYPE >> sharedTextureSubImage1D(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        WIDTH_TYPE   const&width  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        PIXELS_TYPE  const&pixels ){
        return std::make_shared<TextureSubImage1D<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          WIDTH_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          PIXELS_TYPE >>(
              texture,
              level  ,
              xoffset,
              width  ,
              format ,
              type   ,
              pixels );
    }

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline VertexAttribL3dv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribL3dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribL3dv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline std::shared_ptr<VertexAttribL3dv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribL3dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribL3dv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename PROGRAM_TYPE  = GLuint   ,
      typename LOCATION_TYPE = GLint    ,
      typename PARAMS_TYPE   = GLdouble*>
    inline GetUniformdv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      PARAMS_TYPE  >* newGetUniformdv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        PARAMS_TYPE   const&params  ){
        return new GetUniformdv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          PARAMS_TYPE  >(
              program ,
              location,
              params  );
    }
    template<
      typename PROGRAM_TYPE  = GLuint   ,
      typename LOCATION_TYPE = GLint    ,
      typename PARAMS_TYPE   = GLdouble*>
    inline std::shared_ptr<GetUniformdv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      PARAMS_TYPE  >> sharedGetUniformdv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        PARAMS_TYPE   const&params  ){
        return std::make_shared<GetUniformdv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          PARAMS_TYPE  >>(
              program ,
              location,
              params  );
    }

    template<
      typename ID_TYPE     = GLuint  ,
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename OFFSET_TYPE = GLintptr>
    inline GetQueryBufferObjectui64v<
      ID_TYPE    ,
      BUFFER_TYPE,
      PNAME_TYPE ,
      OFFSET_TYPE>* newGetQueryBufferObjectui64v(
        ID_TYPE     const&id    ,
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        OFFSET_TYPE const&offset){
        return new GetQueryBufferObjectui64v<
          ID_TYPE    ,
          BUFFER_TYPE,
          PNAME_TYPE ,
          OFFSET_TYPE>(
              id    ,
              buffer,
              pname ,
              offset);
    }
    template<
      typename ID_TYPE     = GLuint  ,
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename OFFSET_TYPE = GLintptr>
    inline std::shared_ptr<GetQueryBufferObjectui64v<
      ID_TYPE    ,
      BUFFER_TYPE,
      PNAME_TYPE ,
      OFFSET_TYPE>> sharedGetQueryBufferObjectui64v(
        ID_TYPE     const&id    ,
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        OFFSET_TYPE const&offset){
        return std::make_shared<GetQueryBufferObjectui64v<
          ID_TYPE    ,
          BUFFER_TYPE,
          PNAME_TYPE ,
          OFFSET_TYPE>>(
              id    ,
              buffer,
              pname ,
              offset);
    }

    template<
      typename D_TYPE = GLfloat>
    inline ClearDepthf<
      D_TYPE>* newClearDepthf(
        D_TYPE const&d){
        return new ClearDepthf<
          D_TYPE>(
              d);
    }
    template<
      typename D_TYPE = GLfloat>
    inline std::shared_ptr<ClearDepthf<
      D_TYPE>> sharedClearDepthf(
        D_TYPE const&d){
        return std::make_shared<ClearDepthf<
          D_TYPE>>(
              d);
    }

    template<
      typename INDEX_TYPE  = GLuint ,
      typename PNAME_TYPE  = GLenum ,
      typename PARAMS_TYPE = GLuint*>
    inline GetVertexAttribIuiv<
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetVertexAttribIuiv(
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetVertexAttribIuiv<
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              index ,
              pname ,
              params);
    }
    template<
      typename INDEX_TYPE  = GLuint ,
      typename PNAME_TYPE  = GLenum ,
      typename PARAMS_TYPE = GLuint*>
    inline std::shared_ptr<GetVertexAttribIuiv<
      INDEX_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetVertexAttribIuiv(
        INDEX_TYPE  const&index ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetVertexAttribIuiv<
          INDEX_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              index ,
              pname ,
              params);
    }

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline UniformMatrix2x3fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix2x3fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix2x3fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<UniformMatrix2x3fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix2x3fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix2x3fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename N_TYPE   = GLsizei,
      typename IDS_TYPE = GLuint*>
    inline GenTransformFeedbacks<
      N_TYPE  ,
      IDS_TYPE>* newGenTransformFeedbacks(
        N_TYPE   const&n  ,
        IDS_TYPE const&ids){
        return new GenTransformFeedbacks<
          N_TYPE  ,
          IDS_TYPE>(
              n  ,
              ids);
    }
    template<
      typename N_TYPE   = GLsizei,
      typename IDS_TYPE = GLuint*>
    inline std::shared_ptr<GenTransformFeedbacks<
      N_TYPE  ,
      IDS_TYPE>> sharedGenTransformFeedbacks(
        N_TYPE   const&n  ,
        IDS_TYPE const&ids){
        return std::make_shared<GenTransformFeedbacks<
          N_TYPE  ,
          IDS_TYPE>>(
              n  ,
              ids);
    }

    template<
      typename N_TYPE             = GLsizei,
      typename RENDERBUFFERS_TYPE = GLuint*>
    inline CreateRenderbuffers<
      N_TYPE            ,
      RENDERBUFFERS_TYPE>* newCreateRenderbuffers(
        N_TYPE             const&n            ,
        RENDERBUFFERS_TYPE const&renderbuffers){
        return new CreateRenderbuffers<
          N_TYPE            ,
          RENDERBUFFERS_TYPE>(
              n            ,
              renderbuffers);
    }
    template<
      typename N_TYPE             = GLsizei,
      typename RENDERBUFFERS_TYPE = GLuint*>
    inline std::shared_ptr<CreateRenderbuffers<
      N_TYPE            ,
      RENDERBUFFERS_TYPE>> sharedCreateRenderbuffers(
        N_TYPE             const&n            ,
        RENDERBUFFERS_TYPE const&renderbuffers){
        return std::make_shared<CreateRenderbuffers<
          N_TYPE            ,
          RENDERBUFFERS_TYPE>>(
              n            ,
              renderbuffers);
    }

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLushort*>
    inline VertexAttrib4Nusv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4Nusv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4Nusv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLushort*>
    inline std::shared_ptr<VertexAttrib4Nusv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4Nusv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4Nusv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline ProgramUniformMatrix4x3dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix4x3dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix4x3dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<ProgramUniformMatrix4x3dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix4x3dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix4x3dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename RED_TYPE   = GLboolean,
      typename GREEN_TYPE = GLboolean,
      typename BLUE_TYPE  = GLboolean,
      typename ALPHA_TYPE = GLboolean>
    inline ColorMask<
      RED_TYPE  ,
      GREEN_TYPE,
      BLUE_TYPE ,
      ALPHA_TYPE>* newColorMask(
        RED_TYPE   const&red  ,
        GREEN_TYPE const&green,
        BLUE_TYPE  const&blue ,
        ALPHA_TYPE const&alpha){
        return new ColorMask<
          RED_TYPE  ,
          GREEN_TYPE,
          BLUE_TYPE ,
          ALPHA_TYPE>(
              red  ,
              green,
              blue ,
              alpha);
    }
    template<
      typename RED_TYPE   = GLboolean,
      typename GREEN_TYPE = GLboolean,
      typename BLUE_TYPE  = GLboolean,
      typename ALPHA_TYPE = GLboolean>
    inline std::shared_ptr<ColorMask<
      RED_TYPE  ,
      GREEN_TYPE,
      BLUE_TYPE ,
      ALPHA_TYPE>> sharedColorMask(
        RED_TYPE   const&red  ,
        GREEN_TYPE const&green,
        BLUE_TYPE  const&blue ,
        ALPHA_TYPE const&alpha){
        return std::make_shared<ColorMask<
          RED_TYPE  ,
          GREEN_TYPE,
          BLUE_TYPE ,
          ALPHA_TYPE>>(
              red  ,
              green,
              blue ,
              alpha);
    }

    template<
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei,
      typename FORMAT_TYPE  = GLenum ,
      typename TYPE_TYPE    = GLenum ,
      typename BUFSIZE_TYPE = GLsizei,
      typename DATA_TYPE    = void*  >
    inline ReadnPixels<
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      BUFSIZE_TYPE,
      DATA_TYPE   >* newReadnPixels(
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        BUFSIZE_TYPE const&bufSize,
        DATA_TYPE    const&data   ){
        return new ReadnPixels<
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          BUFSIZE_TYPE,
          DATA_TYPE   >(
              x      ,
              y      ,
              width  ,
              height ,
              format ,
              type   ,
              bufSize,
              data   );
    }
    template<
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei,
      typename FORMAT_TYPE  = GLenum ,
      typename TYPE_TYPE    = GLenum ,
      typename BUFSIZE_TYPE = GLsizei,
      typename DATA_TYPE    = void*  >
    inline std::shared_ptr<ReadnPixels<
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      BUFSIZE_TYPE,
      DATA_TYPE   >> sharedReadnPixels(
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        BUFSIZE_TYPE const&bufSize,
        DATA_TYPE    const&data   ){
        return std::make_shared<ReadnPixels<
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          BUFSIZE_TYPE,
          DATA_TYPE   >>(
              x      ,
              y      ,
              width  ,
              height ,
              format ,
              type   ,
              bufSize,
              data   );
    }

    template<
      typename RET_TYPE   = GLboolean,
      typename ARRAY_TYPE = GLuint   >
    inline IsVertexArray<
      RET_TYPE  ,
      ARRAY_TYPE>* newIsVertexArray(
        RET_TYPE   const&ret  ,
        ARRAY_TYPE const&array){
        return new IsVertexArray<
          RET_TYPE  ,
          ARRAY_TYPE>(
              ret  ,
              array);
    }
    template<
      typename RET_TYPE   = GLboolean,
      typename ARRAY_TYPE = GLuint   >
    inline std::shared_ptr<IsVertexArray<
      RET_TYPE  ,
      ARRAY_TYPE>> sharedIsVertexArray(
        RET_TYPE   const&ret  ,
        ARRAY_TYPE const&array){
        return std::make_shared<IsVertexArray<
          RET_TYPE  ,
          ARRAY_TYPE>>(
              ret  ,
              array);
    }

    template<
      typename PROGRAM_TYPE      = GLuint     ,
      typename BINARYFORMAT_TYPE = GLenum     ,
      typename BINARY_TYPE       = const void*,
      typename LENGTH_TYPE       = GLsizei    >
    inline ProgramBinary<
      PROGRAM_TYPE     ,
      BINARYFORMAT_TYPE,
      BINARY_TYPE      ,
      LENGTH_TYPE      >* newProgramBinary(
        PROGRAM_TYPE      const&program     ,
        BINARYFORMAT_TYPE const&binaryFormat,
        BINARY_TYPE       const&binary      ,
        LENGTH_TYPE       const&length      ){
        return new ProgramBinary<
          PROGRAM_TYPE     ,
          BINARYFORMAT_TYPE,
          BINARY_TYPE      ,
          LENGTH_TYPE      >(
              program     ,
              binaryFormat,
              binary      ,
              length      );
    }
    template<
      typename PROGRAM_TYPE      = GLuint     ,
      typename BINARYFORMAT_TYPE = GLenum     ,
      typename BINARY_TYPE       = const void*,
      typename LENGTH_TYPE       = GLsizei    >
    inline std::shared_ptr<ProgramBinary<
      PROGRAM_TYPE     ,
      BINARYFORMAT_TYPE,
      BINARY_TYPE      ,
      LENGTH_TYPE      >> sharedProgramBinary(
        PROGRAM_TYPE      const&program     ,
        BINARYFORMAT_TYPE const&binaryFormat,
        BINARY_TYPE       const&binary      ,
        LENGTH_TYPE       const&length      ){
        return std::make_shared<ProgramBinary<
          PROGRAM_TYPE     ,
          BINARYFORMAT_TYPE,
          BINARY_TYPE      ,
          LENGTH_TYPE      >>(
              program     ,
              binaryFormat,
              binary      ,
              length      );
    }

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLbyte*>
    inline VertexAttribI4bv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribI4bv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribI4bv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLbyte*>
    inline std::shared_ptr<VertexAttribI4bv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribI4bv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribI4bv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename TARGET_TYPE = GLenum  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLfloat*>
    inline GetTexParameterfv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetTexParameterfv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetTexParameterfv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLfloat*>
    inline std::shared_ptr<GetTexParameterfv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetTexParameterfv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetTexParameterfv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename BUF_TYPE = GLuint,
      typename SRC_TYPE = GLenum,
      typename DST_TYPE = GLenum>
    inline BlendFunci<
      BUF_TYPE,
      SRC_TYPE,
      DST_TYPE>* newBlendFunci(
        BUF_TYPE const&buf,
        SRC_TYPE const&src,
        DST_TYPE const&dst){
        return new BlendFunci<
          BUF_TYPE,
          SRC_TYPE,
          DST_TYPE>(
              buf,
              src,
              dst);
    }
    template<
      typename BUF_TYPE = GLuint,
      typename SRC_TYPE = GLenum,
      typename DST_TYPE = GLenum>
    inline std::shared_ptr<BlendFunci<
      BUF_TYPE,
      SRC_TYPE,
      DST_TYPE>> sharedBlendFunci(
        BUF_TYPE const&buf,
        SRC_TYPE const&src,
        DST_TYPE const&dst){
        return std::make_shared<BlendFunci<
          BUF_TYPE,
          SRC_TYPE,
          DST_TYPE>>(
              buf,
              src,
              dst);
    }

    template<
      typename TARGET_TYPE = GLenum     ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*,
      typename FLAGS_TYPE  = GLbitfield >
    inline BufferStorage<
      TARGET_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  ,
      FLAGS_TYPE >* newBufferStorage(
        TARGET_TYPE const&target,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ,
        FLAGS_TYPE  const&flags ){
        return new BufferStorage<
          TARGET_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  ,
          FLAGS_TYPE >(
              target,
              size  ,
              data  ,
              flags );
    }
    template<
      typename TARGET_TYPE = GLenum     ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*,
      typename FLAGS_TYPE  = GLbitfield >
    inline std::shared_ptr<BufferStorage<
      TARGET_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  ,
      FLAGS_TYPE >> sharedBufferStorage(
        TARGET_TYPE const&target,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ,
        FLAGS_TYPE  const&flags ){
        return std::make_shared<BufferStorage<
          TARGET_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  ,
          FLAGS_TYPE >>(
              target,
              size  ,
              data  ,
              flags );
    }

    template<
      typename RET_TYPE     = GLenum    ,
      typename SYNC_TYPE    = GLsync    ,
      typename FLAGS_TYPE   = GLbitfield,
      typename TIMEOUT_TYPE = GLuint64  >
    inline ClientWaitSync<
      RET_TYPE    ,
      SYNC_TYPE   ,
      FLAGS_TYPE  ,
      TIMEOUT_TYPE>* newClientWaitSync(
        RET_TYPE     const&ret    ,
        SYNC_TYPE    const&sync   ,
        FLAGS_TYPE   const&flags  ,
        TIMEOUT_TYPE const&timeout){
        return new ClientWaitSync<
          RET_TYPE    ,
          SYNC_TYPE   ,
          FLAGS_TYPE  ,
          TIMEOUT_TYPE>(
              ret    ,
              sync   ,
              flags  ,
              timeout);
    }
    template<
      typename RET_TYPE     = GLenum    ,
      typename SYNC_TYPE    = GLsync    ,
      typename FLAGS_TYPE   = GLbitfield,
      typename TIMEOUT_TYPE = GLuint64  >
    inline std::shared_ptr<ClientWaitSync<
      RET_TYPE    ,
      SYNC_TYPE   ,
      FLAGS_TYPE  ,
      TIMEOUT_TYPE>> sharedClientWaitSync(
        RET_TYPE     const&ret    ,
        SYNC_TYPE    const&sync   ,
        FLAGS_TYPE   const&flags  ,
        TIMEOUT_TYPE const&timeout){
        return std::make_shared<ClientWaitSync<
          RET_TYPE    ,
          SYNC_TYPE   ,
          FLAGS_TYPE  ,
          TIMEOUT_TYPE>>(
              ret    ,
              sync   ,
              flags  ,
              timeout);
    }

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLuint,
      typename Y_TYPE     = GLuint,
      typename Z_TYPE     = GLuint,
      typename W_TYPE     = GLuint>
    inline VertexAttribI4ui<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >* newVertexAttribI4ui(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return new VertexAttribI4ui<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }
    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLuint,
      typename Y_TYPE     = GLuint,
      typename Z_TYPE     = GLuint,
      typename W_TYPE     = GLuint>
    inline std::shared_ptr<VertexAttribI4ui<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    ,
      Z_TYPE    ,
      W_TYPE    >> sharedVertexAttribI4ui(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ,
        Z_TYPE     const&z    ,
        W_TYPE     const&w    ){
        return std::make_shared<VertexAttribI4ui<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    ,
          Z_TYPE    ,
          W_TYPE    >>(
              index,
              x    ,
              y    ,
              z    ,
              w    );
    }

    template<
      typename TARGET_TYPE = GLenum  ,
      typename INDEX_TYPE  = GLuint  ,
      typename DATA_TYPE   = GLfloat*>
    inline GetFloati_v<
      TARGET_TYPE,
      INDEX_TYPE ,
      DATA_TYPE  >* newGetFloati_v(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        DATA_TYPE   const&data  ){
        return new GetFloati_v<
          TARGET_TYPE,
          INDEX_TYPE ,
          DATA_TYPE  >(
              target,
              index ,
              data  );
    }
    template<
      typename TARGET_TYPE = GLenum  ,
      typename INDEX_TYPE  = GLuint  ,
      typename DATA_TYPE   = GLfloat*>
    inline std::shared_ptr<GetFloati_v<
      TARGET_TYPE,
      INDEX_TYPE ,
      DATA_TYPE  >> sharedGetFloati_v(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        DATA_TYPE   const&data  ){
        return std::make_shared<GetFloati_v<
          TARGET_TYPE,
          INDEX_TYPE ,
          DATA_TYPE  >>(
              target,
              index ,
              data  );
    }

    template<
      typename FUNC_TYPE = GLenum>
    inline DepthFunc<
      FUNC_TYPE>* newDepthFunc(
        FUNC_TYPE const&func){
        return new DepthFunc<
          FUNC_TYPE>(
              func);
    }
    template<
      typename FUNC_TYPE = GLenum>
    inline std::shared_ptr<DepthFunc<
      FUNC_TYPE>> sharedDepthFunc(
        FUNC_TYPE const&func){
        return std::make_shared<DepthFunc<
          FUNC_TYPE>>(
              func);
    }

    template<
      typename VAOBJ_TYPE = GLuint  ,
      typename INDEX_TYPE = GLuint  ,
      typename PNAME_TYPE = GLenum  ,
      typename PARAM_TYPE = GLint64*>
    inline GetVertexArrayIndexed64iv<
      VAOBJ_TYPE,
      INDEX_TYPE,
      PNAME_TYPE,
      PARAM_TYPE>* newGetVertexArrayIndexed64iv(
        VAOBJ_TYPE const&vaobj,
        INDEX_TYPE const&index,
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return new GetVertexArrayIndexed64iv<
          VAOBJ_TYPE,
          INDEX_TYPE,
          PNAME_TYPE,
          PARAM_TYPE>(
              vaobj,
              index,
              pname,
              param);
    }
    template<
      typename VAOBJ_TYPE = GLuint  ,
      typename INDEX_TYPE = GLuint  ,
      typename PNAME_TYPE = GLenum  ,
      typename PARAM_TYPE = GLint64*>
    inline std::shared_ptr<GetVertexArrayIndexed64iv<
      VAOBJ_TYPE,
      INDEX_TYPE,
      PNAME_TYPE,
      PARAM_TYPE>> sharedGetVertexArrayIndexed64iv(
        VAOBJ_TYPE const&vaobj,
        INDEX_TYPE const&index,
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return std::make_shared<GetVertexArrayIndexed64iv<
          VAOBJ_TYPE,
          INDEX_TYPE,
          PNAME_TYPE,
          PARAM_TYPE>>(
              vaobj,
              index,
              pname,
              param);
    }

    template<
      typename TARGET_TYPE = GLenum      ,
      typename PNAME_TYPE  = GLenum      ,
      typename PARAMS_TYPE = const GLint*>
    inline TexParameterIiv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newTexParameterIiv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new TexParameterIiv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum      ,
      typename PNAME_TYPE  = GLenum      ,
      typename PARAMS_TYPE = const GLint*>
    inline std::shared_ptr<TexParameterIiv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedTexParameterIiv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<TexParameterIiv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename MODE_TYPE = GLenum>
    inline BlendEquation<
      MODE_TYPE>* newBlendEquation(
        MODE_TYPE const&mode){
        return new BlendEquation<
          MODE_TYPE>(
              mode);
    }
    template<
      typename MODE_TYPE = GLenum>
    inline std::shared_ptr<BlendEquation<
      MODE_TYPE>> sharedBlendEquation(
        MODE_TYPE const&mode){
        return std::make_shared<BlendEquation<
          MODE_TYPE>>(
              mode);
    }

    template<
      typename RET_TYPE     = GLint        ,
      typename PROGRAM_TYPE = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    inline GetUniformLocation<
      RET_TYPE    ,
      PROGRAM_TYPE,
      NAME_TYPE   >* newGetUniformLocation(
        RET_TYPE     const&ret    ,
        PROGRAM_TYPE const&program,
        NAME_TYPE    const&name   ){
        return new GetUniformLocation<
          RET_TYPE    ,
          PROGRAM_TYPE,
          NAME_TYPE   >(
              ret    ,
              program,
              name   );
    }
    template<
      typename RET_TYPE     = GLint        ,
      typename PROGRAM_TYPE = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    inline std::shared_ptr<GetUniformLocation<
      RET_TYPE    ,
      PROGRAM_TYPE,
      NAME_TYPE   >> sharedGetUniformLocation(
        RET_TYPE     const&ret    ,
        PROGRAM_TYPE const&program,
        NAME_TYPE    const&name   ){
        return std::make_shared<GetUniformLocation<
          RET_TYPE    ,
          PROGRAM_TYPE,
          NAME_TYPE   >>(
              ret    ,
              program,
              name   );
    }

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline UniformMatrix2x4dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix2x4dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix2x4dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<UniformMatrix2x4dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix2x4dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix2x4dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename VAOBJ_TYPE          = GLuint   ,
      typename ATTRIBINDEX_TYPE    = GLuint   ,
      typename SIZE_TYPE           = GLint    ,
      typename TYPE_TYPE           = GLenum   ,
      typename NORMALIZED_TYPE     = GLboolean,
      typename RELATIVEOFFSET_TYPE = GLuint   >
    inline VertexArrayAttribFormat<
      VAOBJ_TYPE         ,
      ATTRIBINDEX_TYPE   ,
      SIZE_TYPE          ,
      TYPE_TYPE          ,
      NORMALIZED_TYPE    ,
      RELATIVEOFFSET_TYPE>* newVertexArrayAttribFormat(
        VAOBJ_TYPE          const&vaobj         ,
        ATTRIBINDEX_TYPE    const&attribindex   ,
        SIZE_TYPE           const&size          ,
        TYPE_TYPE           const&type          ,
        NORMALIZED_TYPE     const&normalized    ,
        RELATIVEOFFSET_TYPE const&relativeoffset){
        return new VertexArrayAttribFormat<
          VAOBJ_TYPE         ,
          ATTRIBINDEX_TYPE   ,
          SIZE_TYPE          ,
          TYPE_TYPE          ,
          NORMALIZED_TYPE    ,
          RELATIVEOFFSET_TYPE>(
              vaobj         ,
              attribindex   ,
              size          ,
              type          ,
              normalized    ,
              relativeoffset);
    }
    template<
      typename VAOBJ_TYPE          = GLuint   ,
      typename ATTRIBINDEX_TYPE    = GLuint   ,
      typename SIZE_TYPE           = GLint    ,
      typename TYPE_TYPE           = GLenum   ,
      typename NORMALIZED_TYPE     = GLboolean,
      typename RELATIVEOFFSET_TYPE = GLuint   >
    inline std::shared_ptr<VertexArrayAttribFormat<
      VAOBJ_TYPE         ,
      ATTRIBINDEX_TYPE   ,
      SIZE_TYPE          ,
      TYPE_TYPE          ,
      NORMALIZED_TYPE    ,
      RELATIVEOFFSET_TYPE>> sharedVertexArrayAttribFormat(
        VAOBJ_TYPE          const&vaobj         ,
        ATTRIBINDEX_TYPE    const&attribindex   ,
        SIZE_TYPE           const&size          ,
        TYPE_TYPE           const&type          ,
        NORMALIZED_TYPE     const&normalized    ,
        RELATIVEOFFSET_TYPE const&relativeoffset){
        return std::make_shared<VertexArrayAttribFormat<
          VAOBJ_TYPE         ,
          ATTRIBINDEX_TYPE   ,
          SIZE_TYPE          ,
          TYPE_TYPE          ,
          NORMALIZED_TYPE    ,
          RELATIVEOFFSET_TYPE>>(
              vaobj         ,
              attribindex   ,
              size          ,
              type          ,
              normalized    ,
              relativeoffset);
    }

    template<
      typename TARGET_TYPE    = GLenum     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename YOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename HEIGHT_TYPE    = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    inline CompressedTexSubImage2D<
      TARGET_TYPE   ,
      LEVEL_TYPE    ,
      XOFFSET_TYPE  ,
      YOFFSET_TYPE  ,
      WIDTH_TYPE    ,
      HEIGHT_TYPE   ,
      FORMAT_TYPE   ,
      IMAGESIZE_TYPE,
      DATA_TYPE     >* newCompressedTexSubImage2D(
        TARGET_TYPE    const&target   ,
        LEVEL_TYPE     const&level    ,
        XOFFSET_TYPE   const&xoffset  ,
        YOFFSET_TYPE   const&yoffset  ,
        WIDTH_TYPE     const&width    ,
        HEIGHT_TYPE    const&height   ,
        FORMAT_TYPE    const&format   ,
        IMAGESIZE_TYPE const&imageSize,
        DATA_TYPE      const&data     ){
        return new CompressedTexSubImage2D<
          TARGET_TYPE   ,
          LEVEL_TYPE    ,
          XOFFSET_TYPE  ,
          YOFFSET_TYPE  ,
          WIDTH_TYPE    ,
          HEIGHT_TYPE   ,
          FORMAT_TYPE   ,
          IMAGESIZE_TYPE,
          DATA_TYPE     >(
              target   ,
              level    ,
              xoffset  ,
              yoffset  ,
              width    ,
              height   ,
              format   ,
              imageSize,
              data     );
    }
    template<
      typename TARGET_TYPE    = GLenum     ,
      typename LEVEL_TYPE     = GLint      ,
      typename XOFFSET_TYPE   = GLint      ,
      typename YOFFSET_TYPE   = GLint      ,
      typename WIDTH_TYPE     = GLsizei    ,
      typename HEIGHT_TYPE    = GLsizei    ,
      typename FORMAT_TYPE    = GLenum     ,
      typename IMAGESIZE_TYPE = GLsizei    ,
      typename DATA_TYPE      = const void*>
    inline std::shared_ptr<CompressedTexSubImage2D<
      TARGET_TYPE   ,
      LEVEL_TYPE    ,
      XOFFSET_TYPE  ,
      YOFFSET_TYPE  ,
      WIDTH_TYPE    ,
      HEIGHT_TYPE   ,
      FORMAT_TYPE   ,
      IMAGESIZE_TYPE,
      DATA_TYPE     >> sharedCompressedTexSubImage2D(
        TARGET_TYPE    const&target   ,
        LEVEL_TYPE     const&level    ,
        XOFFSET_TYPE   const&xoffset  ,
        YOFFSET_TYPE   const&yoffset  ,
        WIDTH_TYPE     const&width    ,
        HEIGHT_TYPE    const&height   ,
        FORMAT_TYPE    const&format   ,
        IMAGESIZE_TYPE const&imageSize,
        DATA_TYPE      const&data     ){
        return std::make_shared<CompressedTexSubImage2D<
          TARGET_TYPE   ,
          LEVEL_TYPE    ,
          XOFFSET_TYPE  ,
          YOFFSET_TYPE  ,
          WIDTH_TYPE    ,
          HEIGHT_TYPE   ,
          FORMAT_TYPE   ,
          IMAGESIZE_TYPE,
          DATA_TYPE     >>(
              target   ,
              level    ,
              xoffset  ,
              yoffset  ,
              width    ,
              height   ,
              format   ,
              imageSize,
              data     );
    }

    template<
      typename FRAMEBUFFER_TYPE = GLuint       ,
      typename N_TYPE           = GLsizei      ,
      typename BUFS_TYPE        = const GLenum*>
    inline NamedFramebufferDrawBuffers<
      FRAMEBUFFER_TYPE,
      N_TYPE          ,
      BUFS_TYPE       >* newNamedFramebufferDrawBuffers(
        FRAMEBUFFER_TYPE const&framebuffer,
        N_TYPE           const&n          ,
        BUFS_TYPE        const&bufs       ){
        return new NamedFramebufferDrawBuffers<
          FRAMEBUFFER_TYPE,
          N_TYPE          ,
          BUFS_TYPE       >(
              framebuffer,
              n          ,
              bufs       );
    }
    template<
      typename FRAMEBUFFER_TYPE = GLuint       ,
      typename N_TYPE           = GLsizei      ,
      typename BUFS_TYPE        = const GLenum*>
    inline std::shared_ptr<NamedFramebufferDrawBuffers<
      FRAMEBUFFER_TYPE,
      N_TYPE          ,
      BUFS_TYPE       >> sharedNamedFramebufferDrawBuffers(
        FRAMEBUFFER_TYPE const&framebuffer,
        N_TYPE           const&n          ,
        BUFS_TYPE        const&bufs       ){
        return std::make_shared<NamedFramebufferDrawBuffers<
          FRAMEBUFFER_TYPE,
          N_TYPE          ,
          BUFS_TYPE       >>(
              framebuffer,
              n          ,
              bufs       );
    }


    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLushort*>
    inline VertexAttrib4usv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4usv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4usv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLushort*>
    inline std::shared_ptr<VertexAttrib4usv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4usv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4usv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename SHADERTYPE_TYPE = GLenum ,
      typename LOCATION_TYPE   = GLint  ,
      typename PARAMS_TYPE     = GLuint*>
    inline GetUniformSubroutineuiv<
      SHADERTYPE_TYPE,
      LOCATION_TYPE  ,
      PARAMS_TYPE    >* newGetUniformSubroutineuiv(
        SHADERTYPE_TYPE const&shadertype,
        LOCATION_TYPE   const&location  ,
        PARAMS_TYPE     const&params    ){
        return new GetUniformSubroutineuiv<
          SHADERTYPE_TYPE,
          LOCATION_TYPE  ,
          PARAMS_TYPE    >(
              shadertype,
              location  ,
              params    );
    }
    template<
      typename SHADERTYPE_TYPE = GLenum ,
      typename LOCATION_TYPE   = GLint  ,
      typename PARAMS_TYPE     = GLuint*>
    inline std::shared_ptr<GetUniformSubroutineuiv<
      SHADERTYPE_TYPE,
      LOCATION_TYPE  ,
      PARAMS_TYPE    >> sharedGetUniformSubroutineuiv(
        SHADERTYPE_TYPE const&shadertype,
        LOCATION_TYPE   const&location  ,
        PARAMS_TYPE     const&params    ){
        return std::make_shared<GetUniformSubroutineuiv<
          SHADERTYPE_TYPE,
          LOCATION_TYPE  ,
          PARAMS_TYPE    >>(
              shadertype,
              location  ,
              params    );
    }

    template<
      typename TARGET_TYPE               = GLenum   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    inline TexImage2DMultisample<
      TARGET_TYPE              ,
      SAMPLES_TYPE             ,
      INTERNALFORMAT_TYPE      ,
      WIDTH_TYPE               ,
      HEIGHT_TYPE              ,
      FIXEDSAMPLELOCATIONS_TYPE>* newTexImage2DMultisample(
        TARGET_TYPE               const&target              ,
        SAMPLES_TYPE              const&samples             ,
        INTERNALFORMAT_TYPE       const&internalformat      ,
        WIDTH_TYPE                const&width               ,
        HEIGHT_TYPE               const&height              ,
        FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
        return new TexImage2DMultisample<
          TARGET_TYPE              ,
          SAMPLES_TYPE             ,
          INTERNALFORMAT_TYPE      ,
          WIDTH_TYPE               ,
          HEIGHT_TYPE              ,
          FIXEDSAMPLELOCATIONS_TYPE>(
              target              ,
              samples             ,
              internalformat      ,
              width               ,
              height              ,
              fixedsamplelocations);
    }
    template<
      typename TARGET_TYPE               = GLenum   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    inline std::shared_ptr<TexImage2DMultisample<
      TARGET_TYPE              ,
      SAMPLES_TYPE             ,
      INTERNALFORMAT_TYPE      ,
      WIDTH_TYPE               ,
      HEIGHT_TYPE              ,
      FIXEDSAMPLELOCATIONS_TYPE>> sharedTexImage2DMultisample(
        TARGET_TYPE               const&target              ,
        SAMPLES_TYPE              const&samples             ,
        INTERNALFORMAT_TYPE       const&internalformat      ,
        WIDTH_TYPE                const&width               ,
        HEIGHT_TYPE               const&height              ,
        FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
        return std::make_shared<TexImage2DMultisample<
          TARGET_TYPE              ,
          SAMPLES_TYPE             ,
          INTERNALFORMAT_TYPE      ,
          WIDTH_TYPE               ,
          HEIGHT_TYPE              ,
          FIXEDSAMPLELOCATIONS_TYPE>>(
              target              ,
              samples             ,
              internalformat      ,
              width               ,
              height              ,
              fixedsamplelocations);
    }

    template<
      typename BINDINGINDEX_TYPE = GLuint  ,
      typename BUFFER_TYPE       = GLuint  ,
      typename OFFSET_TYPE       = GLintptr,
      typename STRIDE_TYPE       = GLsizei >
    inline BindVertexBuffer<
      BINDINGINDEX_TYPE,
      BUFFER_TYPE      ,
      OFFSET_TYPE      ,
      STRIDE_TYPE      >* newBindVertexBuffer(
        BINDINGINDEX_TYPE const&bindingindex,
        BUFFER_TYPE       const&buffer      ,
        OFFSET_TYPE       const&offset      ,
        STRIDE_TYPE       const&stride      ){
        return new BindVertexBuffer<
          BINDINGINDEX_TYPE,
          BUFFER_TYPE      ,
          OFFSET_TYPE      ,
          STRIDE_TYPE      >(
              bindingindex,
              buffer      ,
              offset      ,
              stride      );
    }
    template<
      typename BINDINGINDEX_TYPE = GLuint  ,
      typename BUFFER_TYPE       = GLuint  ,
      typename OFFSET_TYPE       = GLintptr,
      typename STRIDE_TYPE       = GLsizei >
    inline std::shared_ptr<BindVertexBuffer<
      BINDINGINDEX_TYPE,
      BUFFER_TYPE      ,
      OFFSET_TYPE      ,
      STRIDE_TYPE      >> sharedBindVertexBuffer(
        BINDINGINDEX_TYPE const&bindingindex,
        BUFFER_TYPE       const&buffer      ,
        OFFSET_TYPE       const&offset      ,
        STRIDE_TYPE       const&stride      ){
        return std::make_shared<BindVertexBuffer<
          BINDINGINDEX_TYPE,
          BUFFER_TYPE      ,
          OFFSET_TYPE      ,
          STRIDE_TYPE      >>(
              bindingindex,
              buffer      ,
              offset      ,
              stride      );
    }

    template<
      typename SOURCE_TYPE   = GLenum       ,
      typename TYPE_TYPE     = GLenum       ,
      typename ID_TYPE       = GLuint       ,
      typename SEVERITY_TYPE = GLenum       ,
      typename LENGTH_TYPE   = GLsizei      ,
      typename BUF_TYPE      = const GLchar*>
    inline DebugMessageInsert<
      SOURCE_TYPE  ,
      TYPE_TYPE    ,
      ID_TYPE      ,
      SEVERITY_TYPE,
      LENGTH_TYPE  ,
      BUF_TYPE     >* newDebugMessageInsert(
        SOURCE_TYPE   const&source  ,
        TYPE_TYPE     const&type    ,
        ID_TYPE       const&id      ,
        SEVERITY_TYPE const&severity,
        LENGTH_TYPE   const&length  ,
        BUF_TYPE      const&buf     ){
        return new DebugMessageInsert<
          SOURCE_TYPE  ,
          TYPE_TYPE    ,
          ID_TYPE      ,
          SEVERITY_TYPE,
          LENGTH_TYPE  ,
          BUF_TYPE     >(
              source  ,
              type    ,
              id      ,
              severity,
              length  ,
              buf     );
    }
    template<
      typename SOURCE_TYPE   = GLenum       ,
      typename TYPE_TYPE     = GLenum       ,
      typename ID_TYPE       = GLuint       ,
      typename SEVERITY_TYPE = GLenum       ,
      typename LENGTH_TYPE   = GLsizei      ,
      typename BUF_TYPE      = const GLchar*>
    inline std::shared_ptr<DebugMessageInsert<
      SOURCE_TYPE  ,
      TYPE_TYPE    ,
      ID_TYPE      ,
      SEVERITY_TYPE,
      LENGTH_TYPE  ,
      BUF_TYPE     >> sharedDebugMessageInsert(
        SOURCE_TYPE   const&source  ,
        TYPE_TYPE     const&type    ,
        ID_TYPE       const&id      ,
        SEVERITY_TYPE const&severity,
        LENGTH_TYPE   const&length  ,
        BUF_TYPE      const&buf     ){
        return std::make_shared<DebugMessageInsert<
          SOURCE_TYPE  ,
          TYPE_TYPE    ,
          ID_TYPE      ,
          SEVERITY_TYPE,
          LENGTH_TYPE  ,
          BUF_TYPE     >>(
              source  ,
              type    ,
              id      ,
              severity,
              length  ,
              buf     );
    }

    template<
      typename N_TYPE        = GLsizei,
      typename SAMPLERS_TYPE = GLuint*>
    inline CreateSamplers<
      N_TYPE       ,
      SAMPLERS_TYPE>* newCreateSamplers(
        N_TYPE        const&n       ,
        SAMPLERS_TYPE const&samplers){
        return new CreateSamplers<
          N_TYPE       ,
          SAMPLERS_TYPE>(
              n       ,
              samplers);
    }
    template<
      typename N_TYPE        = GLsizei,
      typename SAMPLERS_TYPE = GLuint*>
    inline std::shared_ptr<CreateSamplers<
      N_TYPE       ,
      SAMPLERS_TYPE>> sharedCreateSamplers(
        N_TYPE        const&n       ,
        SAMPLERS_TYPE const&samplers){
        return std::make_shared<CreateSamplers<
          N_TYPE       ,
          SAMPLERS_TYPE>>(
              n       ,
              samplers);
    }

    template<
      typename PROGRAM_TYPE          = GLuint       ,
      typename PROGRAMINTERFACE_TYPE = GLenum       ,
      typename INDEX_TYPE            = GLuint       ,
      typename PROPCOUNT_TYPE        = GLsizei      ,
      typename PROPS_TYPE            = const GLenum*,
      typename BUFSIZE_TYPE          = GLsizei      ,
      typename LENGTH_TYPE           = GLsizei*     ,
      typename PARAMS_TYPE           = GLint*       >
    inline GetProgramResourceiv<
      PROGRAM_TYPE         ,
      PROGRAMINTERFACE_TYPE,
      INDEX_TYPE           ,
      PROPCOUNT_TYPE       ,
      PROPS_TYPE           ,
      BUFSIZE_TYPE         ,
      LENGTH_TYPE          ,
      PARAMS_TYPE          >* newGetProgramResourceiv(
        PROGRAM_TYPE          const&program         ,
        PROGRAMINTERFACE_TYPE const&programInterface,
        INDEX_TYPE            const&index           ,
        PROPCOUNT_TYPE        const&propCount       ,
        PROPS_TYPE            const&props           ,
        BUFSIZE_TYPE          const&bufSize         ,
        LENGTH_TYPE           const&length          ,
        PARAMS_TYPE           const&params          ){
        return new GetProgramResourceiv<
          PROGRAM_TYPE         ,
          PROGRAMINTERFACE_TYPE,
          INDEX_TYPE           ,
          PROPCOUNT_TYPE       ,
          PROPS_TYPE           ,
          BUFSIZE_TYPE         ,
          LENGTH_TYPE          ,
          PARAMS_TYPE          >(
              program         ,
              programInterface,
              index           ,
              propCount       ,
              props           ,
              bufSize         ,
              length          ,
              params          );
    }
    template<
      typename PROGRAM_TYPE          = GLuint       ,
      typename PROGRAMINTERFACE_TYPE = GLenum       ,
      typename INDEX_TYPE            = GLuint       ,
      typename PROPCOUNT_TYPE        = GLsizei      ,
      typename PROPS_TYPE            = const GLenum*,
      typename BUFSIZE_TYPE          = GLsizei      ,
      typename LENGTH_TYPE           = GLsizei*     ,
      typename PARAMS_TYPE           = GLint*       >
    inline std::shared_ptr<GetProgramResourceiv<
      PROGRAM_TYPE         ,
      PROGRAMINTERFACE_TYPE,
      INDEX_TYPE           ,
      PROPCOUNT_TYPE       ,
      PROPS_TYPE           ,
      BUFSIZE_TYPE         ,
      LENGTH_TYPE          ,
      PARAMS_TYPE          >> sharedGetProgramResourceiv(
        PROGRAM_TYPE          const&program         ,
        PROGRAMINTERFACE_TYPE const&programInterface,
        INDEX_TYPE            const&index           ,
        PROPCOUNT_TYPE        const&propCount       ,
        PROPS_TYPE            const&props           ,
        BUFSIZE_TYPE          const&bufSize         ,
        LENGTH_TYPE           const&length          ,
        PARAMS_TYPE           const&params          ){
        return std::make_shared<GetProgramResourceiv<
          PROGRAM_TYPE         ,
          PROGRAMINTERFACE_TYPE,
          INDEX_TYPE           ,
          PROPCOUNT_TYPE       ,
          PROPS_TYPE           ,
          BUFSIZE_TYPE         ,
          LENGTH_TYPE          ,
          PARAMS_TYPE          >>(
              program         ,
              programInterface,
              index           ,
              propCount       ,
              props           ,
              bufSize         ,
              length          ,
              params          );
    }

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename DATA_TYPE           = const void*>
    inline ClearBufferData<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      DATA_TYPE          >* newClearBufferData(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        DATA_TYPE           const&data          ){
        return new ClearBufferData<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          DATA_TYPE          >(
              target        ,
              internalformat,
              format        ,
              type          ,
              data          );
    }
    template<
      typename TARGET_TYPE         = GLenum     ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename DATA_TYPE           = const void*>
    inline std::shared_ptr<ClearBufferData<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      DATA_TYPE          >> sharedClearBufferData(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        DATA_TYPE           const&data          ){
        return std::make_shared<ClearBufferData<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          DATA_TYPE          >>(
              target        ,
              internalformat,
              format        ,
              type          ,
              data          );
    }

    template<
      typename PRIMITIVEMODE_TYPE = GLenum>
    inline BeginTransformFeedback<
      PRIMITIVEMODE_TYPE>* newBeginTransformFeedback(
        PRIMITIVEMODE_TYPE const&primitiveMode){
        return new BeginTransformFeedback<
          PRIMITIVEMODE_TYPE>(
              primitiveMode);
    }
    template<
      typename PRIMITIVEMODE_TYPE = GLenum>
    inline std::shared_ptr<BeginTransformFeedback<
      PRIMITIVEMODE_TYPE>> sharedBeginTransformFeedback(
        PRIMITIVEMODE_TYPE const&primitiveMode){
        return std::make_shared<BeginTransformFeedback<
          PRIMITIVEMODE_TYPE>>(
              primitiveMode);
    }

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline VertexAttribI1iv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribI1iv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribI1iv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline std::shared_ptr<VertexAttribI1iv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribI1iv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribI1iv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename RET_TYPE     = GLboolean,
      typename SAMPLER_TYPE = GLuint   >
    inline IsSampler<
      RET_TYPE    ,
      SAMPLER_TYPE>* newIsSampler(
        RET_TYPE     const&ret    ,
        SAMPLER_TYPE const&sampler){
        return new IsSampler<
          RET_TYPE    ,
          SAMPLER_TYPE>(
              ret    ,
              sampler);
    }
    template<
      typename RET_TYPE     = GLboolean,
      typename SAMPLER_TYPE = GLuint   >
    inline std::shared_ptr<IsSampler<
      RET_TYPE    ,
      SAMPLER_TYPE>> sharedIsSampler(
        RET_TYPE     const&ret    ,
        SAMPLER_TYPE const&sampler){
        return std::make_shared<IsSampler<
          RET_TYPE    ,
          SAMPLER_TYPE>>(
              ret    ,
              sampler);
    }

    template<
      typename INDEX_TYPE   = GLuint,
      typename DIVISOR_TYPE = GLuint>
    inline VertexAttribDivisor<
      INDEX_TYPE  ,
      DIVISOR_TYPE>* newVertexAttribDivisor(
        INDEX_TYPE   const&index  ,
        DIVISOR_TYPE const&divisor){
        return new VertexAttribDivisor<
          INDEX_TYPE  ,
          DIVISOR_TYPE>(
              index  ,
              divisor);
    }
    template<
      typename INDEX_TYPE   = GLuint,
      typename DIVISOR_TYPE = GLuint>
    inline std::shared_ptr<VertexAttribDivisor<
      INDEX_TYPE  ,
      DIVISOR_TYPE>> sharedVertexAttribDivisor(
        INDEX_TYPE   const&index  ,
        DIVISOR_TYPE const&divisor){
        return std::make_shared<VertexAttribDivisor<
          INDEX_TYPE  ,
          DIVISOR_TYPE>>(
              index  ,
              divisor);
    }

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    inline GetCompressedTextureImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      BUFSIZE_TYPE,
      PIXELS_TYPE >* newGetCompressedTextureImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        BUFSIZE_TYPE const&bufSize,
        PIXELS_TYPE  const&pixels ){
        return new GetCompressedTextureImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          BUFSIZE_TYPE,
          PIXELS_TYPE >(
              texture,
              level  ,
              bufSize,
              pixels );
    }
    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    inline std::shared_ptr<GetCompressedTextureImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      BUFSIZE_TYPE,
      PIXELS_TYPE >> sharedGetCompressedTextureImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        BUFSIZE_TYPE const&bufSize,
        PIXELS_TYPE  const&pixels ){
        return std::make_shared<GetCompressedTextureImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          BUFSIZE_TYPE,
          PIXELS_TYPE >>(
              texture,
              level  ,
              bufSize,
              pixels );
    }

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename IMAGESIZE_TYPE      = GLsizei    ,
      typename DATA_TYPE           = const void*>
    inline CompressedTexImage1D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      BORDER_TYPE        ,
      IMAGESIZE_TYPE     ,
      DATA_TYPE          >* newCompressedTexImage1D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        BORDER_TYPE         const&border        ,
        IMAGESIZE_TYPE      const&imageSize     ,
        DATA_TYPE           const&data          ){
        return new CompressedTexImage1D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          BORDER_TYPE        ,
          IMAGESIZE_TYPE     ,
          DATA_TYPE          >(
              target        ,
              level         ,
              internalformat,
              width         ,
              border        ,
              imageSize     ,
              data          );
    }
    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename IMAGESIZE_TYPE      = GLsizei    ,
      typename DATA_TYPE           = const void*>
    inline std::shared_ptr<CompressedTexImage1D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      BORDER_TYPE        ,
      IMAGESIZE_TYPE     ,
      DATA_TYPE          >> sharedCompressedTexImage1D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        BORDER_TYPE         const&border        ,
        IMAGESIZE_TYPE      const&imageSize     ,
        DATA_TYPE           const&data          ){
        return std::make_shared<CompressedTexImage1D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          BORDER_TYPE        ,
          IMAGESIZE_TYPE     ,
          DATA_TYPE          >>(
              target        ,
              level         ,
              internalformat,
              width         ,
              border        ,
              imageSize     ,
              data          );
    }

    template<
      typename N_TYPE   = GLsizei      ,
      typename IDS_TYPE = const GLuint*>
    inline DeleteTransformFeedbacks<
      N_TYPE  ,
      IDS_TYPE>* newDeleteTransformFeedbacks(
        N_TYPE   const&n  ,
        IDS_TYPE const&ids){
        return new DeleteTransformFeedbacks<
          N_TYPE  ,
          IDS_TYPE>(
              n  ,
              ids);
    }
    template<
      typename N_TYPE   = GLsizei      ,
      typename IDS_TYPE = const GLuint*>
    inline std::shared_ptr<DeleteTransformFeedbacks<
      N_TYPE  ,
      IDS_TYPE>> sharedDeleteTransformFeedbacks(
        N_TYPE   const&n  ,
        IDS_TYPE const&ids){
        return std::make_shared<DeleteTransformFeedbacks<
          N_TYPE  ,
          IDS_TYPE>>(
              n  ,
              ids);
    }

    template<
      typename TARGET_TYPE  = GLenum ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei>
    inline CopyTexSubImage1D<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  >* newCopyTexSubImage1D(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ){
        return new CopyTexSubImage1D<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  >(
              target ,
              level  ,
              xoffset,
              x      ,
              y      ,
              width  );
    }
    template<
      typename TARGET_TYPE  = GLenum ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei>
    inline std::shared_ptr<CopyTexSubImage1D<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  >> sharedCopyTexSubImage1D(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ){
        return std::make_shared<CopyTexSubImage1D<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  >>(
              target ,
              level  ,
              xoffset,
              x      ,
              y      ,
              width  );
    }

    template<
      typename MODE_TYPE       = GLenum     ,
      typename START_TYPE      = GLuint     ,
      typename END_TYPE        = GLuint     ,
      typename COUNT_TYPE      = GLsizei    ,
      typename TYPE_TYPE       = GLenum     ,
      typename INDICES_TYPE    = const void*,
      typename BASEVERTEX_TYPE = GLint      >
    inline DrawRangeElementsBaseVertex<
      MODE_TYPE      ,
      START_TYPE     ,
      END_TYPE       ,
      COUNT_TYPE     ,
      TYPE_TYPE      ,
      INDICES_TYPE   ,
      BASEVERTEX_TYPE>* newDrawRangeElementsBaseVertex(
        MODE_TYPE       const&mode      ,
        START_TYPE      const&start     ,
        END_TYPE        const&end       ,
        COUNT_TYPE      const&count     ,
        TYPE_TYPE       const&type      ,
        INDICES_TYPE    const&indices   ,
        BASEVERTEX_TYPE const&basevertex){
        return new DrawRangeElementsBaseVertex<
          MODE_TYPE      ,
          START_TYPE     ,
          END_TYPE       ,
          COUNT_TYPE     ,
          TYPE_TYPE      ,
          INDICES_TYPE   ,
          BASEVERTEX_TYPE>(
              mode      ,
              start     ,
              end       ,
              count     ,
              type      ,
              indices   ,
              basevertex);
    }
    template<
      typename MODE_TYPE       = GLenum     ,
      typename START_TYPE      = GLuint     ,
      typename END_TYPE        = GLuint     ,
      typename COUNT_TYPE      = GLsizei    ,
      typename TYPE_TYPE       = GLenum     ,
      typename INDICES_TYPE    = const void*,
      typename BASEVERTEX_TYPE = GLint      >
    inline std::shared_ptr<DrawRangeElementsBaseVertex<
      MODE_TYPE      ,
      START_TYPE     ,
      END_TYPE       ,
      COUNT_TYPE     ,
      TYPE_TYPE      ,
      INDICES_TYPE   ,
      BASEVERTEX_TYPE>> sharedDrawRangeElementsBaseVertex(
        MODE_TYPE       const&mode      ,
        START_TYPE      const&start     ,
        END_TYPE        const&end       ,
        COUNT_TYPE      const&count     ,
        TYPE_TYPE       const&type      ,
        INDICES_TYPE    const&indices   ,
        BASEVERTEX_TYPE const&basevertex){
        return std::make_shared<DrawRangeElementsBaseVertex<
          MODE_TYPE      ,
          START_TYPE     ,
          END_TYPE       ,
          COUNT_TYPE     ,
          TYPE_TYPE      ,
          INDICES_TYPE   ,
          BASEVERTEX_TYPE>>(
              mode      ,
              start     ,
              end       ,
              count     ,
              type      ,
              indices   ,
              basevertex);
    }

    template<
      typename RET_TYPE    = GLenum,
      typename TARGET_TYPE = GLenum>
    inline CheckFramebufferStatus<
      RET_TYPE   ,
      TARGET_TYPE>* newCheckFramebufferStatus(
        RET_TYPE    const&ret   ,
        TARGET_TYPE const&target){
        return new CheckFramebufferStatus<
          RET_TYPE   ,
          TARGET_TYPE>(
              ret   ,
              target);
    }
    template<
      typename RET_TYPE    = GLenum,
      typename TARGET_TYPE = GLenum>
    inline std::shared_ptr<CheckFramebufferStatus<
      RET_TYPE   ,
      TARGET_TYPE>> sharedCheckFramebufferStatus(
        RET_TYPE    const&ret   ,
        TARGET_TYPE const&target){
        return std::make_shared<CheckFramebufferStatus<
          RET_TYPE   ,
          TARGET_TYPE>>(
              ret   ,
              target);
    }


    template<
      typename PROGRAM_TYPE = GLuint       ,
      typename INDEX_TYPE   = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    inline BindAttribLocation<
      PROGRAM_TYPE,
      INDEX_TYPE  ,
      NAME_TYPE   >* newBindAttribLocation(
        PROGRAM_TYPE const&program,
        INDEX_TYPE   const&index  ,
        NAME_TYPE    const&name   ){
        return new BindAttribLocation<
          PROGRAM_TYPE,
          INDEX_TYPE  ,
          NAME_TYPE   >(
              program,
              index  ,
              name   );
    }
    template<
      typename PROGRAM_TYPE = GLuint       ,
      typename INDEX_TYPE   = GLuint       ,
      typename NAME_TYPE    = const GLchar*>
    inline std::shared_ptr<BindAttribLocation<
      PROGRAM_TYPE,
      INDEX_TYPE  ,
      NAME_TYPE   >> sharedBindAttribLocation(
        PROGRAM_TYPE const&program,
        INDEX_TYPE   const&index  ,
        NAME_TYPE    const&name   ){
        return std::make_shared<BindAttribLocation<
          PROGRAM_TYPE,
          INDEX_TYPE  ,
          NAME_TYPE   >>(
              program,
              index  ,
              name   );
    }

    template<
      typename UNIT_TYPE    = GLuint   ,
      typename TEXTURE_TYPE = GLuint   ,
      typename LEVEL_TYPE   = GLint    ,
      typename LAYERED_TYPE = GLboolean,
      typename LAYER_TYPE   = GLint    ,
      typename ACCESS_TYPE  = GLenum   ,
      typename FORMAT_TYPE  = GLenum   >
    inline BindImageTexture<
      UNIT_TYPE   ,
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      LAYERED_TYPE,
      LAYER_TYPE  ,
      ACCESS_TYPE ,
      FORMAT_TYPE >* newBindImageTexture(
        UNIT_TYPE    const&unit   ,
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        LAYERED_TYPE const&layered,
        LAYER_TYPE   const&layer  ,
        ACCESS_TYPE  const&access ,
        FORMAT_TYPE  const&format ){
        return new BindImageTexture<
          UNIT_TYPE   ,
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          LAYERED_TYPE,
          LAYER_TYPE  ,
          ACCESS_TYPE ,
          FORMAT_TYPE >(
              unit   ,
              texture,
              level  ,
              layered,
              layer  ,
              access ,
              format );
    }
    template<
      typename UNIT_TYPE    = GLuint   ,
      typename TEXTURE_TYPE = GLuint   ,
      typename LEVEL_TYPE   = GLint    ,
      typename LAYERED_TYPE = GLboolean,
      typename LAYER_TYPE   = GLint    ,
      typename ACCESS_TYPE  = GLenum   ,
      typename FORMAT_TYPE  = GLenum   >
    inline std::shared_ptr<BindImageTexture<
      UNIT_TYPE   ,
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      LAYERED_TYPE,
      LAYER_TYPE  ,
      ACCESS_TYPE ,
      FORMAT_TYPE >> sharedBindImageTexture(
        UNIT_TYPE    const&unit   ,
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        LAYERED_TYPE const&layered,
        LAYER_TYPE   const&layer  ,
        ACCESS_TYPE  const&access ,
        FORMAT_TYPE  const&format ){
        return std::make_shared<BindImageTexture<
          UNIT_TYPE   ,
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          LAYERED_TYPE,
          LAYER_TYPE  ,
          ACCESS_TYPE ,
          FORMAT_TYPE >>(
              unit   ,
              texture,
              level  ,
              layered,
              layer  ,
              access ,
              format );
    }

    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline UniformMatrix2dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix2dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix2dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<UniformMatrix2dv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix2dv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix2dv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename PROGRAM_TYPE  = GLuint       ,
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline ProgramUniform2uiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform2uiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform2uiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint       ,
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline std::shared_ptr<ProgramUniform2uiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform2uiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform2uiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename MODE_TYPE    = GLenum     ,
      typename START_TYPE   = GLuint     ,
      typename END_TYPE     = GLuint     ,
      typename COUNT_TYPE   = GLsizei    ,
      typename TYPE_TYPE    = GLenum     ,
      typename INDICES_TYPE = const void*>
    inline DrawRangeElements<
      MODE_TYPE   ,
      START_TYPE  ,
      END_TYPE    ,
      COUNT_TYPE  ,
      TYPE_TYPE   ,
      INDICES_TYPE>* newDrawRangeElements(
        MODE_TYPE    const&mode   ,
        START_TYPE   const&start  ,
        END_TYPE     const&end    ,
        COUNT_TYPE   const&count  ,
        TYPE_TYPE    const&type   ,
        INDICES_TYPE const&indices){
        return new DrawRangeElements<
          MODE_TYPE   ,
          START_TYPE  ,
          END_TYPE    ,
          COUNT_TYPE  ,
          TYPE_TYPE   ,
          INDICES_TYPE>(
              mode   ,
              start  ,
              end    ,
              count  ,
              type   ,
              indices);
    }
    template<
      typename MODE_TYPE    = GLenum     ,
      typename START_TYPE   = GLuint     ,
      typename END_TYPE     = GLuint     ,
      typename COUNT_TYPE   = GLsizei    ,
      typename TYPE_TYPE    = GLenum     ,
      typename INDICES_TYPE = const void*>
    inline std::shared_ptr<DrawRangeElements<
      MODE_TYPE   ,
      START_TYPE  ,
      END_TYPE    ,
      COUNT_TYPE  ,
      TYPE_TYPE   ,
      INDICES_TYPE>> sharedDrawRangeElements(
        MODE_TYPE    const&mode   ,
        START_TYPE   const&start  ,
        END_TYPE     const&end    ,
        COUNT_TYPE   const&count  ,
        TYPE_TYPE    const&type   ,
        INDICES_TYPE const&indices){
        return std::make_shared<DrawRangeElements<
          MODE_TYPE   ,
          START_TYPE  ,
          END_TYPE    ,
          COUNT_TYPE  ,
          TYPE_TYPE   ,
          INDICES_TYPE>>(
              mode   ,
              start  ,
              end    ,
              count  ,
              type   ,
              indices);
    }

    template<
      typename ID_TYPE     = GLuint ,
      typename PNAME_TYPE  = GLenum ,
      typename PARAMS_TYPE = GLuint*>
    inline GetQueryObjectuiv<
      ID_TYPE    ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetQueryObjectuiv(
        ID_TYPE     const&id    ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetQueryObjectuiv<
          ID_TYPE    ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              id    ,
              pname ,
              params);
    }
    template<
      typename ID_TYPE     = GLuint ,
      typename PNAME_TYPE  = GLenum ,
      typename PARAMS_TYPE = GLuint*>
    inline std::shared_ptr<GetQueryObjectuiv<
      ID_TYPE    ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetQueryObjectuiv(
        ID_TYPE     const&id    ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetQueryObjectuiv<
          ID_TYPE    ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              id    ,
              pname ,
              params);
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint,
      typename BUFFER_TYPE = GLuint>
    inline BindBufferBase<
      TARGET_TYPE,
      INDEX_TYPE ,
      BUFFER_TYPE>* newBindBufferBase(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        BUFFER_TYPE const&buffer){
        return new BindBufferBase<
          TARGET_TYPE,
          INDEX_TYPE ,
          BUFFER_TYPE>(
              target,
              index ,
              buffer);
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint,
      typename BUFFER_TYPE = GLuint>
    inline std::shared_ptr<BindBufferBase<
      TARGET_TYPE,
      INDEX_TYPE ,
      BUFFER_TYPE>> sharedBindBufferBase(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ,
        BUFFER_TYPE const&buffer){
        return std::make_shared<BindBufferBase<
          TARGET_TYPE,
          INDEX_TYPE ,
          BUFFER_TYPE>>(
              target,
              index ,
              buffer);
    }

    template<
      typename PROGRAM_TYPE = GLuint  ,
      typename INDEX_TYPE   = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename SIZE_TYPE    = GLint*  ,
      typename TYPE_TYPE    = GLenum* ,
      typename NAME_TYPE    = GLchar* >
    inline GetActiveUniform<
      PROGRAM_TYPE,
      INDEX_TYPE  ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      SIZE_TYPE   ,
      TYPE_TYPE   ,
      NAME_TYPE   >* newGetActiveUniform(
        PROGRAM_TYPE const&program,
        INDEX_TYPE   const&index  ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        SIZE_TYPE    const&size   ,
        TYPE_TYPE    const&type   ,
        NAME_TYPE    const&name   ){
        return new GetActiveUniform<
          PROGRAM_TYPE,
          INDEX_TYPE  ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          SIZE_TYPE   ,
          TYPE_TYPE   ,
          NAME_TYPE   >(
              program,
              index  ,
              bufSize,
              length ,
              size   ,
              type   ,
              name   );
    }
    template<
      typename PROGRAM_TYPE = GLuint  ,
      typename INDEX_TYPE   = GLuint  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename SIZE_TYPE    = GLint*  ,
      typename TYPE_TYPE    = GLenum* ,
      typename NAME_TYPE    = GLchar* >
    inline std::shared_ptr<GetActiveUniform<
      PROGRAM_TYPE,
      INDEX_TYPE  ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      SIZE_TYPE   ,
      TYPE_TYPE   ,
      NAME_TYPE   >> sharedGetActiveUniform(
        PROGRAM_TYPE const&program,
        INDEX_TYPE   const&index  ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        SIZE_TYPE    const&size   ,
        TYPE_TYPE    const&type   ,
        NAME_TYPE    const&name   ){
        return std::make_shared<GetActiveUniform<
          PROGRAM_TYPE,
          INDEX_TYPE  ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          SIZE_TYPE   ,
          TYPE_TYPE   ,
          NAME_TYPE   >>(
              program,
              index  ,
              bufSize,
              length ,
              size   ,
              type   ,
              name   );
    }

    template<
      typename TARGET_TYPE = GLenum     ,
      typename OFFSET_TYPE = GLintptr   ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*>
    inline BufferSubData<
      TARGET_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  >* newBufferSubData(
        TARGET_TYPE const&target,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ){
        return new BufferSubData<
          TARGET_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  >(
              target,
              offset,
              size  ,
              data  );
    }
    template<
      typename TARGET_TYPE = GLenum     ,
      typename OFFSET_TYPE = GLintptr   ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*>
    inline std::shared_ptr<BufferSubData<
      TARGET_TYPE,
      OFFSET_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  >> sharedBufferSubData(
        TARGET_TYPE const&target,
        OFFSET_TYPE const&offset,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ){
        return std::make_shared<BufferSubData<
          TARGET_TYPE,
          OFFSET_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  >>(
              target,
              offset,
              size  ,
              data  );
    }

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline VertexAttrib4iv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4iv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4iv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline std::shared_ptr<VertexAttrib4iv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4iv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4iv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename PROGRAM_TYPE  = GLuint       ,
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline ProgramUniform1uiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform1uiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform1uiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint       ,
      typename LOCATION_TYPE = GLint        ,
      typename COUNT_TYPE    = GLsizei      ,
      typename VALUE_TYPE    = const GLuint*>
    inline std::shared_ptr<ProgramUniform1uiv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform1uiv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform1uiv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint >
    inline FramebufferTexture<
      TARGET_TYPE    ,
      ATTACHMENT_TYPE,
      TEXTURE_TYPE   ,
      LEVEL_TYPE     >* newFramebufferTexture(
        TARGET_TYPE     const&target    ,
        ATTACHMENT_TYPE const&attachment,
        TEXTURE_TYPE    const&texture   ,
        LEVEL_TYPE      const&level     ){
        return new FramebufferTexture<
          TARGET_TYPE    ,
          ATTACHMENT_TYPE,
          TEXTURE_TYPE   ,
          LEVEL_TYPE     >(
              target    ,
              attachment,
              texture   ,
              level     );
    }
    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint >
    inline std::shared_ptr<FramebufferTexture<
      TARGET_TYPE    ,
      ATTACHMENT_TYPE,
      TEXTURE_TYPE   ,
      LEVEL_TYPE     >> sharedFramebufferTexture(
        TARGET_TYPE     const&target    ,
        ATTACHMENT_TYPE const&attachment,
        TEXTURE_TYPE    const&texture   ,
        LEVEL_TYPE      const&level     ){
        return std::make_shared<FramebufferTexture<
          TARGET_TYPE    ,
          ATTACHMENT_TYPE,
          TEXTURE_TYPE   ,
          LEVEL_TYPE     >>(
              target    ,
              attachment,
              texture   ,
              level     );
    }

    template<
      typename BUF_TYPE      = GLuint,
      typename SRCRGB_TYPE   = GLenum,
      typename DSTRGB_TYPE   = GLenum,
      typename SRCALPHA_TYPE = GLenum,
      typename DSTALPHA_TYPE = GLenum>
    inline BlendFuncSeparatei<
      BUF_TYPE     ,
      SRCRGB_TYPE  ,
      DSTRGB_TYPE  ,
      SRCALPHA_TYPE,
      DSTALPHA_TYPE>* newBlendFuncSeparatei(
        BUF_TYPE      const&buf     ,
        SRCRGB_TYPE   const&srcRGB  ,
        DSTRGB_TYPE   const&dstRGB  ,
        SRCALPHA_TYPE const&srcAlpha,
        DSTALPHA_TYPE const&dstAlpha){
        return new BlendFuncSeparatei<
          BUF_TYPE     ,
          SRCRGB_TYPE  ,
          DSTRGB_TYPE  ,
          SRCALPHA_TYPE,
          DSTALPHA_TYPE>(
              buf     ,
              srcRGB  ,
              dstRGB  ,
              srcAlpha,
              dstAlpha);
    }
    template<
      typename BUF_TYPE      = GLuint,
      typename SRCRGB_TYPE   = GLenum,
      typename DSTRGB_TYPE   = GLenum,
      typename SRCALPHA_TYPE = GLenum,
      typename DSTALPHA_TYPE = GLenum>
    inline std::shared_ptr<BlendFuncSeparatei<
      BUF_TYPE     ,
      SRCRGB_TYPE  ,
      DSTRGB_TYPE  ,
      SRCALPHA_TYPE,
      DSTALPHA_TYPE>> sharedBlendFuncSeparatei(
        BUF_TYPE      const&buf     ,
        SRCRGB_TYPE   const&srcRGB  ,
        DSTRGB_TYPE   const&dstRGB  ,
        SRCALPHA_TYPE const&srcAlpha,
        DSTALPHA_TYPE const&dstAlpha){
        return std::make_shared<BlendFuncSeparatei<
          BUF_TYPE     ,
          SRCRGB_TYPE  ,
          DSTRGB_TYPE  ,
          SRCALPHA_TYPE,
          DSTALPHA_TYPE>>(
              buf     ,
              srcRGB  ,
              dstRGB  ,
              srcAlpha,
              dstAlpha);
    }

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline ProgramUniformMatrix4x2fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix4x2fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix4x2fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<ProgramUniformMatrix4x2fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix4x2fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix4x2fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename ID_TYPE     = GLuint   ,
      typename PNAME_TYPE  = GLenum   ,
      typename PARAMS_TYPE = GLuint64*>
    inline GetQueryObjectui64v<
      ID_TYPE    ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetQueryObjectui64v(
        ID_TYPE     const&id    ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetQueryObjectui64v<
          ID_TYPE    ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              id    ,
              pname ,
              params);
    }
    template<
      typename ID_TYPE     = GLuint   ,
      typename PNAME_TYPE  = GLenum   ,
      typename PARAMS_TYPE = GLuint64*>
    inline std::shared_ptr<GetQueryObjectui64v<
      ID_TYPE    ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetQueryObjectui64v(
        ID_TYPE     const&id    ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetQueryObjectui64v<
          ID_TYPE    ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              id    ,
              pname ,
              params);
    }

    template<
      typename MODE_TYPE      = GLenum        ,
      typename FIRST_TYPE     = const GLint*  ,
      typename COUNT_TYPE     = const GLsizei*,
      typename DRAWCOUNT_TYPE = GLsizei       >
    inline MultiDrawArrays<
      MODE_TYPE     ,
      FIRST_TYPE    ,
      COUNT_TYPE    ,
      DRAWCOUNT_TYPE>* newMultiDrawArrays(
        MODE_TYPE      const&mode     ,
        FIRST_TYPE     const&first    ,
        COUNT_TYPE     const&count    ,
        DRAWCOUNT_TYPE const&drawcount){
        return new MultiDrawArrays<
          MODE_TYPE     ,
          FIRST_TYPE    ,
          COUNT_TYPE    ,
          DRAWCOUNT_TYPE>(
              mode     ,
              first    ,
              count    ,
              drawcount);
    }
    template<
      typename MODE_TYPE      = GLenum        ,
      typename FIRST_TYPE     = const GLint*  ,
      typename COUNT_TYPE     = const GLsizei*,
      typename DRAWCOUNT_TYPE = GLsizei       >
    inline std::shared_ptr<MultiDrawArrays<
      MODE_TYPE     ,
      FIRST_TYPE    ,
      COUNT_TYPE    ,
      DRAWCOUNT_TYPE>> sharedMultiDrawArrays(
        MODE_TYPE      const&mode     ,
        FIRST_TYPE     const&first    ,
        COUNT_TYPE     const&count    ,
        DRAWCOUNT_TYPE const&drawcount){
        return std::make_shared<MultiDrawArrays<
          MODE_TYPE     ,
          FIRST_TYPE    ,
          COUNT_TYPE    ,
          DRAWCOUNT_TYPE>>(
              mode     ,
              first    ,
              count    ,
              drawcount);
    }

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline VertexAttribI2iv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribI2iv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribI2iv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline std::shared_ptr<VertexAttribI2iv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribI2iv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribI2iv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename SHADERTYPE_TYPE    = GLenum,
      typename PRECISIONTYPE_TYPE = GLenum,
      typename RANGE_TYPE         = GLint*,
      typename PRECISION_TYPE     = GLint*>
    inline GetShaderPrecisionFormat<
      SHADERTYPE_TYPE   ,
      PRECISIONTYPE_TYPE,
      RANGE_TYPE        ,
      PRECISION_TYPE    >* newGetShaderPrecisionFormat(
        SHADERTYPE_TYPE    const&shadertype   ,
        PRECISIONTYPE_TYPE const&precisiontype,
        RANGE_TYPE         const&range        ,
        PRECISION_TYPE     const&precision    ){
        return new GetShaderPrecisionFormat<
          SHADERTYPE_TYPE   ,
          PRECISIONTYPE_TYPE,
          RANGE_TYPE        ,
          PRECISION_TYPE    >(
              shadertype   ,
              precisiontype,
              range        ,
              precision    );
    }
    template<
      typename SHADERTYPE_TYPE    = GLenum,
      typename PRECISIONTYPE_TYPE = GLenum,
      typename RANGE_TYPE         = GLint*,
      typename PRECISION_TYPE     = GLint*>
    inline std::shared_ptr<GetShaderPrecisionFormat<
      SHADERTYPE_TYPE   ,
      PRECISIONTYPE_TYPE,
      RANGE_TYPE        ,
      PRECISION_TYPE    >> sharedGetShaderPrecisionFormat(
        SHADERTYPE_TYPE    const&shadertype   ,
        PRECISIONTYPE_TYPE const&precisiontype,
        RANGE_TYPE         const&range        ,
        PRECISION_TYPE     const&precision    ){
        return std::make_shared<GetShaderPrecisionFormat<
          SHADERTYPE_TYPE   ,
          PRECISIONTYPE_TYPE,
          RANGE_TYPE        ,
          PRECISION_TYPE    >>(
              shadertype   ,
              precisiontype,
              range        ,
              precision    );
    }

    template<
      typename FLAG_TYPE = GLboolean>
    inline DepthMask<
      FLAG_TYPE>* newDepthMask(
        FLAG_TYPE const&flag){
        return new DepthMask<
          FLAG_TYPE>(
              flag);
    }
    template<
      typename FLAG_TYPE = GLboolean>
    inline std::shared_ptr<DepthMask<
      FLAG_TYPE>> sharedDepthMask(
        FLAG_TYPE const&flag){
        return std::make_shared<DepthMask<
          FLAG_TYPE>>(
              flag);
    }

    template<
      typename TEXTURE_TYPE        = GLuint,
      typename TARGET_TYPE         = GLenum,
      typename ORIGTEXTURE_TYPE    = GLuint,
      typename INTERNALFORMAT_TYPE = GLenum,
      typename MINLEVEL_TYPE       = GLuint,
      typename NUMLEVELS_TYPE      = GLuint,
      typename MINLAYER_TYPE       = GLuint,
      typename NUMLAYERS_TYPE      = GLuint>
    inline TextureView<
      TEXTURE_TYPE       ,
      TARGET_TYPE        ,
      ORIGTEXTURE_TYPE   ,
      INTERNALFORMAT_TYPE,
      MINLEVEL_TYPE      ,
      NUMLEVELS_TYPE     ,
      MINLAYER_TYPE      ,
      NUMLAYERS_TYPE     >* newTextureView(
        TEXTURE_TYPE        const&texture       ,
        TARGET_TYPE         const&target        ,
        ORIGTEXTURE_TYPE    const&origtexture   ,
        INTERNALFORMAT_TYPE const&internalformat,
        MINLEVEL_TYPE       const&minlevel      ,
        NUMLEVELS_TYPE      const&numlevels     ,
        MINLAYER_TYPE       const&minlayer      ,
        NUMLAYERS_TYPE      const&numlayers     ){
        return new TextureView<
          TEXTURE_TYPE       ,
          TARGET_TYPE        ,
          ORIGTEXTURE_TYPE   ,
          INTERNALFORMAT_TYPE,
          MINLEVEL_TYPE      ,
          NUMLEVELS_TYPE     ,
          MINLAYER_TYPE      ,
          NUMLAYERS_TYPE     >(
              texture       ,
              target        ,
              origtexture   ,
              internalformat,
              minlevel      ,
              numlevels     ,
              minlayer      ,
              numlayers     );
    }
    template<
      typename TEXTURE_TYPE        = GLuint,
      typename TARGET_TYPE         = GLenum,
      typename ORIGTEXTURE_TYPE    = GLuint,
      typename INTERNALFORMAT_TYPE = GLenum,
      typename MINLEVEL_TYPE       = GLuint,
      typename NUMLEVELS_TYPE      = GLuint,
      typename MINLAYER_TYPE       = GLuint,
      typename NUMLAYERS_TYPE      = GLuint>
    inline std::shared_ptr<TextureView<
      TEXTURE_TYPE       ,
      TARGET_TYPE        ,
      ORIGTEXTURE_TYPE   ,
      INTERNALFORMAT_TYPE,
      MINLEVEL_TYPE      ,
      NUMLEVELS_TYPE     ,
      MINLAYER_TYPE      ,
      NUMLAYERS_TYPE     >> sharedTextureView(
        TEXTURE_TYPE        const&texture       ,
        TARGET_TYPE         const&target        ,
        ORIGTEXTURE_TYPE    const&origtexture   ,
        INTERNALFORMAT_TYPE const&internalformat,
        MINLEVEL_TYPE       const&minlevel      ,
        NUMLEVELS_TYPE      const&numlevels     ,
        MINLAYER_TYPE       const&minlayer      ,
        NUMLAYERS_TYPE      const&numlayers     ){
        return std::make_shared<TextureView<
          TEXTURE_TYPE       ,
          TARGET_TYPE        ,
          ORIGTEXTURE_TYPE   ,
          INTERNALFORMAT_TYPE,
          MINLEVEL_TYPE      ,
          NUMLEVELS_TYPE     ,
          MINLAYER_TYPE      ,
          NUMLAYERS_TYPE     >>(
              texture       ,
              target        ,
              origtexture   ,
              internalformat,
              minlevel      ,
              numlevels     ,
              minlayer      ,
              numlayers     );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint>
    inline Disablei<
      TARGET_TYPE,
      INDEX_TYPE >* newDisablei(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ){
        return new Disablei<
          TARGET_TYPE,
          INDEX_TYPE >(
              target,
              index );
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename INDEX_TYPE  = GLuint>
    inline std::shared_ptr<Disablei<
      TARGET_TYPE,
      INDEX_TYPE >> sharedDisablei(
        TARGET_TYPE const&target,
        INDEX_TYPE  const&index ){
        return std::make_shared<Disablei<
          TARGET_TYPE,
          INDEX_TYPE >>(
              target,
              index );
    }

    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline ProgramUniformMatrix2x4fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix2x4fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix2x4fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint        ,
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<ProgramUniformMatrix2x4fv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix2x4fv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix2x4fv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename READTARGET_TYPE  = GLenum    ,
      typename WRITETARGET_TYPE = GLenum    ,
      typename READOFFSET_TYPE  = GLintptr  ,
      typename WRITEOFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE        = GLsizeiptr>
    inline CopyBufferSubData<
      READTARGET_TYPE ,
      WRITETARGET_TYPE,
      READOFFSET_TYPE ,
      WRITEOFFSET_TYPE,
      SIZE_TYPE       >* newCopyBufferSubData(
        READTARGET_TYPE  const&readTarget ,
        WRITETARGET_TYPE const&writeTarget,
        READOFFSET_TYPE  const&readOffset ,
        WRITEOFFSET_TYPE const&writeOffset,
        SIZE_TYPE        const&size       ){
        return new CopyBufferSubData<
          READTARGET_TYPE ,
          WRITETARGET_TYPE,
          READOFFSET_TYPE ,
          WRITEOFFSET_TYPE,
          SIZE_TYPE       >(
              readTarget ,
              writeTarget,
              readOffset ,
              writeOffset,
              size       );
    }
    template<
      typename READTARGET_TYPE  = GLenum    ,
      typename WRITETARGET_TYPE = GLenum    ,
      typename READOFFSET_TYPE  = GLintptr  ,
      typename WRITEOFFSET_TYPE = GLintptr  ,
      typename SIZE_TYPE        = GLsizeiptr>
    inline std::shared_ptr<CopyBufferSubData<
      READTARGET_TYPE ,
      WRITETARGET_TYPE,
      READOFFSET_TYPE ,
      WRITEOFFSET_TYPE,
      SIZE_TYPE       >> sharedCopyBufferSubData(
        READTARGET_TYPE  const&readTarget ,
        WRITETARGET_TYPE const&writeTarget,
        READOFFSET_TYPE  const&readOffset ,
        WRITEOFFSET_TYPE const&writeOffset,
        SIZE_TYPE        const&size       ){
        return std::make_shared<CopyBufferSubData<
          READTARGET_TYPE ,
          WRITETARGET_TYPE,
          READOFFSET_TYPE ,
          WRITEOFFSET_TYPE,
          SIZE_TYPE       >>(
              readTarget ,
              writeTarget,
              readOffset ,
              writeOffset,
              size       );
    }

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble>
    inline VertexAttribL1d<
      INDEX_TYPE,
      X_TYPE    >* newVertexAttribL1d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ){
        return new VertexAttribL1d<
          INDEX_TYPE,
          X_TYPE    >(
              index,
              x    );
    }
    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble>
    inline std::shared_ptr<VertexAttribL1d<
      INDEX_TYPE,
      X_TYPE    >> sharedVertexAttribL1d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ){
        return std::make_shared<VertexAttribL1d<
          INDEX_TYPE,
          X_TYPE    >>(
              index,
              x    );
    }

    template<
      typename N_TYPE             = GLsizei      ,
      typename RENDERBUFFERS_TYPE = const GLuint*>
    inline DeleteRenderbuffers<
      N_TYPE            ,
      RENDERBUFFERS_TYPE>* newDeleteRenderbuffers(
        N_TYPE             const&n            ,
        RENDERBUFFERS_TYPE const&renderbuffers){
        return new DeleteRenderbuffers<
          N_TYPE            ,
          RENDERBUFFERS_TYPE>(
              n            ,
              renderbuffers);
    }
    template<
      typename N_TYPE             = GLsizei      ,
      typename RENDERBUFFERS_TYPE = const GLuint*>
    inline std::shared_ptr<DeleteRenderbuffers<
      N_TYPE            ,
      RENDERBUFFERS_TYPE>> sharedDeleteRenderbuffers(
        N_TYPE             const&n            ,
        RENDERBUFFERS_TYPE const&renderbuffers){
        return std::make_shared<DeleteRenderbuffers<
          N_TYPE            ,
          RENDERBUFFERS_TYPE>>(
              n            ,
              renderbuffers);
    }

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    inline VertexAttribI3uiv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribI3uiv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribI3uiv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    inline std::shared_ptr<VertexAttribI3uiv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribI3uiv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribI3uiv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }


    template<
      typename ATTRIBINDEX_TYPE    = GLuint,
      typename SIZE_TYPE           = GLint ,
      typename TYPE_TYPE           = GLenum,
      typename RELATIVEOFFSET_TYPE = GLuint>
    inline VertexAttribIFormat<
      ATTRIBINDEX_TYPE   ,
      SIZE_TYPE          ,
      TYPE_TYPE          ,
      RELATIVEOFFSET_TYPE>* newVertexAttribIFormat(
        ATTRIBINDEX_TYPE    const&attribindex   ,
        SIZE_TYPE           const&size          ,
        TYPE_TYPE           const&type          ,
        RELATIVEOFFSET_TYPE const&relativeoffset){
        return new VertexAttribIFormat<
          ATTRIBINDEX_TYPE   ,
          SIZE_TYPE          ,
          TYPE_TYPE          ,
          RELATIVEOFFSET_TYPE>(
              attribindex   ,
              size          ,
              type          ,
              relativeoffset);
    }
    template<
      typename ATTRIBINDEX_TYPE    = GLuint,
      typename SIZE_TYPE           = GLint ,
      typename TYPE_TYPE           = GLenum,
      typename RELATIVEOFFSET_TYPE = GLuint>
    inline std::shared_ptr<VertexAttribIFormat<
      ATTRIBINDEX_TYPE   ,
      SIZE_TYPE          ,
      TYPE_TYPE          ,
      RELATIVEOFFSET_TYPE>> sharedVertexAttribIFormat(
        ATTRIBINDEX_TYPE    const&attribindex   ,
        SIZE_TYPE           const&size          ,
        TYPE_TYPE           const&type          ,
        RELATIVEOFFSET_TYPE const&relativeoffset){
        return std::make_shared<VertexAttribIFormat<
          ATTRIBINDEX_TYPE   ,
          SIZE_TYPE          ,
          TYPE_TYPE          ,
          RELATIVEOFFSET_TYPE>>(
              attribindex   ,
              size          ,
              type          ,
              relativeoffset);
    }

    template<
      typename N_TYPE            = GLsizei,
      typename FRAMEBUFFERS_TYPE = GLuint*>
    inline CreateFramebuffers<
      N_TYPE           ,
      FRAMEBUFFERS_TYPE>* newCreateFramebuffers(
        N_TYPE            const&n           ,
        FRAMEBUFFERS_TYPE const&framebuffers){
        return new CreateFramebuffers<
          N_TYPE           ,
          FRAMEBUFFERS_TYPE>(
              n           ,
              framebuffers);
    }
    template<
      typename N_TYPE            = GLsizei,
      typename FRAMEBUFFERS_TYPE = GLuint*>
    inline std::shared_ptr<CreateFramebuffers<
      N_TYPE           ,
      FRAMEBUFFERS_TYPE>> sharedCreateFramebuffers(
        N_TYPE            const&n           ,
        FRAMEBUFFERS_TYPE const&framebuffers){
        return std::make_shared<CreateFramebuffers<
          N_TYPE           ,
          FRAMEBUFFERS_TYPE>>(
              n           ,
              framebuffers);
    }

    template<
      typename SYNC_TYPE    = GLsync  ,
      typename PNAME_TYPE   = GLenum  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename VALUES_TYPE  = GLint*  >
    inline GetSynciv<
      SYNC_TYPE   ,
      PNAME_TYPE  ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      VALUES_TYPE >* newGetSynciv(
        SYNC_TYPE    const&sync   ,
        PNAME_TYPE   const&pname  ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        VALUES_TYPE  const&values ){
        return new GetSynciv<
          SYNC_TYPE   ,
          PNAME_TYPE  ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          VALUES_TYPE >(
              sync   ,
              pname  ,
              bufSize,
              length ,
              values );
    }
    template<
      typename SYNC_TYPE    = GLsync  ,
      typename PNAME_TYPE   = GLenum  ,
      typename BUFSIZE_TYPE = GLsizei ,
      typename LENGTH_TYPE  = GLsizei*,
      typename VALUES_TYPE  = GLint*  >
    inline std::shared_ptr<GetSynciv<
      SYNC_TYPE   ,
      PNAME_TYPE  ,
      BUFSIZE_TYPE,
      LENGTH_TYPE ,
      VALUES_TYPE >> sharedGetSynciv(
        SYNC_TYPE    const&sync   ,
        PNAME_TYPE   const&pname  ,
        BUFSIZE_TYPE const&bufSize,
        LENGTH_TYPE  const&length ,
        VALUES_TYPE  const&values ){
        return std::make_shared<GetSynciv<
          SYNC_TYPE   ,
          PNAME_TYPE  ,
          BUFSIZE_TYPE,
          LENGTH_TYPE ,
          VALUES_TYPE >>(
              sync   ,
              pname  ,
              bufSize,
              length ,
              values );
    }

    template<
      typename PROGRAM_TYPE  = GLuint         ,
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline ProgramUniform2dv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform2dv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform2dv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint         ,
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline std::shared_ptr<ProgramUniform2dv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform2dv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform2dv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename TARGET_TYPE               = GLenum   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename DEPTH_TYPE                = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    inline TexImage3DMultisample<
      TARGET_TYPE              ,
      SAMPLES_TYPE             ,
      INTERNALFORMAT_TYPE      ,
      WIDTH_TYPE               ,
      HEIGHT_TYPE              ,
      DEPTH_TYPE               ,
      FIXEDSAMPLELOCATIONS_TYPE>* newTexImage3DMultisample(
        TARGET_TYPE               const&target              ,
        SAMPLES_TYPE              const&samples             ,
        INTERNALFORMAT_TYPE       const&internalformat      ,
        WIDTH_TYPE                const&width               ,
        HEIGHT_TYPE               const&height              ,
        DEPTH_TYPE                const&depth               ,
        FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
        return new TexImage3DMultisample<
          TARGET_TYPE              ,
          SAMPLES_TYPE             ,
          INTERNALFORMAT_TYPE      ,
          WIDTH_TYPE               ,
          HEIGHT_TYPE              ,
          DEPTH_TYPE               ,
          FIXEDSAMPLELOCATIONS_TYPE>(
              target              ,
              samples             ,
              internalformat      ,
              width               ,
              height              ,
              depth               ,
              fixedsamplelocations);
    }
    template<
      typename TARGET_TYPE               = GLenum   ,
      typename SAMPLES_TYPE              = GLsizei  ,
      typename INTERNALFORMAT_TYPE       = GLenum   ,
      typename WIDTH_TYPE                = GLsizei  ,
      typename HEIGHT_TYPE               = GLsizei  ,
      typename DEPTH_TYPE                = GLsizei  ,
      typename FIXEDSAMPLELOCATIONS_TYPE = GLboolean>
    inline std::shared_ptr<TexImage3DMultisample<
      TARGET_TYPE              ,
      SAMPLES_TYPE             ,
      INTERNALFORMAT_TYPE      ,
      WIDTH_TYPE               ,
      HEIGHT_TYPE              ,
      DEPTH_TYPE               ,
      FIXEDSAMPLELOCATIONS_TYPE>> sharedTexImage3DMultisample(
        TARGET_TYPE               const&target              ,
        SAMPLES_TYPE              const&samples             ,
        INTERNALFORMAT_TYPE       const&internalformat      ,
        WIDTH_TYPE                const&width               ,
        HEIGHT_TYPE               const&height              ,
        DEPTH_TYPE                const&depth               ,
        FIXEDSAMPLELOCATIONS_TYPE const&fixedsamplelocations){
        return std::make_shared<TexImage3DMultisample<
          TARGET_TYPE              ,
          SAMPLES_TYPE             ,
          INTERNALFORMAT_TYPE      ,
          WIDTH_TYPE               ,
          HEIGHT_TYPE              ,
          DEPTH_TYPE               ,
          FIXEDSAMPLELOCATIONS_TYPE>>(
              target              ,
              samples             ,
              internalformat      ,
              width               ,
              height              ,
              depth               ,
              fixedsamplelocations);
    }

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLint ,
      typename V1_TYPE       = GLint >
    inline ProgramUniform2i<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >* newProgramUniform2i(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return new ProgramUniform2i<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >(
              program ,
              location,
              v0      ,
              v1      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLint ,
      typename V1_TYPE       = GLint >
    inline std::shared_ptr<ProgramUniform2i<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >> sharedProgramUniform2i(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return std::make_shared<ProgramUniform2i<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >>(
              program ,
              location,
              v0      ,
              v1      );
    }

    template<
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLint64*>
    inline GetNamedBufferParameteri64v<
      BUFFER_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetNamedBufferParameteri64v(
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetNamedBufferParameteri64v<
          BUFFER_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              buffer,
              pname ,
              params);
    }
    template<
      typename BUFFER_TYPE = GLuint  ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLint64*>
    inline std::shared_ptr<GetNamedBufferParameteri64v<
      BUFFER_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetNamedBufferParameteri64v(
        BUFFER_TYPE const&buffer,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetNamedBufferParameteri64v<
          BUFFER_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              buffer,
              pname ,
              params);
    }

    template<
      typename MODE_TYPE      = GLenum     ,
      typename TYPE_TYPE      = GLenum     ,
      typename INDIRECT_TYPE  = const void*,
      typename DRAWCOUNT_TYPE = GLsizei    ,
      typename STRIDE_TYPE    = GLsizei    >
    inline MultiDrawElementsIndirect<
      MODE_TYPE     ,
      TYPE_TYPE     ,
      INDIRECT_TYPE ,
      DRAWCOUNT_TYPE,
      STRIDE_TYPE   >* newMultiDrawElementsIndirect(
        MODE_TYPE      const&mode     ,
        TYPE_TYPE      const&type     ,
        INDIRECT_TYPE  const&indirect ,
        DRAWCOUNT_TYPE const&drawcount,
        STRIDE_TYPE    const&stride   ){
        return new MultiDrawElementsIndirect<
          MODE_TYPE     ,
          TYPE_TYPE     ,
          INDIRECT_TYPE ,
          DRAWCOUNT_TYPE,
          STRIDE_TYPE   >(
              mode     ,
              type     ,
              indirect ,
              drawcount,
              stride   );
    }
    template<
      typename MODE_TYPE      = GLenum     ,
      typename TYPE_TYPE      = GLenum     ,
      typename INDIRECT_TYPE  = const void*,
      typename DRAWCOUNT_TYPE = GLsizei    ,
      typename STRIDE_TYPE    = GLsizei    >
    inline std::shared_ptr<MultiDrawElementsIndirect<
      MODE_TYPE     ,
      TYPE_TYPE     ,
      INDIRECT_TYPE ,
      DRAWCOUNT_TYPE,
      STRIDE_TYPE   >> sharedMultiDrawElementsIndirect(
        MODE_TYPE      const&mode     ,
        TYPE_TYPE      const&type     ,
        INDIRECT_TYPE  const&indirect ,
        DRAWCOUNT_TYPE const&drawcount,
        STRIDE_TYPE    const&stride   ){
        return std::make_shared<MultiDrawElementsIndirect<
          MODE_TYPE     ,
          TYPE_TYPE     ,
          INDIRECT_TYPE ,
          DRAWCOUNT_TYPE,
          STRIDE_TYPE   >>(
              mode     ,
              type     ,
              indirect ,
              drawcount,
              stride   );
    }

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline UniformMatrix4fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix4fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix4fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<UniformMatrix4fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix4fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix4fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename BUFFER_TYPE = GLuint>
    inline BindBuffer<
      TARGET_TYPE,
      BUFFER_TYPE>* newBindBuffer(
        TARGET_TYPE const&target,
        BUFFER_TYPE const&buffer){
        return new BindBuffer<
          TARGET_TYPE,
          BUFFER_TYPE>(
              target,
              buffer);
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename BUFFER_TYPE = GLuint>
    inline std::shared_ptr<BindBuffer<
      TARGET_TYPE,
      BUFFER_TYPE>> sharedBindBuffer(
        TARGET_TYPE const&target,
        BUFFER_TYPE const&buffer){
        return std::make_shared<BindBuffer<
          TARGET_TYPE,
          BUFFER_TYPE>>(
              target,
              buffer);
    }

    template<
      typename DEPTH_TYPE = GLdouble>
    inline ClearDepth<
      DEPTH_TYPE>* newClearDepth(
        DEPTH_TYPE const&depth){
        return new ClearDepth<
          DEPTH_TYPE>(
              depth);
    }
    template<
      typename DEPTH_TYPE = GLdouble>
    inline std::shared_ptr<ClearDepth<
      DEPTH_TYPE>> sharedClearDepth(
        DEPTH_TYPE const&depth){
        return std::make_shared<ClearDepth<
          DEPTH_TYPE>>(
              depth);
    }

    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename V0_TYPE       = GLdouble,
      typename V1_TYPE       = GLdouble>
    inline ProgramUniform2d<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >* newProgramUniform2d(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return new ProgramUniform2d<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >(
              program ,
              location,
              v0      ,
              v1      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint  ,
      typename LOCATION_TYPE = GLint   ,
      typename V0_TYPE       = GLdouble,
      typename V1_TYPE       = GLdouble>
    inline std::shared_ptr<ProgramUniform2d<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >> sharedProgramUniform2d(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return std::make_shared<ProgramUniform2d<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >>(
              program ,
              location,
              v0      ,
              v1      );
    }

    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat>
    inline ProgramUniform2f<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >* newProgramUniform2f(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return new ProgramUniform2f<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >(
              program ,
              location,
              v0      ,
              v1      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint ,
      typename LOCATION_TYPE = GLint  ,
      typename V0_TYPE       = GLfloat,
      typename V1_TYPE       = GLfloat>
    inline std::shared_ptr<ProgramUniform2f<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >> sharedProgramUniform2f(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return std::make_shared<ProgramUniform2f<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >>(
              program ,
              location,
              v0      ,
              v1      );
    }

    template<
      typename PROGRAM_TYPE      = GLuint  ,
      typename BUFSIZE_TYPE      = GLsizei ,
      typename LENGTH_TYPE       = GLsizei*,
      typename BINARYFORMAT_TYPE = GLenum* ,
      typename BINARY_TYPE       = void*   >
    inline GetProgramBinary<
      PROGRAM_TYPE     ,
      BUFSIZE_TYPE     ,
      LENGTH_TYPE      ,
      BINARYFORMAT_TYPE,
      BINARY_TYPE      >* newGetProgramBinary(
        PROGRAM_TYPE      const&program     ,
        BUFSIZE_TYPE      const&bufSize     ,
        LENGTH_TYPE       const&length      ,
        BINARYFORMAT_TYPE const&binaryFormat,
        BINARY_TYPE       const&binary      ){
        return new GetProgramBinary<
          PROGRAM_TYPE     ,
          BUFSIZE_TYPE     ,
          LENGTH_TYPE      ,
          BINARYFORMAT_TYPE,
          BINARY_TYPE      >(
              program     ,
              bufSize     ,
              length      ,
              binaryFormat,
              binary      );
    }
    template<
      typename PROGRAM_TYPE      = GLuint  ,
      typename BUFSIZE_TYPE      = GLsizei ,
      typename LENGTH_TYPE       = GLsizei*,
      typename BINARYFORMAT_TYPE = GLenum* ,
      typename BINARY_TYPE       = void*   >
    inline std::shared_ptr<GetProgramBinary<
      PROGRAM_TYPE     ,
      BUFSIZE_TYPE     ,
      LENGTH_TYPE      ,
      BINARYFORMAT_TYPE,
      BINARY_TYPE      >> sharedGetProgramBinary(
        PROGRAM_TYPE      const&program     ,
        BUFSIZE_TYPE      const&bufSize     ,
        LENGTH_TYPE       const&length      ,
        BINARYFORMAT_TYPE const&binaryFormat,
        BINARY_TYPE       const&binary      ){
        return std::make_shared<GetProgramBinary<
          PROGRAM_TYPE     ,
          BUFSIZE_TYPE     ,
          LENGTH_TYPE      ,
          BINARYFORMAT_TYPE,
          BINARY_TYPE      >>(
              program     ,
              bufSize     ,
              length      ,
              binaryFormat,
              binary      );
    }

    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline UniformMatrix2x4fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newUniformMatrix2x4fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new UniformMatrix2x4fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename LOCATION_TYPE  = GLint         ,
      typename COUNT_TYPE     = GLsizei       ,
      typename TRANSPOSE_TYPE = GLboolean     ,
      typename VALUE_TYPE     = const GLfloat*>
    inline std::shared_ptr<UniformMatrix2x4fv<
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedUniformMatrix2x4fv(
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<UniformMatrix2x4fv<
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename TARGET_TYPE = GLenum     ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*,
      typename USAGE_TYPE  = GLenum     >
    inline BufferData<
      TARGET_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  ,
      USAGE_TYPE >* newBufferData(
        TARGET_TYPE const&target,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ,
        USAGE_TYPE  const&usage ){
        return new BufferData<
          TARGET_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  ,
          USAGE_TYPE >(
              target,
              size  ,
              data  ,
              usage );
    }
    template<
      typename TARGET_TYPE = GLenum     ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*,
      typename USAGE_TYPE  = GLenum     >
    inline std::shared_ptr<BufferData<
      TARGET_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  ,
      USAGE_TYPE >> sharedBufferData(
        TARGET_TYPE const&target,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ,
        USAGE_TYPE  const&usage ){
        return std::make_shared<BufferData<
          TARGET_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  ,
          USAGE_TYPE >>(
              target,
              size  ,
              data  ,
              usage );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetTexParameterIiv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetTexParameterIiv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetTexParameterIiv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetTexParameterIiv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetTexParameterIiv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetTexParameterIiv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }


    template<
      typename RET_TYPE = GLenum>
    inline GetError<
      RET_TYPE>* newGetError(
        RET_TYPE const&ret){
        return new GetError<
          RET_TYPE>(
              ret);
    }
    template<
      typename RET_TYPE = GLenum>
    inline std::shared_ptr<GetError<
      RET_TYPE>> sharedGetError(
        RET_TYPE const&ret){
        return std::make_shared<GetError<
          RET_TYPE>>(
              ret);
    }

    template<
      typename N_TYPE   = GLsizei,
      typename IDS_TYPE = GLuint*>
    inline CreateTransformFeedbacks<
      N_TYPE  ,
      IDS_TYPE>* newCreateTransformFeedbacks(
        N_TYPE   const&n  ,
        IDS_TYPE const&ids){
        return new CreateTransformFeedbacks<
          N_TYPE  ,
          IDS_TYPE>(
              n  ,
              ids);
    }
    template<
      typename N_TYPE   = GLsizei,
      typename IDS_TYPE = GLuint*>
    inline std::shared_ptr<CreateTransformFeedbacks<
      N_TYPE  ,
      IDS_TYPE>> sharedCreateTransformFeedbacks(
        N_TYPE   const&n  ,
        IDS_TYPE const&ids){
        return std::make_shared<CreateTransformFeedbacks<
          N_TYPE  ,
          IDS_TYPE>>(
              n  ,
              ids);
    }

    template<
      typename FAIL_TYPE  = GLenum,
      typename ZFAIL_TYPE = GLenum,
      typename ZPASS_TYPE = GLenum>
    inline StencilOp<
      FAIL_TYPE ,
      ZFAIL_TYPE,
      ZPASS_TYPE>* newStencilOp(
        FAIL_TYPE  const&fail ,
        ZFAIL_TYPE const&zfail,
        ZPASS_TYPE const&zpass){
        return new StencilOp<
          FAIL_TYPE ,
          ZFAIL_TYPE,
          ZPASS_TYPE>(
              fail ,
              zfail,
              zpass);
    }
    template<
      typename FAIL_TYPE  = GLenum,
      typename ZFAIL_TYPE = GLenum,
      typename ZPASS_TYPE = GLenum>
    inline std::shared_ptr<StencilOp<
      FAIL_TYPE ,
      ZFAIL_TYPE,
      ZPASS_TYPE>> sharedStencilOp(
        FAIL_TYPE  const&fail ,
        ZFAIL_TYPE const&zfail,
        ZPASS_TYPE const&zpass){
        return std::make_shared<StencilOp<
          FAIL_TYPE ,
          ZFAIL_TYPE,
          ZPASS_TYPE>>(
              fail ,
              zfail,
              zpass);
    }

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei>
    inline CopyTextureSubImage3D<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  ,
      HEIGHT_TYPE >* newCopyTextureSubImage3D(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ){
        return new CopyTextureSubImage3D<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  ,
          HEIGHT_TYPE >(
              texture,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              x      ,
              y      ,
              width  ,
              height );
    }
    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename X_TYPE       = GLint  ,
      typename Y_TYPE       = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei>
    inline std::shared_ptr<CopyTextureSubImage3D<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      X_TYPE      ,
      Y_TYPE      ,
      WIDTH_TYPE  ,
      HEIGHT_TYPE >> sharedCopyTextureSubImage3D(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        X_TYPE       const&x      ,
        Y_TYPE       const&y      ,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ){
        return std::make_shared<CopyTextureSubImage3D<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          X_TYPE      ,
          Y_TYPE      ,
          WIDTH_TYPE  ,
          HEIGHT_TYPE >>(
              texture,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              x      ,
              y      ,
              width  ,
              height );
    }

    template<
      typename TARGET_TYPE  = GLenum     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    inline TexSubImage1D<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      WIDTH_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      PIXELS_TYPE >* newTexSubImage1D(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        WIDTH_TYPE   const&width  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        PIXELS_TYPE  const&pixels ){
        return new TexSubImage1D<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          WIDTH_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          PIXELS_TYPE >(
              target ,
              level  ,
              xoffset,
              width  ,
              format ,
              type   ,
              pixels );
    }
    template<
      typename TARGET_TYPE  = GLenum     ,
      typename LEVEL_TYPE   = GLint      ,
      typename XOFFSET_TYPE = GLint      ,
      typename WIDTH_TYPE   = GLsizei    ,
      typename FORMAT_TYPE  = GLenum     ,
      typename TYPE_TYPE    = GLenum     ,
      typename PIXELS_TYPE  = const void*>
    inline std::shared_ptr<TexSubImage1D<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      WIDTH_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      PIXELS_TYPE >> sharedTexSubImage1D(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        WIDTH_TYPE   const&width  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        PIXELS_TYPE  const&pixels ){
        return std::make_shared<TexSubImage1D<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          WIDTH_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          PIXELS_TYPE >>(
              target ,
              level  ,
              xoffset,
              width  ,
              format ,
              type   ,
              pixels );
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    inline VertexAttrib2fv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib2fv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib2fv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLfloat*>
    inline std::shared_ptr<VertexAttrib2fv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib2fv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib2fv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename TARGET_TYPE = GLenum  ,
      typename LEVEL_TYPE  = GLint   ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLfloat*>
    inline GetTexLevelParameterfv<
      TARGET_TYPE,
      LEVEL_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetTexLevelParameterfv(
        TARGET_TYPE const&target,
        LEVEL_TYPE  const&level ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetTexLevelParameterfv<
          TARGET_TYPE,
          LEVEL_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              level ,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum  ,
      typename LEVEL_TYPE  = GLint   ,
      typename PNAME_TYPE  = GLenum  ,
      typename PARAMS_TYPE = GLfloat*>
    inline std::shared_ptr<GetTexLevelParameterfv<
      TARGET_TYPE,
      LEVEL_TYPE ,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetTexLevelParameterfv(
        TARGET_TYPE const&target,
        LEVEL_TYPE  const&level ,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetTexLevelParameterfv<
          TARGET_TYPE,
          LEVEL_TYPE ,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              level ,
              pname ,
              params);
    }

    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLint >
    inline VertexAttribI1i<
      INDEX_TYPE,
      X_TYPE    >* newVertexAttribI1i(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ){
        return new VertexAttribI1i<
          INDEX_TYPE,
          X_TYPE    >(
              index,
              x    );
    }
    template<
      typename INDEX_TYPE = GLuint,
      typename X_TYPE     = GLint >
    inline std::shared_ptr<VertexAttribI1i<
      INDEX_TYPE,
      X_TYPE    >> sharedVertexAttribI1i(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ){
        return std::make_shared<VertexAttribI1i<
          INDEX_TYPE,
          X_TYPE    >>(
              index,
              x    );
    }

    template<
      typename INDEX_TYPE      = GLuint       ,
      typename TYPE_TYPE       = GLenum       ,
      typename NORMALIZED_TYPE = GLboolean    ,
      typename VALUE_TYPE      = const GLuint*>
    inline VertexAttribP3uiv<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >* newVertexAttribP3uiv(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return new VertexAttribP3uiv<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >(
              index     ,
              type      ,
              normalized,
              value     );
    }
    template<
      typename INDEX_TYPE      = GLuint       ,
      typename TYPE_TYPE       = GLenum       ,
      typename NORMALIZED_TYPE = GLboolean    ,
      typename VALUE_TYPE      = const GLuint*>
    inline std::shared_ptr<VertexAttribP3uiv<
      INDEX_TYPE     ,
      TYPE_TYPE      ,
      NORMALIZED_TYPE,
      VALUE_TYPE     >> sharedVertexAttribP3uiv(
        INDEX_TYPE      const&index     ,
        TYPE_TYPE       const&type      ,
        NORMALIZED_TYPE const&normalized,
        VALUE_TYPE      const&value     ){
        return std::make_shared<VertexAttribP3uiv<
          INDEX_TYPE     ,
          TYPE_TYPE      ,
          NORMALIZED_TYPE,
          VALUE_TYPE     >>(
              index     ,
              type      ,
              normalized,
              value     );
    }

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline VertexAttribI3iv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribI3iv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribI3iv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline std::shared_ptr<VertexAttribI3iv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribI3iv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribI3iv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename PNAME_TYPE = GLenum,
      typename DATA_TYPE  = GLint*>
    inline GetIntegerv<
      PNAME_TYPE,
      DATA_TYPE >* newGetIntegerv(
        PNAME_TYPE const&pname,
        DATA_TYPE  const&data ){
        return new GetIntegerv<
          PNAME_TYPE,
          DATA_TYPE >(
              pname,
              data );
    }
    template<
      typename PNAME_TYPE = GLenum,
      typename DATA_TYPE  = GLint*>
    inline std::shared_ptr<GetIntegerv<
      PNAME_TYPE,
      DATA_TYPE >> sharedGetIntegerv(
        PNAME_TYPE const&pname,
        DATA_TYPE  const&data ){
        return std::make_shared<GetIntegerv<
          PNAME_TYPE,
          DATA_TYPE >>(
              pname,
              data );
    }

    template<
      typename TARGET_TYPE  = GLenum ,
      typename LEVEL_TYPE   = GLint  ,
      typename FORMAT_TYPE  = GLenum ,
      typename TYPE_TYPE    = GLenum ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    inline GetnTexImage<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      BUFSIZE_TYPE,
      PIXELS_TYPE >* newGetnTexImage(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        BUFSIZE_TYPE const&bufSize,
        PIXELS_TYPE  const&pixels ){
        return new GetnTexImage<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          BUFSIZE_TYPE,
          PIXELS_TYPE >(
              target ,
              level  ,
              format ,
              type   ,
              bufSize,
              pixels );
    }
    template<
      typename TARGET_TYPE  = GLenum ,
      typename LEVEL_TYPE   = GLint  ,
      typename FORMAT_TYPE  = GLenum ,
      typename TYPE_TYPE    = GLenum ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    inline std::shared_ptr<GetnTexImage<
      TARGET_TYPE ,
      LEVEL_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      BUFSIZE_TYPE,
      PIXELS_TYPE >> sharedGetnTexImage(
        TARGET_TYPE  const&target ,
        LEVEL_TYPE   const&level  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        BUFSIZE_TYPE const&bufSize,
        PIXELS_TYPE  const&pixels ){
        return std::make_shared<GetnTexImage<
          TARGET_TYPE ,
          LEVEL_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          BUFSIZE_TYPE,
          PIXELS_TYPE >>(
              target ,
              level  ,
              format ,
              type   ,
              bufSize,
              pixels );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = void**>
    inline GetBufferPointerv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetBufferPointerv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetBufferPointerv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = void**>
    inline std::shared_ptr<GetBufferPointerv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetBufferPointerv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetBufferPointerv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline ProgramUniformMatrix3dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >* newProgramUniformMatrix3dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return new ProgramUniformMatrix3dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }
    template<
      typename PROGRAM_TYPE   = GLuint         ,
      typename LOCATION_TYPE  = GLint          ,
      typename COUNT_TYPE     = GLsizei        ,
      typename TRANSPOSE_TYPE = GLboolean      ,
      typename VALUE_TYPE     = const GLdouble*>
    inline std::shared_ptr<ProgramUniformMatrix3dv<
      PROGRAM_TYPE  ,
      LOCATION_TYPE ,
      COUNT_TYPE    ,
      TRANSPOSE_TYPE,
      VALUE_TYPE    >> sharedProgramUniformMatrix3dv(
        PROGRAM_TYPE   const&program  ,
        LOCATION_TYPE  const&location ,
        COUNT_TYPE     const&count    ,
        TRANSPOSE_TYPE const&transpose,
        VALUE_TYPE     const&value    ){
        return std::make_shared<ProgramUniformMatrix3dv<
          PROGRAM_TYPE  ,
          LOCATION_TYPE ,
          COUNT_TYPE    ,
          TRANSPOSE_TYPE,
          VALUE_TYPE    >>(
              program  ,
              location ,
              count    ,
              transpose,
              value    );
    }

    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTARGET_TYPE  = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint ,
      typename ZOFFSET_TYPE    = GLint >
    inline FramebufferTexture3D<
      TARGET_TYPE    ,
      ATTACHMENT_TYPE,
      TEXTARGET_TYPE ,
      TEXTURE_TYPE   ,
      LEVEL_TYPE     ,
      ZOFFSET_TYPE   >* newFramebufferTexture3D(
        TARGET_TYPE     const&target    ,
        ATTACHMENT_TYPE const&attachment,
        TEXTARGET_TYPE  const&textarget ,
        TEXTURE_TYPE    const&texture   ,
        LEVEL_TYPE      const&level     ,
        ZOFFSET_TYPE    const&zoffset   ){
        return new FramebufferTexture3D<
          TARGET_TYPE    ,
          ATTACHMENT_TYPE,
          TEXTARGET_TYPE ,
          TEXTURE_TYPE   ,
          LEVEL_TYPE     ,
          ZOFFSET_TYPE   >(
              target    ,
              attachment,
              textarget ,
              texture   ,
              level     ,
              zoffset   );
    }
    template<
      typename TARGET_TYPE     = GLenum,
      typename ATTACHMENT_TYPE = GLenum,
      typename TEXTARGET_TYPE  = GLenum,
      typename TEXTURE_TYPE    = GLuint,
      typename LEVEL_TYPE      = GLint ,
      typename ZOFFSET_TYPE    = GLint >
    inline std::shared_ptr<FramebufferTexture3D<
      TARGET_TYPE    ,
      ATTACHMENT_TYPE,
      TEXTARGET_TYPE ,
      TEXTURE_TYPE   ,
      LEVEL_TYPE     ,
      ZOFFSET_TYPE   >> sharedFramebufferTexture3D(
        TARGET_TYPE     const&target    ,
        ATTACHMENT_TYPE const&attachment,
        TEXTARGET_TYPE  const&textarget ,
        TEXTURE_TYPE    const&texture   ,
        LEVEL_TYPE      const&level     ,
        ZOFFSET_TYPE    const&zoffset   ){
        return std::make_shared<FramebufferTexture3D<
          TARGET_TYPE    ,
          ATTACHMENT_TYPE,
          TEXTARGET_TYPE ,
          TEXTURE_TYPE   ,
          LEVEL_TYPE     ,
          ZOFFSET_TYPE   >>(
              target    ,
              attachment,
              textarget ,
              texture   ,
              level     ,
              zoffset   );
    }

    template<
      typename RET_TYPE = GLboolean,
      typename ID_TYPE  = GLuint   >
    inline IsQuery<
      RET_TYPE,
      ID_TYPE >* newIsQuery(
        RET_TYPE const&ret,
        ID_TYPE  const&id ){
        return new IsQuery<
          RET_TYPE,
          ID_TYPE >(
              ret,
              id );
    }
    template<
      typename RET_TYPE = GLboolean,
      typename ID_TYPE  = GLuint   >
    inline std::shared_ptr<IsQuery<
      RET_TYPE,
      ID_TYPE >> sharedIsQuery(
        RET_TYPE const&ret,
        ID_TYPE  const&id ){
        return std::make_shared<IsQuery<
          RET_TYPE,
          ID_TYPE >>(
              ret,
              id );
    }

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint>
    inline ProgramUniform2ui<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >* newProgramUniform2ui(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return new ProgramUniform2ui<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >(
              program ,
              location,
              v0      ,
              v1      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint>
    inline std::shared_ptr<ProgramUniform2ui<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      >> sharedProgramUniform2ui(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ){
        return std::make_shared<ProgramUniform2ui<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      >>(
              program ,
              location,
              v0      ,
              v1      );
    }

    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint,
      typename V2_TYPE       = GLuint,
      typename V3_TYPE       = GLuint>
    inline ProgramUniform4ui<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >* newProgramUniform4ui(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return new ProgramUniform4ui<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >(
              program ,
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }
    template<
      typename PROGRAM_TYPE  = GLuint,
      typename LOCATION_TYPE = GLint ,
      typename V0_TYPE       = GLuint,
      typename V1_TYPE       = GLuint,
      typename V2_TYPE       = GLuint,
      typename V3_TYPE       = GLuint>
    inline std::shared_ptr<ProgramUniform4ui<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      V0_TYPE      ,
      V1_TYPE      ,
      V2_TYPE      ,
      V3_TYPE      >> sharedProgramUniform4ui(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        V0_TYPE       const&v0      ,
        V1_TYPE       const&v1      ,
        V2_TYPE       const&v2      ,
        V3_TYPE       const&v3      ){
        return std::make_shared<ProgramUniform4ui<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          V0_TYPE      ,
          V1_TYPE      ,
          V2_TYPE      ,
          V3_TYPE      >>(
              program ,
              location,
              v0      ,
              v1      ,
              v2      ,
              v3      );
    }

    template<
      typename VAOBJ_TYPE = GLuint,
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint*>
    inline GetVertexArrayiv<
      VAOBJ_TYPE,
      PNAME_TYPE,
      PARAM_TYPE>* newGetVertexArrayiv(
        VAOBJ_TYPE const&vaobj,
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return new GetVertexArrayiv<
          VAOBJ_TYPE,
          PNAME_TYPE,
          PARAM_TYPE>(
              vaobj,
              pname,
              param);
    }
    template<
      typename VAOBJ_TYPE = GLuint,
      typename PNAME_TYPE = GLenum,
      typename PARAM_TYPE = GLint*>
    inline std::shared_ptr<GetVertexArrayiv<
      VAOBJ_TYPE,
      PNAME_TYPE,
      PARAM_TYPE>> sharedGetVertexArrayiv(
        VAOBJ_TYPE const&vaobj,
        PNAME_TYPE const&pname,
        PARAM_TYPE const&param){
        return std::make_shared<GetVertexArrayiv<
          VAOBJ_TYPE,
          PNAME_TYPE,
          PARAM_TYPE>>(
              vaobj,
              pname,
              param);
    }

    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLint      ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename HEIGHT_TYPE         = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename PIXELS_TYPE         = const void*>
    inline TexImage2D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      BORDER_TYPE        ,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      PIXELS_TYPE        >* newTexImage2D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        BORDER_TYPE         const&border        ,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        PIXELS_TYPE         const&pixels        ){
        return new TexImage2D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          BORDER_TYPE        ,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          PIXELS_TYPE        >(
              target        ,
              level         ,
              internalformat,
              width         ,
              height        ,
              border        ,
              format        ,
              type          ,
              pixels        );
    }
    template<
      typename TARGET_TYPE         = GLenum     ,
      typename LEVEL_TYPE          = GLint      ,
      typename INTERNALFORMAT_TYPE = GLint      ,
      typename WIDTH_TYPE          = GLsizei    ,
      typename HEIGHT_TYPE         = GLsizei    ,
      typename BORDER_TYPE         = GLint      ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename PIXELS_TYPE         = const void*>
    inline std::shared_ptr<TexImage2D<
      TARGET_TYPE        ,
      LEVEL_TYPE         ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        ,
      BORDER_TYPE        ,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      PIXELS_TYPE        >> sharedTexImage2D(
        TARGET_TYPE         const&target        ,
        LEVEL_TYPE          const&level         ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ,
        BORDER_TYPE         const&border        ,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        PIXELS_TYPE         const&pixels        ){
        return std::make_shared<TexImage2D<
          TARGET_TYPE        ,
          LEVEL_TYPE         ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        ,
          BORDER_TYPE        ,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          PIXELS_TYPE        >>(
              target        ,
              level         ,
              internalformat,
              width         ,
              height        ,
              border        ,
              format        ,
              type          ,
              pixels        );
    }

    template<
      typename MASK_TYPE = GLuint>
    inline StencilMask<
      MASK_TYPE>* newStencilMask(
        MASK_TYPE const&mask){
        return new StencilMask<
          MASK_TYPE>(
              mask);
    }
    template<
      typename MASK_TYPE = GLuint>
    inline std::shared_ptr<StencilMask<
      MASK_TYPE>> sharedStencilMask(
        MASK_TYPE const&mask){
        return std::make_shared<StencilMask<
          MASK_TYPE>>(
              mask);
    }

    template<
      typename SAMPLER_TYPE = GLuint        ,
      typename PNAME_TYPE   = GLenum        ,
      typename PARAM_TYPE   = const GLfloat*>
    inline SamplerParameterfv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >* newSamplerParameterfv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return new SamplerParameterfv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >(
              sampler,
              pname  ,
              param  );
    }
    template<
      typename SAMPLER_TYPE = GLuint        ,
      typename PNAME_TYPE   = GLenum        ,
      typename PARAM_TYPE   = const GLfloat*>
    inline std::shared_ptr<SamplerParameterfv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAM_TYPE  >> sharedSamplerParameterfv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAM_TYPE   const&param  ){
        return std::make_shared<SamplerParameterfv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAM_TYPE  >>(
              sampler,
              pname  ,
              param  );
    }

    template<
      typename RET_TYPE     = GLboolean,
      typename TEXTURE_TYPE = GLuint   >
    inline IsTexture<
      RET_TYPE    ,
      TEXTURE_TYPE>* newIsTexture(
        RET_TYPE     const&ret    ,
        TEXTURE_TYPE const&texture){
        return new IsTexture<
          RET_TYPE    ,
          TEXTURE_TYPE>(
              ret    ,
              texture);
    }
    template<
      typename RET_TYPE     = GLboolean,
      typename TEXTURE_TYPE = GLuint   >
    inline std::shared_ptr<IsTexture<
      RET_TYPE    ,
      TEXTURE_TYPE>> sharedIsTexture(
        RET_TYPE     const&ret    ,
        TEXTURE_TYPE const&texture){
        return std::make_shared<IsTexture<
          RET_TYPE    ,
          TEXTURE_TYPE>>(
              ret    ,
              texture);
    }

    template<
      typename BUFFER_TYPE = GLuint     ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*,
      typename USAGE_TYPE  = GLenum     >
    inline NamedBufferData<
      BUFFER_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  ,
      USAGE_TYPE >* newNamedBufferData(
        BUFFER_TYPE const&buffer,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ,
        USAGE_TYPE  const&usage ){
        return new NamedBufferData<
          BUFFER_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  ,
          USAGE_TYPE >(
              buffer,
              size  ,
              data  ,
              usage );
    }
    template<
      typename BUFFER_TYPE = GLuint     ,
      typename SIZE_TYPE   = GLsizeiptr ,
      typename DATA_TYPE   = const void*,
      typename USAGE_TYPE  = GLenum     >
    inline std::shared_ptr<NamedBufferData<
      BUFFER_TYPE,
      SIZE_TYPE  ,
      DATA_TYPE  ,
      USAGE_TYPE >> sharedNamedBufferData(
        BUFFER_TYPE const&buffer,
        SIZE_TYPE   const&size  ,
        DATA_TYPE   const&data  ,
        USAGE_TYPE  const&usage ){
        return std::make_shared<NamedBufferData<
          BUFFER_TYPE,
          SIZE_TYPE  ,
          DATA_TYPE  ,
          USAGE_TYPE >>(
              buffer,
              size  ,
              data  ,
              usage );
    }

    template<
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline Uniform1fv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform1fv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform1fv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline std::shared_ptr<Uniform1fv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform1fv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform1fv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLubyte*>
    inline VertexAttrib4Nubv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib4Nubv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib4Nubv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint        ,
      typename V_TYPE     = const GLubyte*>
    inline std::shared_ptr<VertexAttrib4Nubv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib4Nubv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib4Nubv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename BUFFER_TYPE         = GLuint     ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename OFFSET_TYPE         = GLintptr   ,
      typename SIZE_TYPE           = GLsizeiptr ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename DATA_TYPE           = const void*>
    inline ClearNamedBufferSubData<
      BUFFER_TYPE        ,
      INTERNALFORMAT_TYPE,
      OFFSET_TYPE        ,
      SIZE_TYPE          ,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      DATA_TYPE          >* newClearNamedBufferSubData(
        BUFFER_TYPE         const&buffer        ,
        INTERNALFORMAT_TYPE const&internalformat,
        OFFSET_TYPE         const&offset        ,
        SIZE_TYPE           const&size          ,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        DATA_TYPE           const&data          ){
        return new ClearNamedBufferSubData<
          BUFFER_TYPE        ,
          INTERNALFORMAT_TYPE,
          OFFSET_TYPE        ,
          SIZE_TYPE          ,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          DATA_TYPE          >(
              buffer        ,
              internalformat,
              offset        ,
              size          ,
              format        ,
              type          ,
              data          );
    }
    template<
      typename BUFFER_TYPE         = GLuint     ,
      typename INTERNALFORMAT_TYPE = GLenum     ,
      typename OFFSET_TYPE         = GLintptr   ,
      typename SIZE_TYPE           = GLsizeiptr ,
      typename FORMAT_TYPE         = GLenum     ,
      typename TYPE_TYPE           = GLenum     ,
      typename DATA_TYPE           = const void*>
    inline std::shared_ptr<ClearNamedBufferSubData<
      BUFFER_TYPE        ,
      INTERNALFORMAT_TYPE,
      OFFSET_TYPE        ,
      SIZE_TYPE          ,
      FORMAT_TYPE        ,
      TYPE_TYPE          ,
      DATA_TYPE          >> sharedClearNamedBufferSubData(
        BUFFER_TYPE         const&buffer        ,
        INTERNALFORMAT_TYPE const&internalformat,
        OFFSET_TYPE         const&offset        ,
        SIZE_TYPE           const&size          ,
        FORMAT_TYPE         const&format        ,
        TYPE_TYPE           const&type          ,
        DATA_TYPE           const&data          ){
        return std::make_shared<ClearNamedBufferSubData<
          BUFFER_TYPE        ,
          INTERNALFORMAT_TYPE,
          OFFSET_TYPE        ,
          SIZE_TYPE          ,
          FORMAT_TYPE        ,
          TYPE_TYPE          ,
          DATA_TYPE          >>(
              buffer        ,
              internalformat,
              offset        ,
              size          ,
              format        ,
              type          ,
              data          );
    }

    template<
      typename TARGET_TYPE = GLenum        ,
      typename PNAME_TYPE  = GLenum        ,
      typename PARAMS_TYPE = const GLfloat*>
    inline TexParameterfv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newTexParameterfv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new TexParameterfv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum        ,
      typename PNAME_TYPE  = GLenum        ,
      typename PARAMS_TYPE = const GLfloat*>
    inline std::shared_ptr<TexParameterfv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedTexParameterfv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<TexParameterfv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline ScissorIndexedv<
      INDEX_TYPE,
      V_TYPE    >* newScissorIndexedv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new ScissorIndexedv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint      ,
      typename V_TYPE     = const GLint*>
    inline std::shared_ptr<ScissorIndexedv<
      INDEX_TYPE,
      V_TYPE    >> sharedScissorIndexedv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<ScissorIndexedv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline Uniform3dv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform3dv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform3dv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint          ,
      typename COUNT_TYPE    = GLsizei        ,
      typename VALUE_TYPE    = const GLdouble*>
    inline std::shared_ptr<Uniform3dv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform3dv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform3dv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename PROGRAM_TYPE  = GLuint        ,
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline ProgramUniform3fv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform3fv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform3fv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint        ,
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline std::shared_ptr<ProgramUniform3fv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform3fv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform3fv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename RET_TYPE        = GLint        ,
      typename PROGRAM_TYPE    = GLuint       ,
      typename SHADERTYPE_TYPE = GLenum       ,
      typename NAME_TYPE       = const GLchar*>
    inline GetSubroutineUniformLocation<
      RET_TYPE       ,
      PROGRAM_TYPE   ,
      SHADERTYPE_TYPE,
      NAME_TYPE      >* newGetSubroutineUniformLocation(
        RET_TYPE        const&ret       ,
        PROGRAM_TYPE    const&program   ,
        SHADERTYPE_TYPE const&shadertype,
        NAME_TYPE       const&name      ){
        return new GetSubroutineUniformLocation<
          RET_TYPE       ,
          PROGRAM_TYPE   ,
          SHADERTYPE_TYPE,
          NAME_TYPE      >(
              ret       ,
              program   ,
              shadertype,
              name      );
    }
    template<
      typename RET_TYPE        = GLint        ,
      typename PROGRAM_TYPE    = GLuint       ,
      typename SHADERTYPE_TYPE = GLenum       ,
      typename NAME_TYPE       = const GLchar*>
    inline std::shared_ptr<GetSubroutineUniformLocation<
      RET_TYPE       ,
      PROGRAM_TYPE   ,
      SHADERTYPE_TYPE,
      NAME_TYPE      >> sharedGetSubroutineUniformLocation(
        RET_TYPE        const&ret       ,
        PROGRAM_TYPE    const&program   ,
        SHADERTYPE_TYPE const&shadertype,
        NAME_TYPE       const&name      ){
        return std::make_shared<GetSubroutineUniformLocation<
          RET_TYPE       ,
          PROGRAM_TYPE   ,
          SHADERTYPE_TYPE,
          NAME_TYPE      >>(
              ret       ,
              program   ,
              shadertype,
              name      );
    }

    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline GetFramebufferParameteriv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>* newGetFramebufferParameteriv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return new GetFramebufferParameteriv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>(
              target,
              pname ,
              params);
    }
    template<
      typename TARGET_TYPE = GLenum,
      typename PNAME_TYPE  = GLenum,
      typename PARAMS_TYPE = GLint*>
    inline std::shared_ptr<GetFramebufferParameteriv<
      TARGET_TYPE,
      PNAME_TYPE ,
      PARAMS_TYPE>> sharedGetFramebufferParameteriv(
        TARGET_TYPE const&target,
        PNAME_TYPE  const&pname ,
        PARAMS_TYPE const&params){
        return std::make_shared<GetFramebufferParameteriv<
          TARGET_TYPE,
          PNAME_TYPE ,
          PARAMS_TYPE>>(
              target,
              pname ,
              params);
    }

    template<
      typename SAMPLER_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    inline GetSamplerParameteriv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >* newGetSamplerParameteriv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return new GetSamplerParameteriv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >(
              sampler,
              pname  ,
              params );
    }
    template<
      typename SAMPLER_TYPE = GLuint,
      typename PNAME_TYPE   = GLenum,
      typename PARAMS_TYPE  = GLint*>
    inline std::shared_ptr<GetSamplerParameteriv<
      SAMPLER_TYPE,
      PNAME_TYPE  ,
      PARAMS_TYPE >> sharedGetSamplerParameteriv(
        SAMPLER_TYPE const&sampler,
        PNAME_TYPE   const&pname  ,
        PARAMS_TYPE  const&params ){
        return std::make_shared<GetSamplerParameteriv<
          SAMPLER_TYPE,
          PNAME_TYPE  ,
          PARAMS_TYPE >>(
              sampler,
              pname  ,
              params );
    }

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei,
      typename DEPTH_TYPE   = GLsizei,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    inline GetCompressedTextureSubImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      DEPTH_TYPE  ,
      BUFSIZE_TYPE,
      PIXELS_TYPE >* newGetCompressedTextureSubImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        DEPTH_TYPE   const&depth  ,
        BUFSIZE_TYPE const&bufSize,
        PIXELS_TYPE  const&pixels ){
        return new GetCompressedTextureSubImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          DEPTH_TYPE  ,
          BUFSIZE_TYPE,
          PIXELS_TYPE >(
              texture,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              width  ,
              height ,
              depth  ,
              bufSize,
              pixels );
    }
    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename XOFFSET_TYPE = GLint  ,
      typename YOFFSET_TYPE = GLint  ,
      typename ZOFFSET_TYPE = GLint  ,
      typename WIDTH_TYPE   = GLsizei,
      typename HEIGHT_TYPE  = GLsizei,
      typename DEPTH_TYPE   = GLsizei,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    inline std::shared_ptr<GetCompressedTextureSubImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      XOFFSET_TYPE,
      YOFFSET_TYPE,
      ZOFFSET_TYPE,
      WIDTH_TYPE  ,
      HEIGHT_TYPE ,
      DEPTH_TYPE  ,
      BUFSIZE_TYPE,
      PIXELS_TYPE >> sharedGetCompressedTextureSubImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        XOFFSET_TYPE const&xoffset,
        YOFFSET_TYPE const&yoffset,
        ZOFFSET_TYPE const&zoffset,
        WIDTH_TYPE   const&width  ,
        HEIGHT_TYPE  const&height ,
        DEPTH_TYPE   const&depth  ,
        BUFSIZE_TYPE const&bufSize,
        PIXELS_TYPE  const&pixels ){
        return std::make_shared<GetCompressedTextureSubImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          XOFFSET_TYPE,
          YOFFSET_TYPE,
          ZOFFSET_TYPE,
          WIDTH_TYPE  ,
          HEIGHT_TYPE ,
          DEPTH_TYPE  ,
          BUFSIZE_TYPE,
          PIXELS_TYPE >>(
              texture,
              level  ,
              xoffset,
              yoffset,
              zoffset,
              width  ,
              height ,
              depth  ,
              bufSize,
              pixels );
    }

    template<
      typename N_TYPE    = GLsizei      ,
      typename BUFS_TYPE = const GLenum*>
    inline DrawBuffers<
      N_TYPE   ,
      BUFS_TYPE>* newDrawBuffers(
        N_TYPE    const&n   ,
        BUFS_TYPE const&bufs){
        return new DrawBuffers<
          N_TYPE   ,
          BUFS_TYPE>(
              n   ,
              bufs);
    }
    template<
      typename N_TYPE    = GLsizei      ,
      typename BUFS_TYPE = const GLenum*>
    inline std::shared_ptr<DrawBuffers<
      N_TYPE   ,
      BUFS_TYPE>> sharedDrawBuffers(
        N_TYPE    const&n   ,
        BUFS_TYPE const&bufs){
        return std::make_shared<DrawBuffers<
          N_TYPE   ,
          BUFS_TYPE>>(
              n   ,
              bufs);
    }

    template<
      typename FIRST_TYPE    = GLuint       ,
      typename COUNT_TYPE    = GLsizei      ,
      typename SAMPLERS_TYPE = const GLuint*>
    inline BindSamplers<
      FIRST_TYPE   ,
      COUNT_TYPE   ,
      SAMPLERS_TYPE>* newBindSamplers(
        FIRST_TYPE    const&first   ,
        COUNT_TYPE    const&count   ,
        SAMPLERS_TYPE const&samplers){
        return new BindSamplers<
          FIRST_TYPE   ,
          COUNT_TYPE   ,
          SAMPLERS_TYPE>(
              first   ,
              count   ,
              samplers);
    }
    template<
      typename FIRST_TYPE    = GLuint       ,
      typename COUNT_TYPE    = GLsizei      ,
      typename SAMPLERS_TYPE = const GLuint*>
    inline std::shared_ptr<BindSamplers<
      FIRST_TYPE   ,
      COUNT_TYPE   ,
      SAMPLERS_TYPE>> sharedBindSamplers(
        FIRST_TYPE    const&first   ,
        COUNT_TYPE    const&count   ,
        SAMPLERS_TYPE const&samplers){
        return std::make_shared<BindSamplers<
          FIRST_TYPE   ,
          COUNT_TYPE   ,
          SAMPLERS_TYPE>>(
              first   ,
              count   ,
              samplers);
    }

    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    inline VertexAttribI1uiv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttribI1uiv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttribI1uiv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint       ,
      typename V_TYPE     = const GLuint*>
    inline std::shared_ptr<VertexAttribI1uiv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttribI1uiv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttribI1uiv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble>
    inline VertexAttrib2d<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    >* newVertexAttrib2d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ){
        return new VertexAttrib2d<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    >(
              index,
              x    ,
              y    );
    }
    template<
      typename INDEX_TYPE = GLuint  ,
      typename X_TYPE     = GLdouble,
      typename Y_TYPE     = GLdouble>
    inline std::shared_ptr<VertexAttrib2d<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    >> sharedVertexAttrib2d(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ){
        return std::make_shared<VertexAttrib2d<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    >>(
              index,
              x    ,
              y    );
    }

    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat,
      typename Y_TYPE     = GLfloat>
    inline VertexAttrib2f<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    >* newVertexAttrib2f(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ){
        return new VertexAttrib2f<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    >(
              index,
              x    ,
              y    );
    }
    template<
      typename INDEX_TYPE = GLuint ,
      typename X_TYPE     = GLfloat,
      typename Y_TYPE     = GLfloat>
    inline std::shared_ptr<VertexAttrib2f<
      INDEX_TYPE,
      X_TYPE    ,
      Y_TYPE    >> sharedVertexAttrib2f(
        INDEX_TYPE const&index,
        X_TYPE     const&x    ,
        Y_TYPE     const&y    ){
        return std::make_shared<VertexAttrib2f<
          INDEX_TYPE,
          X_TYPE    ,
          Y_TYPE    >>(
              index,
              x    ,
              y    );
    }

    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline VertexAttrib3dv<
      INDEX_TYPE,
      V_TYPE    >* newVertexAttrib3dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return new VertexAttrib3dv<
          INDEX_TYPE,
          V_TYPE    >(
              index,
              v    );
    }
    template<
      typename INDEX_TYPE = GLuint         ,
      typename V_TYPE     = const GLdouble*>
    inline std::shared_ptr<VertexAttrib3dv<
      INDEX_TYPE,
      V_TYPE    >> sharedVertexAttrib3dv(
        INDEX_TYPE const&index,
        V_TYPE     const&v    ){
        return std::make_shared<VertexAttrib3dv<
          INDEX_TYPE,
          V_TYPE    >>(
              index,
              v    );
    }

    template<
      typename SRCNAME_TYPE   = GLuint ,
      typename SRCTARGET_TYPE = GLenum ,
      typename SRCLEVEL_TYPE  = GLint  ,
      typename SRCX_TYPE      = GLint  ,
      typename SRCY_TYPE      = GLint  ,
      typename SRCZ_TYPE      = GLint  ,
      typename DSTNAME_TYPE   = GLuint ,
      typename DSTTARGET_TYPE = GLenum ,
      typename DSTLEVEL_TYPE  = GLint  ,
      typename DSTX_TYPE      = GLint  ,
      typename DSTY_TYPE      = GLint  ,
      typename DSTZ_TYPE      = GLint  ,
      typename SRCWIDTH_TYPE  = GLsizei,
      typename SRCHEIGHT_TYPE = GLsizei,
      typename SRCDEPTH_TYPE  = GLsizei>
    inline CopyImageSubData<
      SRCNAME_TYPE  ,
      SRCTARGET_TYPE,
      SRCLEVEL_TYPE ,
      SRCX_TYPE     ,
      SRCY_TYPE     ,
      SRCZ_TYPE     ,
      DSTNAME_TYPE  ,
      DSTTARGET_TYPE,
      DSTLEVEL_TYPE ,
      DSTX_TYPE     ,
      DSTY_TYPE     ,
      DSTZ_TYPE     ,
      SRCWIDTH_TYPE ,
      SRCHEIGHT_TYPE,
      SRCDEPTH_TYPE >* newCopyImageSubData(
        SRCNAME_TYPE   const&srcName  ,
        SRCTARGET_TYPE const&srcTarget,
        SRCLEVEL_TYPE  const&srcLevel ,
        SRCX_TYPE      const&srcX     ,
        SRCY_TYPE      const&srcY     ,
        SRCZ_TYPE      const&srcZ     ,
        DSTNAME_TYPE   const&dstName  ,
        DSTTARGET_TYPE const&dstTarget,
        DSTLEVEL_TYPE  const&dstLevel ,
        DSTX_TYPE      const&dstX     ,
        DSTY_TYPE      const&dstY     ,
        DSTZ_TYPE      const&dstZ     ,
        SRCWIDTH_TYPE  const&srcWidth ,
        SRCHEIGHT_TYPE const&srcHeight,
        SRCDEPTH_TYPE  const&srcDepth ){
        return new CopyImageSubData<
          SRCNAME_TYPE  ,
          SRCTARGET_TYPE,
          SRCLEVEL_TYPE ,
          SRCX_TYPE     ,
          SRCY_TYPE     ,
          SRCZ_TYPE     ,
          DSTNAME_TYPE  ,
          DSTTARGET_TYPE,
          DSTLEVEL_TYPE ,
          DSTX_TYPE     ,
          DSTY_TYPE     ,
          DSTZ_TYPE     ,
          SRCWIDTH_TYPE ,
          SRCHEIGHT_TYPE,
          SRCDEPTH_TYPE >(
              srcName  ,
              srcTarget,
              srcLevel ,
              srcX     ,
              srcY     ,
              srcZ     ,
              dstName  ,
              dstTarget,
              dstLevel ,
              dstX     ,
              dstY     ,
              dstZ     ,
              srcWidth ,
              srcHeight,
              srcDepth );
    }
    template<
      typename SRCNAME_TYPE   = GLuint ,
      typename SRCTARGET_TYPE = GLenum ,
      typename SRCLEVEL_TYPE  = GLint  ,
      typename SRCX_TYPE      = GLint  ,
      typename SRCY_TYPE      = GLint  ,
      typename SRCZ_TYPE      = GLint  ,
      typename DSTNAME_TYPE   = GLuint ,
      typename DSTTARGET_TYPE = GLenum ,
      typename DSTLEVEL_TYPE  = GLint  ,
      typename DSTX_TYPE      = GLint  ,
      typename DSTY_TYPE      = GLint  ,
      typename DSTZ_TYPE      = GLint  ,
      typename SRCWIDTH_TYPE  = GLsizei,
      typename SRCHEIGHT_TYPE = GLsizei,
      typename SRCDEPTH_TYPE  = GLsizei>
    inline std::shared_ptr<CopyImageSubData<
      SRCNAME_TYPE  ,
      SRCTARGET_TYPE,
      SRCLEVEL_TYPE ,
      SRCX_TYPE     ,
      SRCY_TYPE     ,
      SRCZ_TYPE     ,
      DSTNAME_TYPE  ,
      DSTTARGET_TYPE,
      DSTLEVEL_TYPE ,
      DSTX_TYPE     ,
      DSTY_TYPE     ,
      DSTZ_TYPE     ,
      SRCWIDTH_TYPE ,
      SRCHEIGHT_TYPE,
      SRCDEPTH_TYPE >> sharedCopyImageSubData(
        SRCNAME_TYPE   const&srcName  ,
        SRCTARGET_TYPE const&srcTarget,
        SRCLEVEL_TYPE  const&srcLevel ,
        SRCX_TYPE      const&srcX     ,
        SRCY_TYPE      const&srcY     ,
        SRCZ_TYPE      const&srcZ     ,
        DSTNAME_TYPE   const&dstName  ,
        DSTTARGET_TYPE const&dstTarget,
        DSTLEVEL_TYPE  const&dstLevel ,
        DSTX_TYPE      const&dstX     ,
        DSTY_TYPE      const&dstY     ,
        DSTZ_TYPE      const&dstZ     ,
        SRCWIDTH_TYPE  const&srcWidth ,
        SRCHEIGHT_TYPE const&srcHeight,
        SRCDEPTH_TYPE  const&srcDepth ){
        return std::make_shared<CopyImageSubData<
          SRCNAME_TYPE  ,
          SRCTARGET_TYPE,
          SRCLEVEL_TYPE ,
          SRCX_TYPE     ,
          SRCY_TYPE     ,
          SRCZ_TYPE     ,
          DSTNAME_TYPE  ,
          DSTTARGET_TYPE,
          DSTLEVEL_TYPE ,
          DSTX_TYPE     ,
          DSTY_TYPE     ,
          DSTZ_TYPE     ,
          SRCWIDTH_TYPE ,
          SRCHEIGHT_TYPE,
          SRCDEPTH_TYPE >>(
              srcName  ,
              srcTarget,
              srcLevel ,
              srcX     ,
              srcY     ,
              srcZ     ,
              dstName  ,
              dstTarget,
              dstLevel ,
              dstX     ,
              dstY     ,
              dstZ     ,
              srcWidth ,
              srcHeight,
              srcDepth );
    }

    template<
      typename PIPELINE_TYPE = GLuint,
      typename PROGRAM_TYPE  = GLuint>
    inline ActiveShaderProgram<
      PIPELINE_TYPE,
      PROGRAM_TYPE >* newActiveShaderProgram(
        PIPELINE_TYPE const&pipeline,
        PROGRAM_TYPE  const&program ){
        return new ActiveShaderProgram<
          PIPELINE_TYPE,
          PROGRAM_TYPE >(
              pipeline,
              program );
    }
    template<
      typename PIPELINE_TYPE = GLuint,
      typename PROGRAM_TYPE  = GLuint>
    inline std::shared_ptr<ActiveShaderProgram<
      PIPELINE_TYPE,
      PROGRAM_TYPE >> sharedActiveShaderProgram(
        PIPELINE_TYPE const&pipeline,
        PROGRAM_TYPE  const&program ){
        return std::make_shared<ActiveShaderProgram<
          PIPELINE_TYPE,
          PROGRAM_TYPE >>(
              pipeline,
              program );
    }

    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename FORMAT_TYPE  = GLenum ,
      typename TYPE_TYPE    = GLenum ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    inline GetTextureImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      BUFSIZE_TYPE,
      PIXELS_TYPE >* newGetTextureImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        BUFSIZE_TYPE const&bufSize,
        PIXELS_TYPE  const&pixels ){
        return new GetTextureImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          BUFSIZE_TYPE,
          PIXELS_TYPE >(
              texture,
              level  ,
              format ,
              type   ,
              bufSize,
              pixels );
    }
    template<
      typename TEXTURE_TYPE = GLuint ,
      typename LEVEL_TYPE   = GLint  ,
      typename FORMAT_TYPE  = GLenum ,
      typename TYPE_TYPE    = GLenum ,
      typename BUFSIZE_TYPE = GLsizei,
      typename PIXELS_TYPE  = void*  >
    inline std::shared_ptr<GetTextureImage<
      TEXTURE_TYPE,
      LEVEL_TYPE  ,
      FORMAT_TYPE ,
      TYPE_TYPE   ,
      BUFSIZE_TYPE,
      PIXELS_TYPE >> sharedGetTextureImage(
        TEXTURE_TYPE const&texture,
        LEVEL_TYPE   const&level  ,
        FORMAT_TYPE  const&format ,
        TYPE_TYPE    const&type   ,
        BUFSIZE_TYPE const&bufSize,
        PIXELS_TYPE  const&pixels ){
        return std::make_shared<GetTextureImage<
          TEXTURE_TYPE,
          LEVEL_TYPE  ,
          FORMAT_TYPE ,
          TYPE_TYPE   ,
          BUFSIZE_TYPE,
          PIXELS_TYPE >>(
              texture,
              level  ,
              format ,
              type   ,
              bufSize,
              pixels );
    }

    template<
      typename PNAME_TYPE  = GLenum        ,
      typename VALUES_TYPE = const GLfloat*>
    inline PatchParameterfv<
      PNAME_TYPE ,
      VALUES_TYPE>* newPatchParameterfv(
        PNAME_TYPE  const&pname ,
        VALUES_TYPE const&values){
        return new PatchParameterfv<
          PNAME_TYPE ,
          VALUES_TYPE>(
              pname ,
              values);
    }
    template<
      typename PNAME_TYPE  = GLenum        ,
      typename VALUES_TYPE = const GLfloat*>
    inline std::shared_ptr<PatchParameterfv<
      PNAME_TYPE ,
      VALUES_TYPE>> sharedPatchParameterfv(
        PNAME_TYPE  const&pname ,
        VALUES_TYPE const&values){
        return std::make_shared<PatchParameterfv<
          PNAME_TYPE ,
          VALUES_TYPE>>(
              pname ,
              values);
    }

    template<
      typename PROGRAM_TYPE  = GLuint        ,
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline ProgramUniform1fv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newProgramUniform1fv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new ProgramUniform1fv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              program ,
              location,
              count   ,
              value   );
    }
    template<
      typename PROGRAM_TYPE  = GLuint        ,
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline std::shared_ptr<ProgramUniform1fv<
      PROGRAM_TYPE ,
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedProgramUniform1fv(
        PROGRAM_TYPE  const&program ,
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<ProgramUniform1fv<
          PROGRAM_TYPE ,
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              program ,
              location,
              count   ,
              value   );
    }

    template<
      typename RET_TYPE              = GLuint       ,
      typename PROGRAM_TYPE          = GLuint       ,
      typename UNIFORMBLOCKNAME_TYPE = const GLchar*>
    inline GetUniformBlockIndex<
      RET_TYPE             ,
      PROGRAM_TYPE         ,
      UNIFORMBLOCKNAME_TYPE>* newGetUniformBlockIndex(
        RET_TYPE              const&ret             ,
        PROGRAM_TYPE          const&program         ,
        UNIFORMBLOCKNAME_TYPE const&uniformBlockName){
        return new GetUniformBlockIndex<
          RET_TYPE             ,
          PROGRAM_TYPE         ,
          UNIFORMBLOCKNAME_TYPE>(
              ret             ,
              program         ,
              uniformBlockName);
    }
    template<
      typename RET_TYPE              = GLuint       ,
      typename PROGRAM_TYPE          = GLuint       ,
      typename UNIFORMBLOCKNAME_TYPE = const GLchar*>
    inline std::shared_ptr<GetUniformBlockIndex<
      RET_TYPE             ,
      PROGRAM_TYPE         ,
      UNIFORMBLOCKNAME_TYPE>> sharedGetUniformBlockIndex(
        RET_TYPE              const&ret             ,
        PROGRAM_TYPE          const&program         ,
        UNIFORMBLOCKNAME_TYPE const&uniformBlockName){
        return std::make_shared<GetUniformBlockIndex<
          RET_TYPE             ,
          PROGRAM_TYPE         ,
          UNIFORMBLOCKNAME_TYPE>>(
              ret             ,
              program         ,
              uniformBlockName);
    }

    template<
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline Uniform4fv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >* newUniform4fv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return new Uniform4fv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >(
              location,
              count   ,
              value   );
    }
    template<
      typename LOCATION_TYPE = GLint         ,
      typename COUNT_TYPE    = GLsizei       ,
      typename VALUE_TYPE    = const GLfloat*>
    inline std::shared_ptr<Uniform4fv<
      LOCATION_TYPE,
      COUNT_TYPE   ,
      VALUE_TYPE   >> sharedUniform4fv(
        LOCATION_TYPE const&location,
        COUNT_TYPE    const&count   ,
        VALUE_TYPE    const&value   ){
        return std::make_shared<Uniform4fv<
          LOCATION_TYPE,
          COUNT_TYPE   ,
          VALUE_TYPE   >>(
              location,
              count   ,
              value   );
    }

    template<
      typename TEXTURE_TYPE        = GLuint ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    inline TextureStorage2D<
      TEXTURE_TYPE       ,
      LEVELS_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >* newTextureStorage2D(
        TEXTURE_TYPE        const&texture       ,
        LEVELS_TYPE         const&levels        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return new TextureStorage2D<
          TEXTURE_TYPE       ,
          LEVELS_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >(
              texture       ,
              levels        ,
              internalformat,
              width         ,
              height        );
    }
    template<
      typename TEXTURE_TYPE        = GLuint ,
      typename LEVELS_TYPE         = GLsizei,
      typename INTERNALFORMAT_TYPE = GLenum ,
      typename WIDTH_TYPE          = GLsizei,
      typename HEIGHT_TYPE         = GLsizei>
    inline std::shared_ptr<TextureStorage2D<
      TEXTURE_TYPE       ,
      LEVELS_TYPE        ,
      INTERNALFORMAT_TYPE,
      WIDTH_TYPE         ,
      HEIGHT_TYPE        >> sharedTextureStorage2D(
        TEXTURE_TYPE        const&texture       ,
        LEVELS_TYPE         const&levels        ,
        INTERNALFORMAT_TYPE const&internalformat,
        WIDTH_TYPE          const&width         ,
        HEIGHT_TYPE         const&height        ){
        return std::make_shared<TextureStorage2D<
          TEXTURE_TYPE       ,
          LEVELS_TYPE        ,
          INTERNALFORMAT_TYPE,
          WIDTH_TYPE         ,
          HEIGHT_TYPE        >>(
              texture       ,
              levels        ,
              internalformat,
              width         ,
              height        );
    }

    template<
      typename MODE_TYPE = GLenum>
    inline FrontFace<
      MODE_TYPE>* newFrontFace(
        MODE_TYPE const&mode){
        return new FrontFace<
          MODE_TYPE>(
              mode);
    }
    template<
      typename MODE_TYPE = GLenum>
    inline std::shared_ptr<FrontFace<
      MODE_TYPE>> sharedFrontFace(
        MODE_TYPE const&mode){
        return std::make_shared<FrontFace<
          MODE_TYPE>>(
              mode);
    }

    template<
      typename TARGET_TYPE         = GLenum    ,
      typename INTERNALFORMAT_TYPE = GLenum    ,
      typename BUFFER_TYPE         = GLuint    ,
      typename OFFSET_TYPE         = GLintptr  ,
      typename SIZE_TYPE           = GLsizeiptr>
    inline TexBufferRange<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      BUFFER_TYPE        ,
      OFFSET_TYPE        ,
      SIZE_TYPE          >* newTexBufferRange(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        BUFFER_TYPE         const&buffer        ,
        OFFSET_TYPE         const&offset        ,
        SIZE_TYPE           const&size          ){
        return new TexBufferRange<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          BUFFER_TYPE        ,
          OFFSET_TYPE        ,
          SIZE_TYPE          >(
              target        ,
              internalformat,
              buffer        ,
              offset        ,
              size          );
    }
    template<
      typename TARGET_TYPE         = GLenum    ,
      typename INTERNALFORMAT_TYPE = GLenum    ,
      typename BUFFER_TYPE         = GLuint    ,
      typename OFFSET_TYPE         = GLintptr  ,
      typename SIZE_TYPE           = GLsizeiptr>
    inline std::shared_ptr<TexBufferRange<
      TARGET_TYPE        ,
      INTERNALFORMAT_TYPE,
      BUFFER_TYPE        ,
      OFFSET_TYPE        ,
      SIZE_TYPE          >> sharedTexBufferRange(
        TARGET_TYPE         const&target        ,
        INTERNALFORMAT_TYPE const&internalformat,
        BUFFER_TYPE         const&buffer        ,
        OFFSET_TYPE         const&offset        ,
        SIZE_TYPE           const&size          ){
        return std::make_shared<TexBufferRange<
          TARGET_TYPE        ,
          INTERNALFORMAT_TYPE,
          BUFFER_TYPE        ,
          OFFSET_TYPE        ,
          SIZE_TYPE          >>(
              target        ,
              internalformat,
              buffer        ,
              offset        ,
              size          );
    }

    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename ATTACHMENT_TYPE  = GLenum,
      typename TEXTURE_TYPE     = GLuint,
      typename LEVEL_TYPE       = GLint ,
      typename LAYER_TYPE       = GLint >
    inline NamedFramebufferTextureLayer<
      FRAMEBUFFER_TYPE,
      ATTACHMENT_TYPE ,
      TEXTURE_TYPE    ,
      LEVEL_TYPE      ,
      LAYER_TYPE      >* newNamedFramebufferTextureLayer(
        FRAMEBUFFER_TYPE const&framebuffer,
        ATTACHMENT_TYPE  const&attachment ,
        TEXTURE_TYPE     const&texture    ,
        LEVEL_TYPE       const&level      ,
        LAYER_TYPE       const&layer      ){
        return new NamedFramebufferTextureLayer<
          FRAMEBUFFER_TYPE,
          ATTACHMENT_TYPE ,
          TEXTURE_TYPE    ,
          LEVEL_TYPE      ,
          LAYER_TYPE      >(
              framebuffer,
              attachment ,
              texture    ,
              level      ,
              layer      );
    }
    template<
      typename FRAMEBUFFER_TYPE = GLuint,
      typename ATTACHMENT_TYPE  = GLenum,
      typename TEXTURE_TYPE     = GLuint,
      typename LEVEL_TYPE       = GLint ,
      typename LAYER_TYPE       = GLint >
    inline std::shared_ptr<NamedFramebufferTextureLayer<
      FRAMEBUFFER_TYPE,
      ATTACHMENT_TYPE ,
      TEXTURE_TYPE    ,
      LEVEL_TYPE      ,
      LAYER_TYPE      >> sharedNamedFramebufferTextureLayer(
        FRAMEBUFFER_TYPE const&framebuffer,
        ATTACHMENT_TYPE  const&attachment ,
        TEXTURE_TYPE     const&texture    ,
        LEVEL_TYPE       const&level      ,
        LAYER_TYPE       const&layer      ){
        return std::make_shared<NamedFramebufferTextureLayer<
          FRAMEBUFFER_TYPE,
          ATTACHMENT_TYPE ,
          TEXTURE_TYPE    ,
          LEVEL_TYPE      ,
          LAYER_TYPE      >>(
              framebuffer,
              attachment ,
              texture    ,
              level      ,
              layer      );
    }

    template<
      typename MODE_TYPE          = GLenum ,
      typename FIRST_TYPE         = GLint  ,
      typename COUNT_TYPE         = GLsizei,
      typename INSTANCECOUNT_TYPE = GLsizei,
      typename BASEINSTANCE_TYPE  = GLuint >
    inline DrawArraysInstancedBaseInstance<
      MODE_TYPE         ,
      FIRST_TYPE        ,
      COUNT_TYPE        ,
      INSTANCECOUNT_TYPE,
      BASEINSTANCE_TYPE >* newDrawArraysInstancedBaseInstance(
        MODE_TYPE          const&mode         ,
        FIRST_TYPE         const&first        ,
        COUNT_TYPE         const&count        ,
        INSTANCECOUNT_TYPE const&instancecount,
        BASEINSTANCE_TYPE  const&baseinstance ){
        return new DrawArraysInstancedBaseInstance<
          MODE_TYPE         ,
          FIRST_TYPE        ,
          COUNT_TYPE        ,
          INSTANCECOUNT_TYPE,
          BASEINSTANCE_TYPE >(
              mode         ,
              first        ,
              count        ,
              instancecount,
              baseinstance );
    }
    template<
      typename MODE_TYPE          = GLenum ,
      typename FIRST_TYPE         = GLint  ,
      typename COUNT_TYPE         = GLsizei,
      typename INSTANCECOUNT_TYPE = GLsizei,
      typename BASEINSTANCE_TYPE  = GLuint >
    inline std::shared_ptr<DrawArraysInstancedBaseInstance<
      MODE_TYPE         ,
      FIRST_TYPE        ,
      COUNT_TYPE        ,
      INSTANCECOUNT_TYPE,
      BASEINSTANCE_TYPE >> sharedDrawArraysInstancedBaseInstance(
        MODE_TYPE          const&mode         ,
        FIRST_TYPE         const&first        ,
        COUNT_TYPE         const&count        ,
        INSTANCECOUNT_TYPE const&instancecount,
        BASEINSTANCE_TYPE  const&baseinstance ){
        return std::make_shared<DrawArraysInstancedBaseInstance<
          MODE_TYPE         ,
          FIRST_TYPE        ,
          COUNT_TYPE        ,
          INSTANCECOUNT_TYPE,
          BASEINSTANCE_TYPE >>(
              mode         ,
              first        ,
              count        ,
              instancecount,
              baseinstance );
    }

    template<
      typename N_TYPE         = GLsizei      ,
      typename PIPELINES_TYPE = const GLuint*>
    inline DeleteProgramPipelines<
      N_TYPE        ,
      PIPELINES_TYPE>* newDeleteProgramPipelines(
        N_TYPE         const&n        ,
        PIPELINES_TYPE const&pipelines){
        return new DeleteProgramPipelines<
          N_TYPE        ,
          PIPELINES_TYPE>(
              n        ,
              pipelines);
    }
    template<
      typename N_TYPE         = GLsizei      ,
      typename PIPELINES_TYPE = const GLuint*>
    inline std::shared_ptr<DeleteProgramPipelines<
      N_TYPE        ,
      PIPELINES_TYPE>> sharedDeleteProgramPipelines(
        N_TYPE         const&n        ,
        PIPELINES_TYPE const&pipelines){
        return std::make_shared<DeleteProgramPipelines<
          N_TYPE        ,
          PIPELINES_TYPE>>(
              n        ,
              pipelines);
    }

  }
}
